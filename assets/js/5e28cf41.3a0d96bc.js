"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[6457],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(96540);const l={},t=i.createContext(l);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},57197:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"game-scripts/core-systems/fundamentals/utilities/fileutil","title":"File Utilities","description":"Utility functions for managing persistent file operations including deletion and existence checking","source":"@site/docs/game-scripts/core-systems/fundamentals/utilities/fileutil.md","sourceDirName":"game-scripts/core-systems/fundamentals/utilities","slug":"/game-scripts/core-systems/fundamentals/utilities/fileutil","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/utilities/fileutil","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"id":"fileutil","title":"File Utilities","description":"Utility functions for managing persistent file operations including deletion and existence checking","sidebar_position":9,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Component Utilities","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/utilities/componentutil"},"next":{"title":"Math Utilities","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/utilities/mathutil"}}');var l=s(74848),t=s(28453);const r={id:"fileutil",title:"File Utilities",description:"Utility functions for managing persistent file operations including deletion and existence checking",sidebar_position:9,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},a="File Utilities",c={},d=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Functions",id:"functions",level:2},{value:"EraseFiles(cb, files)",id:"erase-files",level:3},{value:"CheckFiles(cb, files)",id:"check-files",level:3},{value:"Common Usage Patterns",id:"common-usage-patterns",level:2},{value:"Batch File Management",id:"batch-file-management",level:3},{value:"File Validation",id:"file-validation",level:3},{value:"Conditional File Operations",id:"conditional-file-operations",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Platform Considerations",id:"platform-considerations",level:2},{value:"PS4 Platform",id:"ps4-platform",level:3},{value:"Other Platforms",id:"other-platforms",level:3},{value:"Related Modules",id:"related-modules",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"file-utilities",children:"File Utilities"})}),"\n",(0,l.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Build Version"}),(0,l.jsx)(n.th,{children:"Change Date"}),(0,l.jsx)(n.th,{children:"Change Type"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"676042"}),(0,l.jsx)(n.td,{children:"2025-06-21"}),(0,l.jsx)(n.td,{children:"stable"}),(0,l.jsx)(n.td,{children:"Current version"})]})})]}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"fileutil.lua"})," module provides utility functions for managing persistent file operations in Don't Starve Together. It offers asynchronous functions for bulk file deletion and existence checking, with platform-specific optimizations and callback-based result handling."]}),"\n",(0,l.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Check if multiple files exist\nlocal files_to_check = {"save1.lua", "save2.lua", "config.lua"}\nCheckFiles(function(status)\n    for file, exists in pairs(status) do\n        print(file .. " exists: " .. tostring(exists))\n    end\nend, files_to_check)\n\n-- Erase multiple files\nlocal files_to_delete = {"temp1.lua", "temp2.lua"}\nEraseFiles(function(success, deleted)\n    if success then\n        print("All files deleted successfully")\n        for _, file in ipairs(deleted) do\n            print("Deleted: " .. file)\n        end\n    else\n        print("Some files failed to delete")\n    end\nend, files_to_delete)\n'})}),"\n",(0,l.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,l.jsx)(n.h3,{id:"erase-files",children:"EraseFiles(cb, files)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nAsynchronously deletes multiple persistent files with platform-specific handling and provides callback results."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"cb"})," (function): Callback function called when all operations complete","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"success"})," (boolean): Whether all files were successfully deleted"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"deleted_files"})," (table): Array of successfully deleted file names"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"files"})," (table): Array of file names to delete"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"None (asynchronous operation with callback)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Platform Behavior:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"PS4"}),": Skips existence check and directly attempts deletion"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Other platforms"}),": Checks file existence before attempting deletion"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'local files = {"save_backup.lua", "temp_data.lua"}\nEraseFiles(function(overall_success, deleted_files)\n    if overall_success then\n        print("All " .. #deleted_files .. " files deleted successfully")\n    else\n        print("Some files failed to delete. Deleted: " .. #deleted_files)\n    end\n    \n    for _, filename in ipairs(deleted_files) do\n        print("Successfully deleted: " .. filename)\n    end\nend, files)\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Implementation Details:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"-- Internal callback handling\nlocal function onerased(success, file)\n    res[file] = nil\n    if success then\n        table.insert(deleted_files, file)\n    else\n        overall_success = false\n    end\n    \n    if not next(res) then\n        if cb then\n            cb(overall_success, deleted_files)\n        end\n    end\nend\n"})}),"\n",(0,l.jsx)(n.h3,{id:"check-files",children:"CheckFiles(cb, files)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nAsynchronously checks the existence of multiple persistent files and returns their status via callback."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"cb"})," (function): Callback function called when all checks complete","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"file_status"})," (table): Map of filename to boolean existence status"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"files"})," (table): Array of file names to check"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"None (asynchronous operation with callback)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'local files_to_verify = {"player_data.lua", "world_settings.lua", "mod_config.lua"}\nCheckFiles(function(status)\n    for filename, exists in pairs(status) do\n        if exists then\n            print(filename .. " found")\n        else\n            print(filename .. " missing")\n        end\n    end\nend, files_to_verify)\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Implementation Details:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"-- Internal callback for each file check\nlocal function onchecked(success, file)\n    res[file] = nil\n    file_status[file] = success\n    \n    if not next(res) then\n        if cb then\n            cb(file_status)\n        end\n    end\nend\n"})}),"\n",(0,l.jsx)(n.h2,{id:"common-usage-patterns",children:"Common Usage Patterns"}),"\n",(0,l.jsx)(n.h3,{id:"batch-file-management",children:"Batch File Management"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Clean up temporary files\nlocal temp_files = {"cache1.tmp", "cache2.tmp", "debug.log"}\nEraseFiles(function(success, deleted)\n    print("Cleanup complete. Deleted " .. #deleted .. " files")\nend, temp_files)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"file-validation",children:"File Validation"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Verify required files exist before proceeding\nlocal required_files = {"config.lua", "save_data.lua"}\nCheckFiles(function(status)\n    local all_exist = true\n    for file, exists in pairs(status) do\n        if not exists then\n            all_exist = false\n            print("Missing required file: " .. file)\n        end\n    end\n    \n    if all_exist then\n        print("All required files present")\n        -- Proceed with initialization\n    end\nend, required_files)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"conditional-file-operations",children:"Conditional File Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Check then delete pattern\nlocal files_to_process = {"old_save1.lua", "old_save2.lua"}\nCheckFiles(function(status)\n    local existing_files = {}\n    for file, exists in pairs(status) do\n        if exists then\n            table.insert(existing_files, file)\n        end\n    end\n    \n    if #existing_files > 0 then\n        EraseFiles(function(success, deleted)\n            print("Deleted " .. #deleted .. " existing files")\n        end, existing_files)\n    end\nend, files_to_process)\n'})}),"\n",(0,l.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,l.jsx)(n.p,{children:"Both functions handle errors gracefully:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Empty file lists"}),": Callbacks are executed immediately with appropriate empty results"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Missing files"}),": ",(0,l.jsx)(n.code,{children:"EraseFiles"})," treats missing files as successful deletions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Platform differences"}),": PS4 optimization skips unnecessary existence checks"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Asynchronous safety"}),": Proper callback management ensures all operations complete"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"platform-considerations",children:"Platform Considerations"}),"\n",(0,l.jsx)(n.h3,{id:"ps4-platform",children:"PS4 Platform"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Skips existence checks for better performance"}),"\n",(0,l.jsx)(n.li,{children:"Directly attempts file deletion"}),"\n",(0,l.jsxs)(n.li,{children:["Uses ",(0,l.jsx)(n.code,{children:"ErasePersistentString"})," directly"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"other-platforms",children:"Other Platforms"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Performs existence check before deletion attempts"}),"\n",(0,l.jsxs)(n.li,{children:["Uses ",(0,l.jsx)(n.code,{children:"TheSim:CheckPersistentStringExists"})," for verification"]}),"\n",(0,l.jsx)(n.li,{children:"More conservative approach to prevent unnecessary operations"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./thesim.md",children:"TheSim"}),": Provides low-level file system operations"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./persistence.md",children:"Persistence"}),": Higher-level save data management"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./saveindex.md",children:"SaveIndex"}),": Save file indexing and management"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}}}]);