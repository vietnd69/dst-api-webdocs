"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[7118],{4095:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api-vanilla/stategraphs/stategraphs-overview","title":"Stategraphs Overview","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/stategraphs/index.md","sourceDirName":"api-vanilla/stategraphs","slug":"/api/stategraphs","permalink":"/dst-api-webdocs/docs/api/stategraphs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"stategraphs-overview","title":"Stategraphs Overview","sidebar_position":1,"last_updated":"2023-07-06T00:00:00.000Z","slug":"/api/stategraphs"},"sidebar":"docs","previous":{"title":"State Graphs","permalink":"/dst-api-webdocs/docs/category/state-graphs"},"next":{"title":"States API","permalink":"/dst-api-webdocs/docs/api-vanilla/stategraphs/states"}}');var i=t(4848),s=t(8453);const o={id:"stategraphs-overview",title:"Stategraphs Overview",sidebar_position:1,last_updated:new Date("2023-07-06T00:00:00.000Z"),slug:"/api/stategraphs"},r="Stategraphs Overview",l={},c=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"State Graph and Animation System Integration",id:"state-graph-and-animation-system-integration",level:2},{value:"Creating a Stategraph",id:"creating-a-stategraph",level:2},{value:"Using Stategraphs",id:"using-stategraphs",level:2},{value:"Stategraph and Animation Best Practices",id:"stategraph-and-animation-best-practices",level:2},{value:"Common States and Handlers",id:"common-states-and-handlers",level:2},{value:"Advanced Stategraph Features",id:"advanced-stategraph-features",level:2},{value:"State Memory",id:"state-memory",level:3},{value:"State Tags",id:"state-tags",level:3},{value:"State Timeouts",id:"state-timeouts",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"stategraphs-overview",children:"Stategraphs Overview"})}),"\n",(0,i.jsx)(e.p,{children:"Stategraphs are a powerful state machine system that controls entity behavior, animations, and interactions in Don't Starve Together. They provide a structured way to define how entities transition between different states based on events and actions."}),"\n",(0,i.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(e.p,{children:"A stategraph consists of several key components:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"States"}),": Defined behaviors that an entity can be in at any given time (e.g., idle, walking, attacking)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Events"}),": Triggers that can cause state transitions (e.g., receiving damage, reaching a target)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transitions"}),": Rules for moving between states in response to events"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ActionHandlers"}),": Special handlers for gameplay actions initiated by the player or AI"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Timeline Events"}),": Functions triggered at specific frames during animations"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(e.p,{children:"The stategraph system is designed as a finite state machine where:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"An entity can only be in one state at a time"}),"\n",(0,i.jsx)(e.li,{children:"States have entry and exit functions that control behavior"}),"\n",(0,i.jsx)(e.li,{children:"Events can trigger transitions between states"}),"\n",(0,i.jsx)(e.li,{children:"States can be tagged for easier querying"}),"\n",(0,i.jsx)(e.li,{children:"The stategraph maintains its own memory that persists across state transitions"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This architecture allows for complex behavior patterns while keeping code organized and maintainable."}),"\n",(0,i.jsx)(e.h2,{id:"state-graph-and-animation-system-integration",children:"State Graph and Animation System Integration"}),"\n",(0,i.jsx)(e.p,{children:"One of the most powerful aspects of stategraphs is their tight integration with the animation system:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'State{\n    name = "attack",\n    tags = {"attack", "busy"},\n    \n    onenter = function(inst)\n        -- Play the attack animation when entering this state\n        inst.AnimState:PlayAnimation("attack")\n        \n        -- Configure combat component\n        inst.components.combat:StartAttack()\n    end,\n    \n    -- Timeline events synchronize code execution with specific animation frames\n    timeline = {\n        -- At frame 10, perform the actual attack\n        TimeEvent(10*FRAMES, function(inst) \n            inst.components.combat:DoAttack()\n            -- Play a sound exactly when the attack animation shows impact\n            inst.SoundEmitter:PlaySound("dontstarve/creatures/spider/attack")\n        end),\n    },\n    \n    -- When animation finishes, return to idle state\n    events = {\n        EventHandler("animover", function(inst)\n            inst.sg:GoToState("idle")\n        end),\n    },\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"This synchronization ensures that visual feedback, sound effects, and gameplay mechanics all align perfectly."}),"\n",(0,i.jsx)(e.h2,{id:"creating-a-stategraph",children:"Creating a Stategraph"}),"\n",(0,i.jsx)(e.p,{children:"To create a stategraph, you'll need to:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Define the states with their enter/exit behaviors and timelines"}),"\n",(0,i.jsx)(e.li,{children:"Set up event handlers to respond to game events"}),"\n",(0,i.jsx)(e.li,{children:"Define any necessary action handlers"}),"\n",(0,i.jsx)(e.li,{children:"Return a StateGraph object"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Complete example of a basic stategraph:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'require("stategraphs/commonstates")\n\nlocal states = {\n    -- Define an idle state\n    State{\n        name = "idle",\n        tags = { "idle", "canrotate" },\n        onenter = function(inst)\n            inst.AnimState:PlayAnimation("idle_loop", true)\n            inst.components.locomotor:StopMoving()\n        end,\n    },\n    \n    -- Define a walk state\n    State{\n        name = "walk",\n        tags = { "moving", "canrotate" },\n        onenter = function(inst)\n            inst.AnimState:PlayAnimation("walk_loop", true)\n            inst.components.locomotor:WalkForward()\n        end,\n        \n        -- Add footstep sounds at specific animation frames\n        timeline = {\n            TimeEvent(5*FRAMES, function(inst) \n                inst.SoundEmitter:PlaySound("dontstarve/movement/foley/walk_dirt")\n            end),\n            TimeEvent(15*FRAMES, function(inst) \n                inst.SoundEmitter:PlaySound("dontstarve/movement/foley/walk_dirt")\n            end),\n        },\n    },\n    \n    -- Define an attack state\n    State{\n        name = "attack",\n        tags = { "attack", "busy" },\n        onenter = function(inst)\n            inst.components.locomotor:StopMoving()\n            inst.AnimState:PlayAnimation("attack")\n        end,\n        \n        timeline = {\n            TimeEvent(8*FRAMES, function(inst) \n                inst.components.combat:DoAttack() \n            end),\n        },\n        \n        events = {\n            EventHandler("animover", function(inst)\n                inst.sg:GoToState("idle")\n            end),\n        },\n    },\n}\n\nlocal events = {\n    -- Handle movement control\n    EventHandler("locomote", function(inst)\n        local is_moving = inst.sg:HasStateTag("moving")\n        local wants_to_move = inst.components.locomotor:WantsToMoveForward()\n        \n        if is_moving and not wants_to_move then\n            inst.sg:GoToState("idle")\n        elseif not is_moving and wants_to_move then\n            inst.sg:GoToState("walk")\n        end\n    end),\n    \n    -- Handle attack event\n    EventHandler("doattack", function(inst, data)\n        if not inst.components.health:IsDead() then\n            inst.sg:GoToState("attack", data.target)\n        end\n    end),\n    \n    -- Handle damage event\n    EventHandler("attacked", function(inst)\n        if not inst.components.health:IsDead() then\n            inst.sg:GoToState("hit")\n        end\n    end),\n}\n\nlocal actionhandlers = {\n    -- Handle attack action\n    ActionHandler(ACTIONS.ATTACK, function(inst, action)\n        inst:PushEvent("doattack", {target = action.target})\n        return true\n    end),\n}\n\nreturn StateGraph("myentity", states, events, "idle", actionhandlers)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"using-stategraphs",children:"Using Stategraphs"}),"\n",(0,i.jsx)(e.p,{children:"To use a stategraph with an entity:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'function MakeMyEntity()\n    -- Create the entity\n    local inst = CreateEntity()\n    \n    -- Add basic components\n    inst.entity:AddTransform()\n    inst.entity:AddAnimState()\n    inst.entity:AddSoundEmitter()\n    inst.entity:AddNetwork()\n    \n    -- Add required components for behavior\n    inst:AddComponent("locomotor")\n    inst:AddComponent("combat")\n    inst:AddComponent("health")\n    \n    -- Set the stategraph\n    inst:SetStateGraph("SGmyentity")\n    \n    -- Initialize animation\n    inst.AnimState:SetBank("spider")\n    inst.AnimState:SetBuild("spider")\n    inst.AnimState:PlayAnimation("idle_loop", true)\n    \n    return inst\nend\n'})}),"\n",(0,i.jsx)(e.h2,{id:"stategraph-and-animation-best-practices",children:"Stategraph and Animation Best Practices"}),"\n",(0,i.jsx)(e.p,{children:"When creating stategraphs with animations:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Match Timeline Events to Animation Keyframes"}),": For best results, timeline events should correspond to specific animation keyframes"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Use Animation Callbacks"}),": The ",(0,i.jsx)(e.code,{children:"animover"})," and ",(0,i.jsx)(e.code,{children:"animqueueover"})," events are essential for proper state transitions"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Organize Multi-part Animations"}),": For complex actions, use multiple states:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Example of multi-part animation states\nState{ name = "attack_pre", onenter = function(inst) inst.AnimState:PlayAnimation("attack_pre") end },\nState{ name = "attack_loop", onenter = function(inst) inst.AnimState:PlayAnimation("attack_loop") end },\nState{ name = "attack_pst", onenter = function(inst) inst.AnimState:PlayAnimation("attack_pst") end },\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Leverage Animation Blending"}),": For smooth transitions"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'inst.AnimState:PlayAnimation("walk_pre")\ninst.AnimState:PushAnimation("walk_loop", true)\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Synchronize Sound Effects"}),": Use timeline events to perfectly time sound effects with animations"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"common-states-and-handlers",children:"Common States and Handlers"}),"\n",(0,i.jsxs)(e.p,{children:["Don't Starve Together provides reusable states and handlers in ",(0,i.jsx)(e.code,{children:"commonstates.lua"}),", which you can use to implement standard behaviors like:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Walking/running"}),"\n",(0,i.jsx)(e.li,{children:"Attacking"}),"\n",(0,i.jsx)(e.li,{children:"Taking damage"}),"\n",(0,i.jsx)(e.li,{children:"Sleeping"}),"\n",(0,i.jsx)(e.li,{children:"Freezing"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This module helps maintain consistency across different entities while reducing code duplication."}),"\n",(0,i.jsx)(e.h2,{id:"advanced-stategraph-features",children:"Advanced Stategraph Features"}),"\n",(0,i.jsx)(e.h3,{id:"state-memory",children:"State Memory"}),"\n",(0,i.jsxs)(e.p,{children:["States can store temporary data in the ",(0,i.jsx)(e.code,{children:"statemem"})," table:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"onenter = function(inst, target)\n    inst.sg.statemem.target = target  -- Store target for use in timeline\nend,\n\ntimeline = {\n    TimeEvent(10*FRAMES, function(inst)\n        if inst.sg.statemem.target and inst.sg.statemem.target:IsValid() then\n            inst.components.combat:DoAttack(inst.sg.statemem.target)\n        end\n    end),\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"state-tags",children:"State Tags"}),"\n",(0,i.jsx)(e.p,{children:"Tags provide a way to categorize states and query their properties:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Add tags when defining a state\nState{\n    name = "attack",\n    tags = {"attack", "busy", "cannotinterrupt"},\n    -- state definition...\n}\n\n-- Check for tags anywhere in code\nif inst.sg:HasStateTag("busy") then\n    -- Entity is in a busy state\nend\n\n-- Dynamically add/remove tags during a state\nonenter = function(inst)\n    inst.sg:AddStateTag("abouttoattack")\nend,\n\ntimeline = {\n    TimeEvent(10*FRAMES, function(inst)\n        inst.sg:RemoveStateTag("abouttoattack")\n        inst.sg:AddStateTag("attackdone")\n    end),\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"state-timeouts",children:"State Timeouts"}),"\n",(0,i.jsx)(e.p,{children:"States can automatically transition after a timeout:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'State{\n    name = "alert",\n    tags = {"idle", "alert"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("alert_loop", true)\n        inst.sg:SetTimeout(5)  -- 5 second timeout\n    end,\n    \n    ontimeout = function(inst)\n        inst.sg:GoToState("idle")\n    end,\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(e.p,{children:"The stategraph system is a powerful way to define entity behavior in Don't Starve Together. By organizing code into states, events, and transitions, it creates readable, maintainable behavior definitions that seamlessly integrate with the animation system. Whether you're creating simple interactive objects or complex creatures with advanced AI, understanding stategraphs is essential for effective DST modding."})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var a=t(6540);const i={},s=a.createContext(i);function o(n){const e=a.useContext(s);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);