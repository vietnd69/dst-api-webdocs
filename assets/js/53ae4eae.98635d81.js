"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[79306],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var l=i(96540);const s={},t=l.createContext(s);function r(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),l.createElement(t.Provider,{value:n},e.children)}},76024:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"game-scripts/core-systems/world-systems/tiles-terrain/tilegroups","title":"TileGroups","description":"Tile categorization and validation system for checking tile types and managing tile group relationships","source":"@site/docs/game-scripts/core-systems/world-systems/tiles-terrain/tilegroups.md","sourceDirName":"game-scripts/core-systems/world-systems/tiles-terrain","slug":"/game-scripts/core-systems/world-systems/tiles-terrain/tilegroups","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/tilegroups","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"tilegroups","title":"TileGroups","description":"Tile categorization and validation system for checking tile types and managing tile group relationships","sidebar_position":2,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"TileDefs","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/tiledefs"},"next":{"title":"TileManager","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/tilemanager"}}');var s=i(74848),t=i(28453);const r={id:"tilegroups",title:"TileGroups",description:"Tile categorization and validation system for checking tile types and managing tile group relationships",sidebar_position:2,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},a="TileGroups",o={},d=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Functions",id:"functions",level:2},{value:"IsLandTile(tile)",id:"is-land-tile",level:3},{value:"IsOceanTile(tile)",id:"is-ocean-tile",level:3},{value:"IsImpassableTile(tile)",id:"is-impassable-tile",level:3},{value:"IsInvalidTile(tile)",id:"is-invalid-tile",level:3},{value:"IsNoiseTile(tile)",id:"is-noise-tile",level:3},{value:"IsTemporaryTile(tile)",id:"is-temporary-tile",level:3},{value:"IsShallowOceanTile(tile)",id:"is-shallow-ocean-tile",level:3},{value:"Tile Groups",id:"tile-groups",level:2},{value:"Legacy Tile Groups",id:"legacy-tile-groups",level:3},{value:"Current Tile Groups",id:"current-tile-groups",level:3},{value:"Specialized Tile Groups",id:"specialized-tile-groups",level:3},{value:"Common Usage Patterns",id:"common-usage-patterns",level:2},{value:"Entity Movement Validation",id:"entity-movement-validation",level:3},{value:"Structure Placement Logic",id:"structure-placement-logic",level:3},{value:"AI Pathfinding Integration",id:"ai-pathfinding-integration",level:3},{value:"Resource Gathering Validation",id:"resource-gathering-validation",level:3},{value:"Integration with Game Systems",id:"integration-with-game-systems",level:2},{value:"World Generation",id:"world-generation",level:3},{value:"Falloff Texture System",id:"falloff-texture-system",level:3},{value:"Component Integration",id:"component-integration",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Related Modules",id:"related-modules",level:2},{value:"Source Reference",id:"source-reference",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tilegroups",children:"TileGroups"})}),"\n",(0,s.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Build Version"}),(0,s.jsx)(n.th,{children:"Change Date"}),(0,s.jsx)(n.th,{children:"Change Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"676042"}),(0,s.jsx)(n.td,{children:"2025-06-21"}),(0,s.jsx)(n.td,{children:"stable"}),(0,s.jsx)(n.td,{children:"Current version"})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TileGroups"})," module extends the ",(0,s.jsx)(n.code,{children:"TileGroupManager"})," to provide tile categorization and validation functions. It defines tile groups for different categories (land, ocean, impassable, etc.) and provides utility functions to check tile properties and relationships. This system is essential for AI pathfinding, placement validation, and game logic."]}),"\n",(0,s.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Check if a tile is suitable for land-based entities\nif TileGroupManager:IsLandTile(tile_id) then\n    print("Entity can walk here")\nend\n\n-- Validate ocean navigation\nif TileGroupManager:IsOceanTile(tile_id) and \n   TileGroupManager:IsShallowOceanTile(tile_id) then\n    print("Boat can navigate in shallow water")\nend\n\n-- Check for impassable areas\nif TileGroupManager:IsImpassableTile(tile_id) then\n    print("Cannot place structures here")\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h3,{id:"is-land-tile",children:"IsLandTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is a land tile that entities can walk on. Checks both legacy and current land tile ranges."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is a land tile, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Check if player can walk on this tile\nlocal tile_under_player = TheWorld.Map:GetTileAtPoint(player.Transform:GetWorldPosition())\n\nif TileGroupManager:IsLandTile(tile_under_player) then\n    print("Player is on solid ground")\n    -- Allow land-based actions\n    player.components.locomotor:SetCanWalkOnLand(true)\nelse\n    print("Player is not on land")\n    -- Handle water/ocean movement\nend\n\n-- Validate placement for land structures\nlocal function CanPlaceOnTile(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    return TileGroupManager:IsLandTile(tile)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"is-ocean-tile",children:"IsOceanTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is an ocean tile. Checks both legacy and current ocean tile ranges for water-based gameplay."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is an ocean tile, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Check if boat can navigate this area\nlocal tile_id = TheWorld.Map:GetTileAtPoint(boat_x, boat_y)\n\nif TileGroupManager:IsOceanTile(tile_id) then\n    print("Boat can sail here")\n    boat.components.locomotor:SetCanWalkOnWater(true)\nelse\n    print("Boat cannot sail on land")\n    -- Stop boat movement or handle beaching\nend\n\n-- Ocean fishing validation\nlocal function CanFishHere(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    return TileGroupManager:IsOceanTile(tile)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"is-impassable-tile",children:"IsImpassableTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is impassable and cannot be traversed by entities. Includes both legacy impassable tiles and specific impassable tile types."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is impassable, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Pathfinding validation\nlocal function IsValidPathTile(tile)\n    if TileGroupManager:IsImpassableTile(tile) then\n        return false  -- Cannot path through this tile\n    end\n    return true\nend\n\n-- Structure placement validation\nlocal function CanBuildHere(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    if TileGroupManager:IsImpassableTile(tile) then\n        return false, "Cannot build on impassable terrain"\n    end\n    return true\nend\n\n-- AI navigation check\nif not TileGroupManager:IsImpassableTile(target_tile) then\n    -- Safe to move to this location\n    entity.components.locomotor:GoToPoint(target_x, target_y)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"is-invalid-tile",children:"IsInvalidTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is invalid, including both impassable tiles and specifically invalid tile types."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is invalid, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- World boundary checking\nlocal function IsWithinValidWorld(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    if TileGroupManager:IsInvalidTile(tile) then\n        return false  -- Outside world boundaries\n    end\n    return true\nend\n\n-- Entity spawning validation\nlocal function SafeToSpawnAt(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    if TileGroupManager:IsInvalidTile(tile) then\n        return false, "Cannot spawn on invalid terrain"\n    end\n    return true\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"is-noise-tile",children:"IsNoiseTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is a noise tile used for texture blending and world generation. Checks both legacy and current noise tile ranges."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is a noise tile, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- World generation validation\nlocal function IsTextureBlendTile(tile)\n    return TileGroupManager:IsNoiseTile(tile)\nend\n\n-- Skip noise tiles in gameplay logic\nif not TileGroupManager:IsNoiseTile(tile_id) then\n    -- Process only actual gameplay tiles\n    ProcessGameplayTile(tile_id)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"is-temporary-tile",children:"IsTemporaryTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is temporary and uses the undertile component. Temporary tiles help avoid placement conflicts when multiple temporary tiles try to occupy the same spot."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is temporary, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Prevent overlapping temporary structures\nlocal function CanPlaceTemporaryStructure(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    if TileGroupManager:IsTemporaryTile(tile) then\n        return false, "Another temporary structure already here"\n    end\n    return true\nend\n\n-- Special handling for temporary tiles\nif TileGroupManager:IsTemporaryTile(current_tile) then\n    -- Use undertile component logic\n    local undertile = entity.components.undertile\n    if undertile then\n        undertile:SetOriginalTile(underlying_tile)\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"is-shallow-ocean-tile",children:"IsShallowOceanTile(tile)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Status:"})," ",(0,s.jsx)(n.code,{children:"stable"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"}),"\nDetermines if a tile is specifically a shallow ocean tile suitable for certain ocean activities. Only includes coastal shore, coastal ocean, and waterlog ocean tiles."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tile"})," (number): Tile ID to check"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"(boolean): True if the tile is a shallow ocean tile, false otherwise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Boat navigation in shallow water\nif TileGroupManager:IsShallowOceanTile(tile_id) then\n    print("Safe for small boats")\n    boat.components.locomotor:SetSpeedMultiplier(1.0)\nelse\n    print("Deep water - large boats only")\n    if boat.size == "small" then\n        boat.components.locomotor:SetSpeedMultiplier(0.5)\n    end\nend\n\n-- Shallow water fishing\nlocal function CanShorelinefish(x, y)\n    local tile = TheWorld.Map:GetTile(x, y)\n    return TileGroupManager:IsShallowOceanTile(tile)\nend\n\n-- Wade in shallow water\nif TileGroupManager:IsShallowOceanTile(player_tile) then\n    player.components.locomotor:SetTriggersCreatedSounds(false)  -- Quiet movement\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"tile-groups",children:"Tile Groups"}),"\n",(0,s.jsx)(n.p,{children:"The module defines several tile groups used throughout the game:"}),"\n",(0,s.jsx)(n.h3,{id:"legacy-tile-groups",children:"Legacy Tile Groups"}),"\n",(0,s.jsx)(n.p,{children:"These groups maintain compatibility with older tile systems:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.Legacy_LandTiles"})," - Legacy land tile range"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.Legacy_OceanTiles"})," - Legacy ocean tile range"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.Legacy_ImpassableTiles"})," - Legacy impassable tile range"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.Legacy_NoiseTiles"})," - Legacy noise tile range"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"current-tile-groups",children:"Current Tile Groups"}),"\n",(0,s.jsx)(n.p,{children:"Modern tile groups that extend legacy groups:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.LandTiles"})," - All land tiles including legacy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.OceanTiles"})," - All ocean tiles including legacy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.TransparentOceanTiles"})," - Ocean tiles with transparency effects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.ImpassableTiles"})," - All impassable tiles including legacy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.InvalidTiles"})," - Invalid tiles including impassable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.NoiseTiles"})," - All noise tiles including legacy"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"specialized-tile-groups",children:"Specialized Tile Groups"}),"\n",(0,s.jsx)(n.p,{children:"Groups for specific gameplay mechanics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.LandTilesNotDock"})," - ",(0,s.jsx)(n.strong,{children:"Deprecated:"})," Use ",(0,s.jsx)(n.code,{children:"LandTilesWithDefaultFalloff"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.LandTilesWithDefaultFalloff"})," - Land tiles excluding dock tiles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.DockTiles"})," - Only dock tiles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.OceanIceTiles"})," - Ice floe tiles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.LandTilesInvisible"})," - Land tiles including invisible ones"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TileGroups.ShallowOceanTiles"})," - Shallow ocean areas only"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-usage-patterns",children:"Common Usage Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"entity-movement-validation",children:"Entity Movement Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Comprehensive movement check\nlocal function CanMoveToTile(entity, tile_id)\n    if TileGroupManager:IsInvalidTile(tile_id) then\n        return false, "Invalid terrain"\n    end\n    \n    if entity.is_land_entity and not TileGroupManager:IsLandTile(tile_id) then\n        return false, "Land entity cannot enter water"\n    end\n    \n    if entity.is_boat and not TileGroupManager:IsOceanTile(tile_id) then\n        return false, "Boat cannot sail on land"\n    end\n    \n    if entity.is_small_boat and TileGroupManager:IsOceanTile(tile_id) and \n       not TileGroupManager:IsShallowOceanTile(tile_id) then\n        return false, "Small boat cannot handle deep water"\n    end\n    \n    return true\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"structure-placement-logic",children:"Structure Placement Logic"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Building placement validation\nlocal function ValidateBuildingSite(x, y, building_type)\n    local tile = TheWorld.Map:GetTile(x, y)\n    \n    -- Check for invalid terrain\n    if TileGroupManager:IsInvalidTile(tile) then\n        return false, "Cannot build on invalid terrain"\n    end\n    \n    -- Land buildings\n    if building_type.requires_land then\n        if not TileGroupManager:IsLandTile(tile) then\n            return false, "This structure requires solid ground"\n        end\n    end\n    \n    -- Ocean structures\n    if building_type.requires_ocean then\n        if not TileGroupManager:IsOceanTile(tile) then\n            return false, "This structure requires water"\n        end\n        \n        if building_type.shallow_water_only and \n           not TileGroupManager:IsShallowOceanTile(tile) then\n            return false, "This structure requires shallow water"\n        end\n    end\n    \n    -- Temporary structure collision\n    if building_type.is_temporary and TileGroupManager:IsTemporaryTile(tile) then\n        return false, "Another temporary structure already here"\n    end\n    \n    return true\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ai-pathfinding-integration",children:"AI Pathfinding Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Pathfinding cost calculation\nlocal function GetTileCost(tile_id, entity_type)\n    if TileGroupManager:IsInvalidTile(tile_id) then\n        return math.huge  -- Infinite cost - impassable\n    end\n    \n    local base_cost = 1\n    \n    -- Land entity on water\n    if entity_type == "land" and TileGroupManager:IsOceanTile(tile_id) then\n        if TileGroupManager:IsShallowOceanTile(tile_id) then\n            return base_cost * 3  -- Can wade but slow\n        else\n            return math.huge  -- Cannot swim in deep water\n        end\n    end\n    \n    -- Boat on land\n    if entity_type == "boat" and TileGroupManager:IsLandTile(tile_id) then\n        return math.huge  -- Boats cannot go on land\n    end\n    \n    -- Temporary tiles have higher cost\n    if TileGroupManager:IsTemporaryTile(tile_id) then\n        return base_cost * 2\n    end\n    \n    return base_cost\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"resource-gathering-validation",children:"Resource Gathering Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Check if resources can be gathered from tile\nlocal function CanGatherFrom(tile_id, resource_type)\n    if TileGroupManager:IsInvalidTile(tile_id) then\n        return false\n    end\n    \n    if resource_type == "fish" then\n        return TileGroupManager:IsOceanTile(tile_id)\n    end\n    \n    if resource_type == "shoreline_fish" then\n        return TileGroupManager:IsShallowOceanTile(tile_id)\n    end\n    \n    if resource_type == "land_plants" then\n        return TileGroupManager:IsLandTile(tile_id) and \n               not TileGroupManager:IsTemporaryTile(tile_id)\n    end\n    \n    return false\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-game-systems",children:"Integration with Game Systems"}),"\n",(0,s.jsx)(n.h3,{id:"world-generation",children:"World Generation"}),"\n",(0,s.jsx)(n.p,{children:"The tile groups are used during world generation to determine valid placement areas:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- World generation example\nif TileGroupManager:IsLandTile(tile) then\n    -- Can place land biomes, structures, resources\n    PlaceLandContent(x, y)\nelseif TileGroupManager:IsOceanTile(tile) then\n    -- Can place ocean content, sea stacks, etc.\n    PlaceOceanContent(x, y)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"falloff-texture-system",children:"Falloff Texture System"}),"\n",(0,s.jsx)(n.p,{children:"Tile groups determine which falloff textures to use for smooth tile transitions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- The system uses predefined groups for falloff calculations\nTileGroupManager:SetIsLandTileGroup(TileGroups.LandTiles)\nTileGroupManager:SetIsOceanTileGroup(TileGroups.OceanTiles)\nTileGroupManager:SetIsTransparentOceanTileGroup(TileGroups.TransparentOceanTiles)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"component-integration",children:"Component Integration"}),"\n",(0,s.jsx)(n.p,{children:"Many components use tile groups for validation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Locomotor Component"}),": Checks tile types for movement validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Undertile Component"}),": Uses temporary tile detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Builder Component"}),": Validates placement based on tile types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Boat Component"}),": Uses ocean tile detection for navigation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:"The tile group functions are optimized for frequent calls:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Range checks use simple numeric comparisons"}),"\n",(0,s.jsx)(n.li,{children:"No table iterations for basic tile type checks"}),"\n",(0,s.jsx)(n.li,{children:"Legacy compatibility maintained without performance cost"}),"\n",(0,s.jsx)(n.li,{children:"Global constants used for quick validation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/tilemanager",children:"TileManager"}),": Core tile management and registration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/tiledefs",children:"TileDefs"}),": Contains all vanilla tile definitions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../map/worldtiledefs.md",children:"World Tile Definitions"}),": Tile constants and ranges"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"source-reference",children:"Source Reference"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"scripts/tilegroups.lua"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Implementation Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extends TileGroupManager with utility functions"}),"\n",(0,s.jsx)(n.li,{children:"Maintains legacy compatibility through dual range checking"}),"\n",(0,s.jsx)(n.li,{children:"Integrates with falloff texture system for smooth tile transitions"}),"\n",(0,s.jsx)(n.li,{children:"Provides specialized tile groups for specific game mechanics"}),"\n",(0,s.jsx)(n.li,{children:"Worldgen protection prevents execution during world generation"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);