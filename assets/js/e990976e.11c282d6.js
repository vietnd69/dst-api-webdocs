"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[36401],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},80006:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"game-scripts/core-systems/fundamentals/ai-systems/brain","title":"Brain System","description":"Documentation of the Don\'t Starve Together brain system for AI entity control and behavior management","source":"@site/docs/game-scripts/core-systems/fundamentals/ai-systems/brain.md","sourceDirName":"game-scripts/core-systems/fundamentals/ai-systems","slug":"/game-scripts/core-systems/fundamentals/ai-systems/brain","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/ai-systems/brain","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Brain System","description":"Documentation of the Don\'t Starve Together brain system for AI entity control and behavior management","sidebar_position":1,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Behaviour Tree System","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/ai-systems/behaviourtree"},"next":{"title":"Stategraph","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/ai-systems/stategraph"}}');var a=i(74848),s=i(28453);const r={title:"Brain System",description:"Documentation of the Don't Starve Together brain system for AI entity control and behavior management",sidebar_position:1,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},l="Brain System",d={},o=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"BrainWrangler Class",id:"brainwrangler-class",level:3},{value:"Global Brain Manager",id:"global-brain-manager",level:4},{value:"Brain Class",id:"brain-class",level:3},{value:"Brain Management",id:"brain-management",level:2},{value:"State Management",id:"state-management",level:3},{value:"Lifecycle Methods",id:"lifecycle-methods",level:3},{value:"Adding Brain Instances",id:"adding-brain-instances",level:4},{value:"Removing Brain Instances",id:"removing-brain-instances",level:4},{value:"Sleep and Wake System",id:"sleep-and-wake-system",level:3},{value:"Wake Brain",id:"wake-brain",level:4},{value:"Hibernate Brain",id:"hibernate-brain",level:4},{value:"Timed Sleep",id:"timed-sleep",level:4},{value:"Brain Update Cycle",id:"brain-update-cycle",level:2},{value:"Main Update Loop",id:"main-update-loop",level:3},{value:"Individual Brain Update",id:"individual-brain-update",level:3},{value:"Brain Class Methods",id:"brain-class-methods",level:2},{value:"Core Lifecycle",id:"core-lifecycle",level:3},{value:"Start Brain",id:"start-brain",level:4},{value:"Stop Brain",id:"stop-brain",level:4},{value:"Pause and Resume",id:"pause-and-resume",level:3},{value:"Pause Brain",id:"pause-brain",level:4},{value:"Resume Brain",id:"resume-brain",level:4},{value:"Performance Control",id:"performance-control",level:3},{value:"Force Update",id:"force-update",level:4},{value:"Get Sleep Time",id:"get-sleep-time",level:4},{value:"Event System",id:"event-system",level:3},{value:"Add Event Handler",id:"add-event-handler",level:4},{value:"Push Event",id:"push-event",level:4},{value:"Implementation Examples",id:"implementation-examples",level:2},{value:"Basic Brain Setup",id:"basic-brain-setup",level:3},{value:"Custom Brain Creation",id:"custom-brain-creation",level:3},{value:"Event-Driven Brain",id:"event-driven-brain",level:3},{value:"Performance-Optimized Brain",id:"performance-optimized-brain",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Sleep Strategies",id:"sleep-strategies",level:3},{value:"Conditional Sleep",id:"conditional-sleep",level:4},{value:"Adaptive Sleep",id:"adaptive-sleep",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Proper Cleanup",id:"proper-cleanup",level:4},{value:"Integration with Game Systems",id:"integration-with-game-systems",level:2},{value:"Component Integration",id:"component-integration",level:3},{value:"Entity Event Integration",id:"entity-event-integration",level:3},{value:"Mod Integration",id:"mod-integration",level:3},{value:"Debugging Support",id:"debugging-support",level:2},{value:"Debug Information",id:"debug-information",level:3},{value:"Debug Commands",id:"debug-commands",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Safe Brain Operations",id:"safe-brain-operations",level:3},{value:"Entity Validation",id:"entity-validation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Design Guidelines",id:"design-guidelines",level:3},{value:"Performance Best Practices",id:"performance-best-practices",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Related Systems",id:"related-systems",level:2},{value:"Status: \ud83d\udfe2 Stable",id:"status--stable",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"brain-system",children:"Brain System"})}),"\n",(0,a.jsx)(n.p,{children:"The Brain system in Don't Starve Together provides centralized AI management for entities, coordinating behavior execution, sleep/wake cycles, and performance optimization. This system serves as the bridge between entity components and behavior trees, enabling sophisticated AI patterns while maintaining optimal game performance."}),"\n",(0,a.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Build Version"}),(0,a.jsx)(n.th,{children:"Change Date"}),(0,a.jsx)(n.th,{children:"Change Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"675312"}),(0,a.jsx)(n.td,{children:"2025-06-21"}),(0,a.jsx)(n.td,{children:"stable"}),(0,a.jsx)(n.td,{children:"Updated documentation to match current implementation"})]})})]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The brain system serves multiple purposes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"AI Coordination"}),": Manages behavior tree execution for all AI entities"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Management"}),": Implements sleep/wake cycles to optimize CPU usage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Event Integration"}),": Provides event-driven behavior triggers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lifecycle Management"}),": Handles AI startup, shutdown, and cleanup"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The system is built around two core classes: ",(0,a.jsx)(n.code,{children:"BrainWrangler"})," for global management and ",(0,a.jsx)(n.code,{children:"Brain"})," for individual entity AI control."]}),"\n",(0,a.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"brainwrangler-class",children:"BrainWrangler Class"}),"\n",(0,a.jsx)(n.p,{children:"The global brain manager that coordinates all AI entities:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"BrainWrangler = Class(function(self)\n    self.instances = {}        -- All brain instances\n    self.updaters = {}         -- Brains currently updating\n    self._safe_updaters = {}   -- Safe iteration copy\n    self.tickwaiters = {}      -- Brains sleeping until specific tick\n    self.hibernaters = {}      -- Hibernating brains\nend)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"global-brain-manager",children:"Global Brain Manager"}),"\n",(0,a.jsx)(n.p,{children:"The system provides a singleton instance for global coordination:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"BrainManager = BrainWrangler()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"brain-class",children:"Brain Class"}),"\n",(0,a.jsx)(n.p,{children:"Individual brain instances that control entity AI:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"Brain = Class(function(self)\n    self.inst = nil                -- Entity this brain controls\n    self.currentbehaviour = nil    -- Current behavior state\n    self.behaviourqueue = {}       -- Queued behaviors\n    self.events = {}              -- Event handlers\n    self.thinkperiod = nil        -- Update frequency\n    self.lastthinktime = nil      -- Last update time\n    self.paused = false           -- Pause state\nend)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"brain-management",children:"Brain Management"}),"\n",(0,a.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,a.jsx)(n.p,{children:"The brain system categorizes brains into different states for optimization:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"State"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Performance Impact"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Updaters"})}),(0,a.jsx)(n.td,{children:"Actively updating brains"}),(0,a.jsx)(n.td,{children:"High CPU usage"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Hibernaters"})}),(0,a.jsx)(n.td,{children:"Sleeping indefinitely"}),(0,a.jsx)(n.td,{children:"Minimal CPU usage"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Tick Waiters"})}),(0,a.jsx)(n.td,{children:"Sleeping until specific time"}),(0,a.jsx)(n.td,{children:"No CPU usage"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"lifecycle-methods",children:"Lifecycle Methods"}),"\n",(0,a.jsx)(n.h4,{id:"adding-brain-instances",children:"Adding Brain Instances"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:AddInstance(inst)\n    self.instances[inst] = self.updaters\n    self.updaters[inst] = true\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Registers a new brain for active updating."]}),"\n",(0,a.jsx)(n.h4,{id:"removing-brain-instances",children:"Removing Brain Instances"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:RemoveInstance(inst)\n    self:SendToList(inst, nil)\n    -- Clean up from all lists\n    self.updaters[inst] = nil\n    self.hibernaters[inst] = nil\n    for k,v in pairs(self.tickwaiters) do\n        v[inst] = nil\n    end\n    self.instances[inst] = nil\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Completely removes a brain from the system."]}),"\n",(0,a.jsx)(n.h3,{id:"sleep-and-wake-system",children:"Sleep and Wake System"}),"\n",(0,a.jsx)(n.h4,{id:"wake-brain",children:"Wake Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:Wake(inst)\n    if self.instances[inst] then\n        self:SendToList(inst, self.updaters)\n    end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Moves brain from hibernation to active updating."]}),"\n",(0,a.jsx)(n.h4,{id:"hibernate-brain",children:"Hibernate Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:Hibernate(inst)\n    if self.instances[inst] then\n        self:SendToList(inst, self.hibernaters)\n    end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Moves brain to hibernation (stops updating)."]}),"\n",(0,a.jsx)(n.h4,{id:"timed-sleep",children:"Timed Sleep"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:Sleep(inst, time_to_wait)\n    local sleep_ticks = time_to_wait/GetTickTime()\n    if sleep_ticks == 0 then sleep_ticks = 1 end\n    \n    local target_tick = math.floor(GetTick() + sleep_ticks)\n    \n    if target_tick > GetTick() then\n        local waiters = self.tickwaiters[target_tick]\n        if not waiters then\n            waiters = {}\n            self.tickwaiters[target_tick] = waiters\n        end\n        self:SendToList(inst, waiters)\n    end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Sleeps brain for specific duration for performance optimization."]}),"\n",(0,a.jsx)(n.h2,{id:"brain-update-cycle",children:"Brain Update Cycle"}),"\n",(0,a.jsx)(n.h3,{id:"main-update-loop",children:"Main Update Loop"}),"\n",(0,a.jsx)(n.p,{children:"The brain manager processes all brains in each game tick:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BrainWrangler:Update(current_tick)\n    -- Wake up brains that finished sleeping\n    local waiters = self.tickwaiters[current_tick]\n    if waiters then\n        for k,v in pairs(waiters) do\n            self.updaters[k] = true\n            self.instances[k] = self.updaters\n        end\n        self.tickwaiters[current_tick] = nil\n    end\n    \n    -- Update active brains safely\n    local count = 0\n    for k, _ in pairs(self.updaters) do\n        if k.inst.entity:IsValid() and not k.inst:IsAsleep() then\n            count = count + 1\n            self._safe_updaters[count] = k\n        end\n    end\n    \n    for i = 1, count do\n        local k = self._safe_updaters[i]\n        self._safe_updaters[i] = nil\n        \n        k:OnUpdate()\n        local sleep_amount = k:GetSleepTime()\n        if sleep_amount then\n            if sleep_amount > GetTickTime() then\n                self:Sleep(k, sleep_amount)\n            end\n        else\n            self:Hibernate(k)\n        end\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"individual-brain-update",children:"Individual Brain Update"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:OnUpdate()\n    if self.DoUpdate then\n        self:DoUpdate()\n    end\n    \n    if self.bt then\n        self.bt:Update()\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"brain-class-methods",children:"Brain Class Methods"}),"\n",(0,a.jsx)(n.h3,{id:"core-lifecycle",children:"Core Lifecycle"}),"\n",(0,a.jsx)(n.h4,{id:"start-brain",children:"Start Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:Start()\n    if self.paused then\n        return\n    end\n    \n    if self.OnStart then\n        self:OnStart()\n    end\n    self.stopped = false\n    BrainManager:AddInstance(self)\n    \n    if self.OnInitializationComplete then\n        self:OnInitializationComplete()\n    end\n    \n    -- Apply mods\n    if self.modpostinitfns then\n        for i,modfn in ipairs(self.modpostinitfns) do\n            modfn(self)\n        end\n    end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Initializes and starts brain execution."]}),"\n",(0,a.jsx)(n.h4,{id:"stop-brain",children:"Stop Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:Stop()\n    if self.paused then\n        return\n    end\n    \n    if self.OnStop then\n        self:OnStop()\n    end\n    if self.bt then\n        self.bt:Stop()\n    end\n    self.stopped = true\n    BrainManager:RemoveInstance(self)\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Stops brain execution and cleans up resources."]}),"\n",(0,a.jsx)(n.h3,{id:"pause-and-resume",children:"Pause and Resume"}),"\n",(0,a.jsx)(n.h4,{id:"pause-brain",children:"Pause Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:Pause()\n    self.paused = true\n    BrainManager:RemoveInstance(self)\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"resume-brain",children:"Resume Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:Resume()\n    self.paused = false\n    BrainManager:AddInstance(self)\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"performance-control",children:"Performance Control"}),"\n",(0,a.jsx)(n.h4,{id:"force-update",children:"Force Update"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:ForceUpdate()\n    if self.bt then\n        self.bt:ForceUpdate()\n    end\n    BrainManager:Wake(self)\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Forces immediate brain update, bypassing sleep optimization."]}),"\n",(0,a.jsx)(n.h4,{id:"get-sleep-time",children:"Get Sleep Time"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:GetSleepTime()\n    if self.bt then\n        return self.bt:GetSleepTime()\n    end\n    return 0\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),": Returns optimal sleep duration for performance optimization."]}),"\n",(0,a.jsx)(n.h3,{id:"event-system",children:"Event System"}),"\n",(0,a.jsx)(n.h4,{id:"add-event-handler",children:"Add Event Handler"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:AddEventHandler(event, fn)\n    self.events[event] = fn\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"push-event",children:"Push Event"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function Brain:PushEvent(event, data)\n    local handler = self.events[event]\n    if handler then\n        handler(data)\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,a.jsx)(n.h3,{id:"basic-brain-setup",children:"Basic Brain Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create a simple brain for an entity\nlocal brain = require("brains/pigbrain")\n\n-- Set up entity with brain\ninst:AddComponent("brain")\ninst.components.brain:SetBrain(brain)\n\n-- The brain will automatically start when the entity spawns\n'})}),"\n",(0,a.jsx)(n.h3,{id:"custom-brain-creation",children:"Custom Brain Creation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Define a custom brain\nlocal MyBrain = Class(Brain, function(self, inst)\n    Brain._ctor(self, inst)\n    \n    -- Set up behavior tree\n    self.bt = BT(inst,\n        PriorityNode({\n            -- High priority behaviors\n            IfNode(function() return inst.components.health:GetPercent() < 0.3 end,\n                   "Low Health",\n                   ActionNode(function() inst:Flee() end, "Escape")),\n            \n            -- Default behavior\n            ActionNode(function() inst:Wander() end, "Wander")\n        })\n    )\nend)\n\n-- Override lifecycle methods\nfunction MyBrain:OnStart()\n    -- Custom initialization\n    print("Brain starting for", self.inst)\nend\n\nfunction MyBrain:OnStop()\n    -- Custom cleanup\n    print("Brain stopping for", self.inst)\nend\n\n-- Custom update logic\nfunction MyBrain:DoUpdate()\n    -- Additional per-frame logic\n    if self.inst:IsNearPlayer() then\n        self.inst:PlayAnimation("alert")\n    end\nend\n\nreturn MyBrain\n'})}),"\n",(0,a.jsx)(n.h3,{id:"event-driven-brain",children:"Event-Driven Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local EventBrain = Class(Brain, function(self, inst)\n    Brain._ctor(self, inst)\n    \n    -- Set up event handlers\n    self:AddEventHandler("attacked", function(data)\n        if data.attacker and data.attacker:HasTag("player") then\n            self:PushEvent("player_attack", data)\n        end\n    end)\n    \n    self:AddEventHandler("player_attack", function(data)\n        -- React to player attack\n        inst.components.combat:SetTarget(data.attacker)\n    end)\n    \n    -- Behavior tree with event integration\n    self.bt = BT(inst,\n        PriorityNode({\n            -- Event-driven behavior\n            EventNode(inst, "player_attack",\n                SequenceNode({\n                    ActionNode(function() inst:FaceTarget() end, "Face Attacker"),\n                    ActionNode(function() inst:Attack() end, "Fight Back")\n                }),\n                10), -- High priority\n            \n            -- Default behavior\n            ActionNode(function() inst:DoIdle() end, "Idle")\n        })\n    )\nend)\n\nreturn EventBrain\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-optimized-brain",children:"Performance-Optimized Brain"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local OptimizedBrain = Class(Brain, function(self, inst)\n    Brain._ctor(self, inst)\n    \n    -- Set up behavior tree with sleep optimization\n    self.bt = BT(inst,\n        PriorityNode({\n            -- Expensive checks with sleep\n            IfNode(function() \n                local result = ExpensivePathfinding()\n                if not result then\n                    -- Sleep for 2 seconds if no path found\n                    inst.components.brain:Sleep(2.0)\n                end\n                return result\n            end, "Pathfind", \n            ActionNode(function() inst:FollowPath() end, "Move")),\n            \n            -- Low frequency behavior\n            SequenceNode({\n                WaitNode(5.0), -- Wait 5 seconds between checks\n                ConditionNode(function() return inst:NeedsFood() end, "Hungry"),\n                ActionNode(function() inst:FindFood() end, "Search Food")\n            })\n        }, 3.0) -- Re-evaluate priorities every 3 seconds\n    )\nend)\n\n-- Override to provide custom sleep logic\nfunction OptimizedBrain:GetSleepTime()\n    local base_sleep = Brain.GetSleepTime(self)\n    \n    -- Sleep longer when far from players\n    local player = FindClosestPlayer(inst, 20)\n    if not player then\n        return math.max(base_sleep, 1.0) -- Sleep at least 1 second\n    end\n    \n    return base_sleep\nend\n\nreturn OptimizedBrain\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"sleep-strategies",children:"Sleep Strategies"}),"\n",(0,a.jsx)(n.h4,{id:"conditional-sleep",children:"Conditional Sleep"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Sleep based on entity state\nfunction CustomBrain:GetSleepTime()\n    if self.inst:IsAsleep() then\n        return 5.0 -- Long sleep when entity is asleep\n    elseif not self.inst:HasNearbyPlayers(15) then\n        return 2.0 -- Medium sleep when no players nearby\n    else\n        return 0.1 -- Frequent updates when players are close\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"adaptive-sleep",children:"Adaptive Sleep"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Adjust sleep time based on activity level\nfunction AdaptiveBrain:DoUpdate()\n    self.activity_counter = (self.activity_counter or 0) + 1\n    \n    -- Reset counter periodically\n    if self.activity_counter > 100 then\n        self.last_activity = self.activity_counter\n        self.activity_counter = 0\n    end\nend\n\nfunction AdaptiveBrain:GetSleepTime()\n    local base_sleep = Brain.GetSleepTime(self)\n    \n    -- Sleep longer if brain has been inactive\n    if self.last_activity and self.last_activity < 10 then\n        return math.max(base_sleep, 3.0)\n    end\n    \n    return base_sleep\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.h4,{id:"proper-cleanup",children:"Proper Cleanup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function CustomBrain:OnStop()\n    -- Clean up references\n    if self.cached_targets then\n        self.cached_targets = nil\n    end\n    \n    if self.pathfinder then\n        self.pathfinder:Cancel()\n        self.pathfinder = nil\n    end\n    \n    -- Call parent cleanup\n    Brain.OnStop(self)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-game-systems",children:"Integration with Game Systems"}),"\n",(0,a.jsx)(n.h3,{id:"component-integration",children:"Component Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Brain that works with multiple components\nfunction ComponentBrain:OnStart()\n    -- Validate required components\n    if not self.inst.components.health then\n        print("Warning: Brain requires health component")\n    end\n    \n    if not self.inst.components.locomotor then\n        print("Warning: Brain requires locomotor component")\n    end\nend\n\nfunction ComponentBrain:DoUpdate()\n    -- Use components safely\n    local health = self.inst.components.health\n    if health and health:GetPercent() < 0.5 then\n        self.low_health = true\n    else\n        self.low_health = false\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"entity-event-integration",children:"Entity Event Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Automatically listen to entity events\nfunction EventIntegratedBrain:OnStart()\n    -- Listen to entity lifecycle events\n    self.inst:ListenForEvent("death", function() self:Stop() end)\n    self.inst:ListenForEvent("attacked", function(data) \n        self:PushEvent("combat", data) \n    end)\n    self.inst:ListenForEvent("itemget", function(data)\n        self:PushEvent("inventory_change", data)\n    end)\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"mod-integration",children:"Mod Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Brain with mod support\nfunction ModdableBrain:OnStart()\n    Brain.OnStart(self)\n    \n    -- Allow mods to add custom initialization\n    if self.mod_start_hooks then\n        for _, hook in ipairs(self.mod_start_hooks) do\n            hook(self)\n        end\n    end\nend\n\n-- Function for mods to register hooks\nfunction ModdableBrain:AddModStartHook(fn)\n    self.mod_start_hooks = self.mod_start_hooks or {}\n    table.insert(self.mod_start_hooks, fn)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-support",children:"Debugging Support"}),"\n",(0,a.jsx)(n.h3,{id:"debug-information",children:"Debug Information"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function Brain:__tostring()\n    if self.bt then\n        return string.format("--brain--\\nsleep time: %2.2f\\n%s", \n                           self:GetSleepTime(), tostring(self.bt))\n    end\n    return "--brain--"\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"debug-commands",children:"Debug Commands"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Console commands for debugging brains\nfunction DebugPrintBrainStats()\n    print("=== Brain Statistics ===")\n    print("Total instances:", GetTableSize(BrainManager.instances))\n    print("Active updaters:", GetTableSize(BrainManager.updaters))\n    print("Hibernating:", GetTableSize(BrainManager.hibernaters))\n    \n    local waiters = 0\n    for tick, list in pairs(BrainManager.tickwaiters) do\n        waiters = waiters + GetTableSize(list)\n    end\n    print("Sleeping (tick waiters):", waiters)\nend\n\nfunction DebugBrainEntity(entity)\n    if entity and entity.components.brain then\n        print("Brain info for", entity)\n        print(tostring(entity.components.brain.brain))\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.h3,{id:"safe-brain-operations",children:"Safe Brain Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SafeBrain:OnUpdate()\n    local success, error_msg = pcall(function()\n        if self.DoUpdate then\n            self:DoUpdate()\n        end\n        \n        if self.bt then\n            self.bt:Update()\n        end\n    end)\n    \n    if not success then\n        print("Brain error:", error_msg)\n        -- Attempt recovery or stop brain\n        self:Stop()\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"entity-validation",children:"Entity Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function ValidatingBrain:OnUpdate()\n    -- Always validate entity before operations\n    if not self.inst or not self.inst:IsValid() then\n        self:Stop()\n        return\n    end\n    \n    Brain.OnUpdate(self)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"design-guidelines",children:"Design Guidelines"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Single Responsibility"}),": Each brain should control one entity's AI"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Awareness"}),": Implement appropriate sleep strategies"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Event-Driven Design"}),": Use events for reactive behaviors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Component Integration"}),": Work safely with entity components"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Proper Cleanup"}),": Always clean up resources in OnStop"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use sleep timers for expensive operations"}),"\n",(0,a.jsx)(n.li,{children:"Implement hibernation for distant/inactive entities"}),"\n",(0,a.jsx)(n.li,{children:"Cache expensive calculations between updates"}),"\n",(0,a.jsx)(n.li,{children:"Avoid deep behavior tree nesting"}),"\n",(0,a.jsx)(n.li,{children:"Profile brain performance regularly"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Document complex AI logic thoroughly"}),"\n",(0,a.jsx)(n.li,{children:"Use meaningful names for brain states and behaviors"}),"\n",(0,a.jsx)(n.li,{children:"Implement proper error handling and recovery"}),"\n",(0,a.jsx)(n.li,{children:"Provide debug information and visualization"}),"\n",(0,a.jsx)(n.li,{children:"Test brain behavior across different scenarios"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-systems",children:"Related Systems"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/ai-systems/behaviourtree",children:"Behaviour Trees"})," - Tree structures that brains execute"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../components/index.md",children:"Components"})," - Entity components that brains interact with"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./actions.md",children:"Actions"})," - Actions that brains can trigger"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../stategraphs/index.md",children:"Stategraphs"})," - Animation states coordinated with brains"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"status--stable",children:"Status: \ud83d\udfe2 Stable"}),"\n",(0,a.jsx)(n.p,{children:"The Brain system is stable and fundamental to DST's AI architecture. The API is mature and changes are rare, focusing mainly on performance optimizations and debugging improvements."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);