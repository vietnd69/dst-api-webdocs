"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[24554],{25879:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"game-scripts/core-systems/world-systems/ocean/ocean-util","title":"Ocean Utilities","description":"Utility functions for ocean mechanics, water depth, wave spawning, and entity sinking in Don\'t Starve Together","source":"@site/docs/game-scripts/core-systems/world-systems/ocean/ocean_util.md","sourceDirName":"game-scripts/core-systems/world-systems/ocean","slug":"/game-scripts/core-systems/world-systems/ocean/ocean-util","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/ocean/ocean-util","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"ocean-util","title":"Ocean Utilities","description":"Utility functions for ocean mechanics, water depth, wave spawning, and entity sinking in Don\'t Starve Together","sidebar_position":1,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Ocean Systems Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/ocean/"},"next":{"title":"Tiles & Terrain Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/world-systems/tiles-terrain/"}}');var t=i(74848),r=i(28453);const a={id:"ocean-util",title:"Ocean Utilities",description:"Utility functions for ocean mechanics, water depth, wave spawning, and entity sinking in Don't Starve Together",sidebar_position:1,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},l="Ocean Utilities",o={},c=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Tile Checking Functions",id:"tile-checking-functions",level:2},{value:"IsOceanTile(tile)",id:"is-ocean-tile",level:3},{value:"IsLandTile(tile)",id:"is-land-tile",level:3},{value:"Ocean Depth Functions",id:"ocean-depth-functions",level:2},{value:"GetOceanDepthAtPosition(x, y, z)",id:"get-ocean-depth-at-position",level:3},{value:"GetOceanDepthAtPoint(pt)",id:"get-ocean-depth-at-point",level:3},{value:"Wave Spawning Functions",id:"wave-spawning-functions",level:2},{value:"SpawnAttackWaves(position, rotation, spawn_radius, numWaves, totalAngle, waveSpeed, wavePrefab, idleTime, instantActive)",id:"spawn-attack-waves",level:3},{value:"SpawnAttackWave(position, rotation, waveSpeed, wavePrefab, idleTime, instantActive)",id:"spawn-attack-wave",level:3},{value:"Pathfinding Functions",id:"pathfinding-functions",level:2},{value:"FindLandBetweenPoints(p0x, p0y, p1x, p1y)",id:"find-land-between-points",level:3},{value:"FindRandomPointOnShoreFromOcean(x, y, z, excludeclosest)",id:"find-random-point-on-shore-from-ocean",level:3},{value:"Flying Creature Management",id:"flying-creature-management",level:2},{value:"LandFlyingCreature(creature)",id:"land-flying-creature",level:3},{value:"RaiseFlyingCreature(creature)",id:"raise-flying-creature",level:3},{value:"Entity Sinking System",id:"entity-sinking-system",level:2},{value:"ShouldEntitySink(entity, entity_sinks_in_water)",id:"should-entity-sink",level:3},{value:"GetSinkEntityFXPrefabs(entity, px, py, pz)",id:"get-sink-entity-fx-prefabs",level:3},{value:"SinkEntity(entity)",id:"sink-entity",level:3},{value:"Utility Functions",id:"utility-functions",level:2},{value:"CanProbablyReachTargetFromShore(inst, target, max_distance)",id:"can-probably-reach-target-from-shore",level:3},{value:"TintByOceanTile(inst)",id:"tint-by-ocean-tile",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Ocean Traversal System",id:"ocean-traversal-system",level:3},{value:"Constants",id:"constants",level:2},{value:"Related Modules",id:"related-modules",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ocean-utilities",children:"Ocean Utilities"})}),"\n",(0,t.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Build Version"}),(0,t.jsx)(n.th,{children:"Change Date"}),(0,t.jsx)(n.th,{children:"Change Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"676042"}),(0,t.jsx)(n.td,{children:"2025-06-21"}),(0,t.jsx)(n.td,{children:"stable"}),(0,t.jsx)(n.td,{children:"Current version"})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ocean_util"})," module provides a comprehensive set of utility functions for handling ocean mechanics in Don't Starve Together. It includes functions for tile type checking, water depth calculation, wave spawning, entity sinking mechanics, and flying creature management. These utilities are essential for ocean-related gameplay features and world interaction systems."]}),"\n",(0,t.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Basic tile checking\nlocal is_ocean = IsOceanTile(tile)\nlocal is_land = IsLandTile(tile)\n\n-- Get ocean depth at a position\nlocal depth = GetOceanDepthAtPosition(x, y, z)\nif depth and depth > 0 then\n    print("Deep water detected: " .. depth)\nend\n\n-- Spawn attack waves around a position\nlocal waves_spawned = SpawnAttackWaves(\n    position,        -- center position\n    rotation,        -- starting rotation\n    spawn_radius,    -- radius from center\n    5,              -- number of waves\n    180,            -- total angle coverage\n    8,              -- wave speed\n    "wave_large",   -- wave prefab\n    3,              -- idle time\n    false           -- not instant active\n)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"tile-checking-functions",children:"Tile Checking Functions"}),"\n",(0,t.jsx)(n.h3,{id:"is-ocean-tile",children:"IsOceanTile(tile)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nChecks if the specified tile is an ocean tile type."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tile"})," (WORLD_TILES): The tile constant to check"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if the tile is an ocean tile, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local tile = TheWorld.Map:GetTileAtPoint(x, y, z)\nif IsOceanTile(tile) then\n    print("Player is over water")\nelse\n    print("Player is on land or other terrain")\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"is-land-tile",children:"IsLandTile(tile)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nChecks if the specified tile is a land tile type (non-ocean)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tile"})," (WORLD_TILES): The tile constant to check"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if the tile is a land tile, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local tile = TheWorld.Map:GetTileAtPoint(x, y, z)\nif IsLandTile(tile) then\n    print("Safe to build structures here")\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"ocean-depth-functions",children:"Ocean Depth Functions"}),"\n",(0,t.jsx)(n.h3,{id:"get-ocean-depth-at-position",children:"GetOceanDepthAtPosition(x, y, z)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nRetrieves the ocean depth value at the specified world coordinates."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"x"})," (number): World X coordinate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"y"})," (number): World Y coordinate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"z"})," (number): World Z coordinate"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(number|nil): Ocean depth value, or ",(0,t.jsx)(n.code,{children:"nil"})," if position is not in ocean or invalid"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local depth = GetOceanDepthAtPosition(100, 0, 200)\nif depth then\n    if depth > 10 then\n        print("Deep ocean - submarines can navigate here")\n    else\n        print("Shallow water - boats can navigate here")\n    end\nelse\n    print("Not in ocean")\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"get-ocean-depth-at-point",children:"GetOceanDepthAtPoint(pt)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nConvenience function to get ocean depth at a Vector3 point."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pt"})," (Vector3): Point with x, y, z coordinates"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(number|nil): Ocean depth value, or ",(0,t.jsx)(n.code,{children:"nil"})," if position is not in ocean or invalid"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local player_pos = ThePlayer:GetPosition()\nlocal depth = GetOceanDepthAtPoint(player_pos)\nif depth and depth > 5 then\n    -- Player is in moderately deep water\n    SpawnPrefab("deep_water_creature").Transform:SetPosition(player_pos:Get())\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"wave-spawning-functions",children:"Wave Spawning Functions"}),"\n",(0,t.jsx)(n.h3,{id:"spawn-attack-waves",children:"SpawnAttackWaves(position, rotation, spawn_radius, numWaves, totalAngle, waveSpeed, wavePrefab, idleTime, instantActive)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nSpawns multiple attack waves in a pattern around a central position. Useful for boss attacks, spell effects, or environmental hazards."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"position"})," (Vector3): Central position for wave spawning"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rotation"})," (number, optional): Starting rotation angle in degrees (random if nil)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spawn_radius"})," (number, optional): Radius from center to spawn waves (default: 0)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"numWaves"})," (number): Number of waves to spawn"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"totalAngle"})," (number, optional): Total angle coverage in degrees (default: 360)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"waveSpeed"})," (number|table, optional): Wave speed or velocity table (default: 6)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"wavePrefab"}),' (string, optional): Wave prefab name (default: "wave_med")']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idleTime"})," (number, optional): Time before wave becomes active (default: 5)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instantActive"})," (boolean, optional): Whether waves activate immediately (default: false)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if at least one wave was spawned, ",(0,t.jsx)(n.code,{children:"false"})," if none spawned"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Spawn a circular wave attack around boss\nlocal boss_pos = boss:GetPosition()\nlocal waves_created = SpawnAttackWaves(\n    boss_pos,        -- center on boss\n    0,               -- start at 0 degrees\n    8,               -- spawn 8 units away\n    8,               -- create 8 waves\n    360,             -- full circle\n    12,              -- fast wave speed\n    "wave_large",    -- use large waves\n    2,               -- 2 second delay\n    false            -- not instant\n)\n\nif waves_created then\n    boss:PushEvent("wave_attack_initiated")\nend\n\n-- Spawn directional wave attack\nSpawnAttackWaves(\n    caster_pos,      -- from caster\n    target_angle,    -- aim at target\n    5,               -- 5 units away\n    3,               -- 3 waves\n    60,              -- 60 degree spread\n    {10, 0, 0},      -- velocity vector\n    "wave_spell",    -- magic wave type\n    0,               -- instant activation\n    true             -- activate immediately\n)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"spawn-attack-wave",children:"SpawnAttackWave(position, rotation, waveSpeed, wavePrefab, idleTime, instantActive)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nSpawns a single attack wave. Convenience wrapper for ",(0,t.jsx)(n.code,{children:"SpawnAttackWaves"})," with ",(0,t.jsx)(n.code,{children:"numWaves = 1"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"position"})," (Vector3): Position to spawn the wave"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rotation"})," (number, optional): Wave rotation angle in degrees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"waveSpeed"})," (number|table, optional): Wave speed or velocity (default: 6)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"wavePrefab"}),' (string, optional): Wave prefab name (default: "wave_med")']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idleTime"})," (number, optional): Time before activation (default: 5)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instantActive"})," (boolean, optional): Immediate activation (default: false)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if wave was spawned, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Spawn single wave toward player\nlocal wave_spawned = SpawnAttackWave(\n    enemy_pos,          -- from enemy position\n    angle_to_player,    -- aimed at player\n    15,                 -- fast speed\n    "wave_boss",        -- boss wave type\n    1,                  -- 1 second delay\n    false               -- delayed activation\n)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pathfinding-functions",children:"Pathfinding Functions"}),"\n",(0,t.jsx)(n.h3,{id:"find-land-between-points",children:"FindLandBetweenPoints(p0x, p0y, p1x, p1y)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nFinds the first land tile along a line between two points using Bresenham-like algorithm. Useful for pathfinding from ocean to shore."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"p0x"})," (number): Starting X coordinate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"p0y"})," (number): Starting Y coordinate (treated as Z in world space)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"p1x"})," (number): Ending X coordinate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"p1y"})," (number): Ending Y coordinate (treated as Z in world space)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(Vector3|nil): Position of first land tile found, or ",(0,t.jsx)(n.code,{children:"nil"})," if no land found"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Find shore from ocean position\nlocal ocean_x, ocean_z = 100, 200\nlocal target_x, target_z = 50, 150\n\nlocal shore_point = FindLandBetweenPoints(ocean_x, ocean_z, target_x, target_z)\nif shore_point then\n    print("Found shore at: " .. shore_point.x .. ", " .. shore_point.z)\n    -- Move entity to shore\n    entity.Transform:SetPosition(shore_point:Get())\nelse\n    print("No land found between points")\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"find-random-point-on-shore-from-ocean",children:"FindRandomPointOnShoreFromOcean(x, y, z, excludeclosest)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nFinds a random accessible shore point from an ocean position. Prioritizes nearby nodes and handles shallow water specially."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"x"})," (number): Starting X coordinate in ocean"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"y"})," (number): Starting Y coordinate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"z"})," (number): Starting Z coordinate in ocean"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"excludeclosest"})," (boolean, optional): Whether to exclude the closest shore point"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(number, number, number|nil): Shore coordinates (x, y, z), or ",(0,t.jsx)(n.code,{children:"nil"})," if no shore found"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Teleport drowning player to random shore\nlocal player_x, player_y, player_z = player.Transform:GetWorldPosition()\n\nif IsOceanTile(TheWorld.Map:GetTileAtPoint(player_x, player_y, player_z)) then\n    local shore_x, shore_y, shore_z = FindRandomPointOnShoreFromOcean(\n        player_x, player_y, player_z, \n        true  -- exclude closest to add variety\n    )\n    \n    if shore_x then\n        player.Transform:SetPosition(shore_x, shore_y, shore_z)\n        player:PushEvent("teleported_to_shore")\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"flying-creature-management",children:"Flying Creature Management"}),"\n",(0,t.jsx)(n.h3,{id:"land-flying-creature",children:"LandFlyingCreature(creature)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nTransitions a flying creature to landed state, updating tags, collision, and triggering events."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"creature"})," (Entity): The flying creature entity to land"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Force bird to land when targeted by player\nlocal function ForceBirdLanding(bird, player)\n    if bird:HasTag("flying") then\n        LandFlyingCreature(bird)\n        bird.components.combat:SetTarget(player)\n        \n        -- Bird will now be affected by ground-based mechanics\n        bird:DoTaskInTime(5, function()\n            RaiseFlyingCreature(bird)  -- Take off after 5 seconds\n        end)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"raise-flying-creature",children:"RaiseFlyingCreature(creature)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nTransitions a creature to flying state, updating tags, collision, and triggering events."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"creature"})," (Entity): The creature entity to make fly"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Make creature fly when threatened\nlocal function MakeCreatureFly(creature)\n    if not creature:HasTag("flying") then\n        RaiseFlyingCreature(creature)\n        \n        -- Flying creatures avoid ground obstacles\n        creature.components.locomotor:SetExternalSpeedMultiplier(creature, "flying", 1.5)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"entity-sinking-system",children:"Entity Sinking System"}),"\n",(0,t.jsx)(n.h3,{id:"should-entity-sink",children:"ShouldEntitySink(entity, entity_sinks_in_water)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nDetermines if an entity should sink based on its position and water interaction rules."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"entity"})," (Entity): Entity to check for sinking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"entity_sinks_in_water"})," (boolean): Whether this entity type sinks in water"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if entity should sink, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check if dropped item should sink\nlocal function CheckItemSinking(item)\n    local should_sink = ShouldEntitySink(item, true)\n    if should_sink then\n        print("Item will sink in water")\n        SinkEntity(item)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"get-sink-entity-fx-prefabs",children:"GetSinkEntityFXPrefabs(entity, px, py, pz)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nGets appropriate visual effects for entity sinking based on tile type at position."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"entity"})," (Entity): Entity that is sinking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"px"})," (number): X position"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"py"})," (number): Y position"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pz"})," (number): Z position"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(table): Array of FX prefab names"}),"\n",(0,t.jsx)(n.li,{children:"(boolean): Whether fallback FX was used (out of bounds)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Available FX Types:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OCEAN"}),": ",(0,t.jsx)(n.code,{children:'{"splash_sink"}'})," - Ocean tile sinking effects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"VOID"}),": ",(0,t.jsx)(n.code,{children:'{"fallingswish_clouds", "fallingswish_lines"}'})," - Void/impassable tile effects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FALLBACK"}),": ",(0,t.jsx)(n.code,{children:'{"splash_ocean"}'})," - Default/legacy ocean effects"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Custom entity sinking with specific effects\nlocal function SinkEntityWithCustomFX(entity)\n    local px, py, pz = entity.Transform:GetWorldPosition()\n    local fx_prefabs, is_fallback = GetSinkEntityFXPrefabs(entity, px, py, pz)\n    \n    if is_fallback then\n        print("Using fallback FX - entity may be out of bounds")\n    end\n    \n    -- Spawn custom effects before standard ones\n    SpawnPrefab("custom_sink_warning").Transform:SetPosition(px, py, pz)\n    \n    -- Spawn standard effects\n    for _, fx_prefab in pairs(fx_prefabs) do\n        local fx = SpawnPrefab(fx_prefab)\n        fx.Transform:SetPosition(px, py, pz)\n    end\n    \n    entity:Remove()\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"sink-entity",children:"SinkEntity(entity)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nHandles complete entity sinking process including inventory dropping, FX spawning, and entity removal or relocation."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"entity"})," (Entity): Entity to sink"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Special Handling:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Irreplaceable items"}),": Entities with ",(0,t.jsx)(n.code,{children:'"irreplaceable"'})," tag are moved to shore instead of removed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shore-seeking items"}),": Entities with ",(0,t.jsx)(n.code,{children:'"shoreonsink"'})," tag are moved to shore"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Container entities"}),": All contents are dropped before sinking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FX spawning"}),": Appropriate visual effects are spawned based on tile type"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Sink player\'s boat when destroyed\nlocal function DestroyBoat(boat)\n    -- Drop all passengers and cargo first\n    if boat.components.container then\n        boat.components.container:DropEverything()\n    end\n    \n    -- Eject any riders\n    if boat.components.rideable then\n        boat.components.rideable:Buck()\n    end\n    \n    -- Sink the boat (will spawn appropriate FX)\n    SinkEntity(boat)\n    \n    -- Notify nearby players\n    local x, y, z = boat.Transform:GetWorldPosition()\n    local nearby_players = FindPlayersInRange(x, y, z, 20, true)\n    for _, player in pairs(nearby_players) do\n        player:PushEvent("boat_sunk", {boat = boat})\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,t.jsx)(n.h3,{id:"can-probably-reach-target-from-shore",children:"CanProbablyReachTargetFromShore(inst, target, max_distance)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nEstimates if an entity can reach a target from the shore within a maximum distance."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Entity attempting to reach target"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"})," (Entity): Target entity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"max_distance"})," (number): Maximum distance to check"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(boolean): ",(0,t.jsx)(n.code,{children:"true"})," if target is probably reachable from shore, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check if enemy can chase player onto land\nlocal function CanChaseToLand(sea_creature, player)\n    local can_reach = CanProbablyReachTargetFromShore(sea_creature, player, 15)\n    \n    if can_reach then\n        -- Sea creature can temporarily come ashore\n        sea_creature.components.combat:SetTarget(player)\n        sea_creature:AddTag("temporary_land_dweller")\n        \n        -- Return to water after some time\n        sea_creature:DoTaskInTime(30, function()\n            sea_creature:RemoveTag("temporary_land_dweller")\n            -- Find water and return\n        end)\n    else\n        print("Target too far inland - give up chase")\n        sea_creature.components.combat:SetTarget(nil)\n    end\n    \n    return can_reach\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"tint-by-ocean-tile",children:"TintByOceanTile(inst)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nApplies color tinting to an entity based on the ocean tile it's positioned over. Removes entity if not over water."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Entity to tint based on ocean tile"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Apply water-based tinting to wave effects\nlocal function CreateTintedWave(prefab_name, position)\n    local wave = SpawnPrefab(prefab_name)\n    wave.Transform:SetPosition(position:Get())\n    \n    -- Tint wave based on water type (deep blue, shallow green, etc.)\n    TintByOceanTile(wave)\n    \n    return wave\nend\n\n-- Custom tinting for special water effects\nlocal function CreateMagicWater(position)\n    local magic_water = SpawnPrefab("magic_water_effect")\n    magic_water.Transform:SetPosition(position:Get())\n    \n    -- Apply base tinting first\n    TintByOceanTile(magic_water)\n    \n    -- Then add magical overlay\n    magic_water:DoTaskInTime(0.1, function()\n        magic_water.AnimState:SetAddColour(0.5, 0, 0.5, 0)  -- Purple magical tint\n    end)\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"ocean-traversal-system",children:"Ocean Traversal System"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Complete ocean traversal and safety system\nlocal OceanTraversalSystem = {}\n\nfunction OceanTraversalSystem:CheckPlayerSafety(player)\n    local x, y, z = player.Transform:GetWorldPosition()\n    local tile = TheWorld.Map:GetTileAtPoint(x, y, z)\n    \n    if IsOceanTile(tile) then\n        local depth = GetOceanDepthAtPosition(x, y, z)\n        \n        if depth and depth > 10 then\n            -- Deep water - player needs boat or swimming ability\n            if not player:HasTag("swimming") and not player:GetCurrentPlatform() then\n                self:InitiateWaterRescue(player, x, y, z)\n                return false\n            end\n        elseif depth and depth > 0 then\n            -- Shallow water - slower movement but survivable\n            player.components.locomotor:SetExternalSpeedMultiplier(player, "shallow_water", 0.5)\n        end\n    else\n        -- On land - remove water speed penalty\n        player.components.locomotor:RemoveExternalSpeedMultiplier(player, "shallow_water")\n    end\n    \n    return true\nend\n\nfunction OceanTraversalSystem:InitiateWaterRescue(player, x, y, z)\n    -- Find nearest shore\n    local shore_x, shore_y, shore_z = FindRandomPointOnShoreFromOcean(x, y, z)\n    \n    if shore_x then\n        -- Spawn rescue waves to push player to shore\n        SpawnAttackWaves(\n            Vector3(x, y, z),    -- from player position\n            math.atan2(shore_z - z, shore_x - x) * RADIANS,  -- toward shore\n            2,                   -- close to player\n            1,                   -- single rescue wave\n            0,                   -- direct line\n            {5, 0, 0},          -- push toward shore\n            "wave_rescue",      -- special rescue wave\n            0,                  -- immediate\n            true                -- instant active\n        )\n        \n        player:PushEvent("water_rescue_initiated")\n    else\n        -- Emergency teleport if no shore found\n        SinkEntity(player)  -- Will handle irreplaceable tag\n    end\nend\n\nreturn OceanTraversalSystem\n'})}),"\n",(0,t.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,t.jsx)(n.p,{children:"The module references several constants defined elsewhere:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"WAVE_SPAWN_DISTANCE"}),": ",(0,t.jsx)(n.code,{children:"1.5"})," - Standard distance offset for wave spawning"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TILE_SCALE"}),": Tile scaling factor for pathfinding calculations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SINKENTITY_PREFABS"}),": Table mapping tile types to appropriate FX prefabs"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./constants.md",children:"Tile Group Manager"}),": Manages tile type classification and properties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./map/",children:"World Map"}),": World tile and topology management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./physics.md",children:"Physics"}),": Collision and movement systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../components/combat.md",children:"Combat"}),": Combat targeting and interaction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./prefabs.md",children:"Prefabs"}),": Entity spawning and management system"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tile Checking"}),": Uses efficient TileGroupManager calls for tile type verification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pathfinding"}),": FindLandBetweenPoints uses optimized line-drawing algorithm"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wave Spawning"}),": Batches multiple wave creation for performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FX Management"}),": Selective FX spawning based on tile type reduces overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Entity Sinking"}),": Minimal processing for simple cases, more complex handling only for special tags"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);