"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[4444],{3572:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"api-vanilla/examples/case-wormhole","title":"Case Study - Wormhole Marks","description":"This case study examines the \\"Wormhole Marks\\" mod for Don\'t Starve Together, which helps players track wormhole connections by adding visual markers. We\'ll analyze its implementation and extract valuable modding techniques.","source":"@site/docs/api-vanilla/examples/case-wormhole.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/case-wormhole","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-wormhole","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"id":"case-wormhole","title":"Case Study - Wormhole Marks","sidebar_position":12},"sidebar":"docs","previous":{"title":"Case Study - Geometric Placement","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-geometric"},"next":{"title":"Case Study - Combined Status","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-status"}}');var t=i(4848),s=i(8453);const o={id:"case-wormhole",title:"Case Study - Wormhole Marks",sidebar_position:12},r="Case Study: Wormhole Marks Mod",l={},d=[{value:"Mod Overview",id:"mod-overview",level:2},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"Core Techniques Used",id:"core-techniques-used",level:3},{value:"1. Entity Identification and Pairing",id:"1-entity-identification-and-pairing",level:2},{value:"Key Code Elements",id:"key-code-elements",level:3},{value:"Implementation Analysis",id:"implementation-analysis",level:3},{value:"2. Custom Visual Indicators",id:"2-custom-visual-indicators",level:2},{value:"Key Code Elements",id:"key-code-elements-1",level:3},{value:"Implementation Analysis",id:"implementation-analysis-1",level:3},{value:"3. Minimap Integration",id:"3-minimap-integration",level:2},{value:"Key Code Elements",id:"key-code-elements-2",level:3},{value:"Implementation Analysis",id:"implementation-analysis-2",level:3},{value:"4. Data Persistence",id:"4-data-persistence",level:2},{value:"Key Code Elements",id:"key-code-elements-3",level:3},{value:"Implementation Analysis",id:"implementation-analysis-3",level:3},{value:"5. Network Synchronization",id:"5-network-synchronization",level:2},{value:"Key Code Elements",id:"key-code-elements-4",level:3},{value:"Implementation Analysis",id:"implementation-analysis-4",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"1. Entity Relationship Tracking",id:"1-entity-relationship-tracking",level:3},{value:"2. Visual Enhancement Without Gameplay Changes",id:"2-visual-enhancement-without-gameplay-changes",level:3},{value:"3. Effective Data Management",id:"3-effective-data-management",level:3},{value:"4. User Experience Focus",id:"4-user-experience-focus",level:3},{value:"Implementing Similar Features",id:"implementing-similar-features",level:2},{value:"Step 1: Identify Target Entities",id:"step-1-identify-target-entities",level:3},{value:"Step 2: Establish Relationships",id:"step-2-establish-relationships",level:3},{value:"Step 3: Create Visual Indicators",id:"step-3-create-visual-indicators",level:3},{value:"Step 4: Add Persistence",id:"step-4-add-persistence",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"case-study-wormhole-marks-mod",children:"Case Study: Wormhole Marks Mod"})}),"\n",(0,t.jsx)(n.p,{children:"This case study examines the \"Wormhole Marks\" mod for Don't Starve Together, which helps players track wormhole connections by adding visual markers. We'll analyze its implementation and extract valuable modding techniques."}),"\n",(0,t.jsx)(n.h2,{id:"mod-overview",children:"Mod Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Wormhole Marks mod solves a common gameplay challenge: remembering which wormholes connect to each other. The mod:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Assigns matching symbols to connected wormhole pairs"}),"\n",(0,t.jsx)(n.li,{children:"Displays these symbols above wormholes in the world"}),"\n",(0,t.jsx)(n.li,{children:"Shows the symbols on the map for easy navigation"}),"\n",(0,t.jsx)(n.li,{children:"Persists markings between game sessions"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"core-techniques-used",children:"Core Techniques Used"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Entity Identification and Pairing"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Custom Visual Indicators"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Minimap Integration"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Data Persistence"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Network Synchronization"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's examine each of these techniques in detail."}),"\n",(0,t.jsx)(n.h2,{id:"1-entity-identification-and-pairing",children:"1. Entity Identification and Pairing"}),"\n",(0,t.jsx)(n.p,{children:"The mod needs to identify all wormholes in the world and determine which ones are connected to each other."}),"\n",(0,t.jsx)(n.h3,{id:"key-code-elements",children:"Key Code Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Find and track all wormholes in the world\nlocal function InitializeWormholes()\n    -- Clear existing data\n    WORMHOLE_PAIRS = {}\n    \n    -- Find all wormholes in the world\n    local wormholes = {}\n    for _, v in pairs(Ents) do\n        if v.prefab == "wormhole" then\n            table.insert(wormholes, v)\n        end\n    end\n    \n    -- Create pairs based on wormhole connections\n    local assigned = {}\n    for i, wormhole in ipairs(wormholes) do\n        if not assigned[wormhole] then\n            -- Find this wormhole\'s target\n            local target = wormhole.components.teleporter.targetTeleporter\n            if target and not assigned[target] then\n                -- Create a new pair\n                local pair_id = #WORMHOLE_PAIRS + 1\n                WORMHOLE_PAIRS[pair_id] = {wormhole, target}\n                \n                -- Mark both as assigned\n                assigned[wormhole] = true\n                assigned[target] = true\n                \n                -- Assign a symbol to this pair\n                AssignSymbolToPair(pair_id)\n            end\n        end\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-analysis",children:"Implementation Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The pairing system demonstrates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Entity Filtering"}),": Finding specific entities by prefab name"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Component Access"}),": Using the teleporter component to find connections"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relationship Tracking"}),": Creating pairs based on in-game relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Duplicate Prevention"}),": Using a lookup table to prevent double-assignment"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2-custom-visual-indicators",children:"2. Custom Visual Indicators"}),"\n",(0,t.jsx)(n.p,{children:"The mod creates visual indicators that appear above each wormhole in the world."}),"\n",(0,t.jsx)(n.h3,{id:"key-code-elements-1",children:"Key Code Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Create a visual marker for a wormhole\nlocal function CreateWormholeMarker(wormhole, symbol)\n    -- Remove any existing marker\n    if wormhole._wormhole_marker then\n        wormhole._wormhole_marker:Remove()\n    end\n    \n    -- Create a new marker entity\n    local marker = SpawnPrefab("wormholemarker")\n    \n    -- Position it above the wormhole\n    local x, y, z = wormhole.Transform:GetWorldPosition()\n    marker.Transform:SetPosition(x, y + 2.5, z)\n    \n    -- Set the symbol\n    marker.symbol = symbol\n    marker.AnimState:OverrideSymbol("symbol", "wormhole_symbols", symbol)\n    \n    -- Link it to the wormhole\n    wormhole._wormhole_marker = marker\n    marker.entity:SetParent(wormhole.entity)\n    \n    return marker\nend\n\n-- Assign a symbol to a wormhole pair\nfunction AssignSymbolToPair(pair_id)\n    local pair = WORMHOLE_PAIRS[pair_id]\n    if not pair then return end\n    \n    -- Choose a symbol from our set\n    local symbol = "symbol_" .. ((pair_id - 1) % NUM_SYMBOLS + 1)\n    \n    -- Create markers for both wormholes in the pair\n    CreateWormholeMarker(pair[1], symbol)\n    CreateWormholeMarker(pair[2], symbol)\n    \n    -- Store the symbol for this pair\n    WORMHOLE_SYMBOLS[pair_id] = symbol\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-analysis-1",children:"Implementation Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The visual indicator system demonstrates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom Entity Creation"}),": Spawning specialized marker entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visual Customization"}),": Using OverrideSymbol for custom appearances"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Entity Positioning"}),": Placing markers relative to their parent objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parent-Child Relationships"}),": Using SetParent to attach markers to wormholes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Removing old markers before creating new ones"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"3-minimap-integration",children:"3. Minimap Integration"}),"\n",(0,t.jsx)(n.p,{children:"The mod adds custom icons to the minimap to show wormhole locations and their symbols."}),"\n",(0,t.jsx)(n.h3,{id:"key-code-elements-2",children:"Key Code Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Add minimap icons for wormholes\nlocal function AddMinimapIcons()\n    -- For each wormhole pair\n    for pair_id, pair in pairs(WORMHOLE_PAIRS) do\n        local symbol = WORMHOLE_SYMBOLS[pair_id]\n        if symbol then\n            -- Add minimap icon for each wormhole in the pair\n            for _, wormhole in ipairs(pair) do\n                if wormhole and wormhole:IsValid() then\n                    -- Create or update minimap icon\n                    if not wormhole._minimap_icon then\n                        wormhole._minimap_icon = SpawnPrefab("wormholemapicon")\n                        wormhole._minimap_icon.MiniMapEntity:SetPriority(10)\n                    end\n                    \n                    -- Set the icon\'s position and symbol\n                    local x, y, z = wormhole.Transform:GetWorldPosition()\n                    wormhole._minimap_icon.Transform:SetPosition(x, 0, z)\n                    \n                    -- Set the icon\'s appearance\n                    wormhole._minimap_icon.MiniMapEntity:SetIcon(symbol)\n                    \n                    -- Make the icon follow the wormhole\n                    wormhole:ListenForEvent("onremove", function()\n                        if wormhole._minimap_icon then\n                            wormhole._minimap_icon:Remove()\n                        end\n                    end)\n                end\n            end\n        end\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-analysis-2",children:"Implementation Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The minimap integration demonstrates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom Map Icons"}),": Creating specialized entities for the map"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Map Priority"}),": Setting the display priority for map icons"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Icon Customization"}),": Setting custom icons based on wormhole pairs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Position Tracking"}),": Keeping map icons synchronized with world entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleanup Management"}),": Removing map icons when their wormholes are removed"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"4-data-persistence",children:"4. Data Persistence"}),"\n",(0,t.jsx)(n.p,{children:"The mod saves wormhole pairing information between game sessions."}),"\n",(0,t.jsx)(n.h3,{id:"key-code-elements-3",children:"Key Code Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Save wormhole data\nlocal function SaveWormholeData()\n    -- Prepare data structure\n    local data = {\n        pairs = {},\n        symbols = {}\n    }\n    \n    -- Save pair information using entity references\n    for pair_id, pair in pairs(WORMHOLE_PAIRS) do\n        data.pairs[pair_id] = {\n            pair[1].GUID,\n            pair[2].GUID\n        }\n    end\n    \n    -- Save symbol assignments\n    for pair_id, symbol in pairs(WORMHOLE_SYMBOLS) do\n        data.symbols[pair_id] = symbol\n    end\n    \n    -- Save to world storage\n    if TheWorld.components.worldstate then\n        TheWorld.components.worldstate:SetValue("wormhole_data", data)\n    end\nend\n\n-- Load wormhole data\nlocal function LoadWormholeData()\n    -- Get data from world storage\n    local data = nil\n    if TheWorld.components.worldstate then\n        data = TheWorld.components.worldstate:GetValue("wormhole_data")\n    end\n    \n    if not data then return false end\n    \n    -- Clear existing data\n    WORMHOLE_PAIRS = {}\n    WORMHOLE_SYMBOLS = {}\n    \n    -- Restore pair information from entity references\n    for pair_id, guid_pair in pairs(data.pairs) do\n        local wormhole1 = Ents[guid_pair[1]]\n        local wormhole2 = Ents[guid_pair[2]]\n        \n        if wormhole1 and wormhole2 and \n           wormhole1:IsValid() and wormhole2:IsValid() then\n            WORMHOLE_PAIRS[pair_id] = {wormhole1, wormhole2}\n        end\n    end\n    \n    -- Restore symbol assignments\n    for pair_id, symbol in pairs(data.symbols) do\n        WORMHOLE_SYMBOLS[pair_id] = symbol\n        \n        -- Recreate visual markers\n        local pair = WORMHOLE_PAIRS[pair_id]\n        if pair then\n            CreateWormholeMarker(pair[1], symbol)\n            CreateWormholeMarker(pair[2], symbol)\n        end\n    end\n    \n    return true\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-analysis-3",children:"Implementation Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The data persistence system demonstrates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Serialization"}),": Converting runtime objects to serializable data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Entity References"}),": Using GUIDs to reference entities between sessions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"World State Storage"}),": Using the worldstate component for persistence"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Restoration"}),": Rebuilding runtime state from saved data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),": Checking that entities still exist when restoring data"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"5-network-synchronization",children:"5. Network Synchronization"}),"\n",(0,t.jsx)(n.p,{children:"The mod ensures that all players see the same wormhole markings in multiplayer games."}),"\n",(0,t.jsx)(n.h3,{id:"key-code-elements-4",children:"Key Code Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Sync wormhole data to clients\nlocal function SyncWormholeData()\n    if not TheWorld.ismastersim then return end\n    \n    -- Prepare data for network transmission\n    local data = {\n        pairs = {},\n        symbols = {}\n    }\n    \n    -- Convert entity references to GUIDs\n    for pair_id, pair in pairs(WORMHOLE_PAIRS) do\n        data.pairs[pair_id] = {\n            pair[1].GUID,\n            pair[2].GUID\n        }\n    end\n    \n    -- Include symbol assignments\n    for pair_id, symbol in pairs(WORMHOLE_SYMBOLS) do\n        data.symbols[pair_id] = symbol\n    end\n    \n    -- Serialize the data\n    local data_string = json.encode(data)\n    \n    -- Send to all clients\n    for i, player in ipairs(AllPlayers) do\n        if player.userid then\n            SendModRPCToClient(GetClientModRPC("WormholeMarks", "ReceiveWormholeData"), player.userid, data_string)\n        end\n    end\nend\n\n-- RPC handler for clients to receive data\nAddClientModRPCHandler("WormholeMarks", "ReceiveWormholeData", function(data_string)\n    -- Deserialize the data\n    local success, data = pcall(json.decode, data_string)\n    if not success or not data then return end\n    \n    -- Apply the data\n    ApplyWormholeData(data)\nend)\n\n-- Apply received wormhole data\nfunction ApplyWormholeData(data)\n    -- Clear existing data\n    WORMHOLE_PAIRS = {}\n    WORMHOLE_SYMBOLS = {}\n    \n    -- Process pair information\n    for pair_id, guid_pair in pairs(data.pairs) do\n        local wormhole1 = Ents[guid_pair[1]]\n        local wormhole2 = Ents[guid_pair[2]]\n        \n        if wormhole1 and wormhole2 and \n           wormhole1:IsValid() and wormhole2:IsValid() then\n            WORMHOLE_PAIRS[pair_id] = {wormhole1, wormhole2}\n        end\n    end\n    \n    -- Apply symbol assignments\n    for pair_id, symbol in pairs(data.symbols) do\n        WORMHOLE_SYMBOLS[pair_id] = symbol\n        \n        -- Recreate visual markers\n        local pair = WORMHOLE_PAIRS[pair_id]\n        if pair then\n            CreateWormholeMarker(pair[1], symbol)\n            CreateWormholeMarker(pair[2], symbol)\n        end\n    end\n    \n    -- Update minimap icons\n    AddMinimapIcons()\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-analysis-4",children:"Implementation Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The network synchronization demonstrates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Server Authority"}),": Only the server generates the initial data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Serialization"}),": Converting complex data structures to strings for transmission"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RPC System"}),": Using Remote Procedure Calls to communicate between server and clients"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Using pcall to safely handle potentially corrupted data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Application"}),": Applying received data to recreate the visual state"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,t.jsx)(n.p,{children:"From analyzing the Wormhole Marks mod, we can extract several valuable lessons for mod development:"}),"\n",(0,t.jsx)(n.h3,{id:"1-entity-relationship-tracking",children:"1. Entity Relationship Tracking"}),"\n",(0,t.jsx)(n.p,{children:"The mod demonstrates effective techniques for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identifying related entities in the world"}),"\n",(0,t.jsx)(n.li,{children:"Creating and maintaining relationships between entities"}),"\n",(0,t.jsx)(n.li,{children:"Visualizing these relationships for players"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-visual-enhancement-without-gameplay-changes",children:"2. Visual Enhancement Without Gameplay Changes"}),"\n",(0,t.jsx)(n.p,{children:"The mod enhances the game experience by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Adding visual information without changing core gameplay"}),"\n",(0,t.jsx)(n.li,{children:"Using subtle but clear visual indicators"}),"\n",(0,t.jsx)(n.li,{children:"Integrating with existing systems (minimap, wormholes)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-effective-data-management",children:"3. Effective Data Management"}),"\n",(0,t.jsx)(n.p,{children:"The mod shows good practices for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Organizing complex data relationships"}),"\n",(0,t.jsx)(n.li,{children:"Persisting data between game sessions"}),"\n",(0,t.jsx)(n.li,{children:"Synchronizing data in multiplayer environments"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-user-experience-focus",children:"4. User Experience Focus"}),"\n",(0,t.jsx)(n.p,{children:"The mod prioritizes user experience through:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Solving a real player pain point"}),"\n",(0,t.jsx)(n.li,{children:"Using intuitive visual language"}),"\n",(0,t.jsx)(n.li,{children:"Minimizing configuration requirements"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementing-similar-features",children:"Implementing Similar Features"}),"\n",(0,t.jsx)(n.p,{children:"If you want to create a mod with similar entity-tracking features, follow these steps:"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-identify-target-entities",children:"Step 1: Identify Target Entities"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Find entities of interest\nfunction FindTargetEntities()\n    local targets = {}\n    \n    -- Search through all entities\n    for _, v in pairs(Ents) do\n        -- Filter by prefab or tag\n        if v.prefab == "target_prefab" or v:HasTag("target_tag") then\n            table.insert(targets, v)\n        end\n    end\n    \n    return targets\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-establish-relationships",children:"Step 2: Establish Relationships"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"-- Create relationships between entities\nfunction EstablishRelationships(entities)\n    local relationships = {}\n    \n    -- Example: Pair entities by distance\n    local assigned = {}\n    for i, entity1 in ipairs(entities) do\n        if not assigned[entity1] then\n            -- Find closest unassigned entity\n            local closest = nil\n            local closest_dist = math.huge\n            \n            for j, entity2 in ipairs(entities) do\n                if entity1 ~= entity2 and not assigned[entity2] then\n                    local dist = entity1:GetDistanceSqToInst(entity2)\n                    if dist < closest_dist then\n                        closest = entity2\n                        closest_dist = dist\n                    end\n                end\n            end\n            \n            -- Create relationship if found\n            if closest then\n                table.insert(relationships, {entity1, closest})\n                assigned[entity1] = true\n                assigned[closest] = true\n            end\n        end\n    end\n    \n    return relationships\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-create-visual-indicators",children:"Step 3: Create Visual Indicators"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Create a visual indicator for an entity\nfunction CreateIndicator(entity, symbol)\n    -- Create indicator entity\n    local indicator = SpawnPrefab("indicator_prefab")\n    \n    -- Position above the entity\n    local x, y, z = entity.Transform:GetWorldPosition()\n    indicator.Transform:SetPosition(x, y + 1.5, z)\n    \n    -- Set appearance\n    indicator.AnimState:OverrideSymbol("symbol", "indicator_symbols", symbol)\n    \n    -- Link to entity\n    entity._indicator = indicator\n    indicator.entity:SetParent(entity.entity)\n    \n    return indicator\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-4-add-persistence",children:"Step 4: Add Persistence"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Save relationship data\nfunction SaveRelationshipData()\n    local data = {\n        relationships = {},\n        symbols = {}\n    }\n    \n    -- Convert to serializable format\n    for i, relationship in ipairs(RELATIONSHIPS) do\n        data.relationships[i] = {\n            relationship[1].GUID,\n            relationship[2].GUID\n        }\n        data.symbols[i] = RELATIONSHIP_SYMBOLS[i]\n    end\n    \n    -- Save to world state\n    if TheWorld.components.worldstate then\n        TheWorld.components.worldstate:SetValue("relationship_data", data)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The Wormhole Marks mod exemplifies excellent mod design through:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Focused Problem-Solving"}),": Addressing a specific player pain point"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-Invasive Enhancement"}),": Adding information without changing gameplay"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Technical Excellence"}),": Implementing robust systems for tracking and visualization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multiplayer Awareness"}),": Ensuring consistent experiences across all players"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By studying this mod, we can learn how to create mods that enhance the game's usability while respecting its core design. These principles apply to any mod that aims to visualize relationships between game elements."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);