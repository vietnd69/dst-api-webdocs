"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[12122],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>t});var r=i(96540);const l={},s=r.createContext(l);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},66152:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"game-scripts/core-systems/development-tools/profiling/profiler","title":"Profiler","description":"Lua code performance profiling system for debugging and optimization analysis","source":"@site/docs/game-scripts/core-systems/development-tools/profiling/profiler.md","sourceDirName":"game-scripts/core-systems/development-tools/profiling","slug":"/game-scripts/core-systems/development-tools/profiling/profiler","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/development-tools/profiling/profiler","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"profiler","title":"Profiler","description":"Lua code performance profiling system for debugging and optimization analysis","sidebar_position":1,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Mixer","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/development-tools/profiling/mixer"},"next":{"title":"Development Utilities Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/development-tools/utilities/"}}');var l=i(74848),s=i(28453);const o={id:"profiler",title:"Profiler",description:"Lua code performance profiling system for debugging and optimization analysis",sidebar_position:1,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},t="Profiler",a={},c=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Module Structure",id:"module-structure",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"newProfiler(variant, sampledelay)",id:"new-profiler",level:3},{value:"profiler()",id:"profiler-start",level:3},{value:"profiler()",id:"profiler-stop",level:3},{value:"profiler(sort_by_total_time)",id:"profiler-report",level:3},{value:"profiler(func, level)",id:"profiler-prevent",level:3},{value:"Profiling Methods",id:"profiling-methods",level:2},{value:"Time-Based Profiling",id:"time-based-profiling",level:3},{value:"Call-Based Profiling",id:"call-based-profiling",level:3},{value:"Internal Architecture",id:"internal-architecture",level:2},{value:"State Management",id:"state-management",level:3},{value:"Data Collection",id:"data-collection",level:3},{value:"Time-Based Collection",id:"time-based-collection",level:4},{value:"Call-Based Collection",id:"call-based-collection",level:4},{value:"Function Record Structure",id:"function-record-structure",level:3},{value:"Report Format",id:"report-format",level:2},{value:"Standard Report Structure",id:"standard-report-structure",level:3},{value:"Report Sections",id:"report-sections",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"Basic Profiling Session",id:"basic-profiling-session",level:3},{value:"Focused Profiling",id:"focused-profiling",level:3},{value:"Comparative Analysis",id:"comparative-analysis",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Profiling Overhead",id:"profiling-overhead",level:3},{value:"Optimization Guidelines",id:"optimization-guidelines",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Validation",id:"validation",level:3},{value:"Integration with DST",id:"integration-with-dst",level:2},{value:"Game Loop Profiling",id:"game-loop-profiling",level:3},{value:"Mod Development",id:"mod-development",level:3},{value:"Related Modules",id:"related-modules",level:2},{value:"Notes",id:"notes",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"profiler",children:"Profiler"})}),"\n",(0,l.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Build Version"}),(0,l.jsx)(n.th,{children:"Change Date"}),(0,l.jsx)(n.th,{children:"Change Type"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"676042"}),(0,l.jsx)(n.td,{children:"2025-06-21"}),(0,l.jsx)(n.td,{children:"stable"}),(0,l.jsx)(n.td,{children:"Current version"})]})})]}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"profiler.lua"})," module provides comprehensive Lua code performance profiling capabilities for Don't Starve Together. Based on the Pepperfish profiler, it enables developers to analyze function execution times, call counts, and performance bottlenecks in Lua scripts. The profiler supports both time-based and call-based profiling methods with detailed reporting functionality."]}),"\n",(0,l.jsx)(n.h2,{id:"module-structure",children:"Module Structure"}),"\n",(0,l.jsxs)(n.p,{children:["The profiler system is built around a global ",(0,l.jsx)(n.code,{children:"_profiler"})," table that contains the core profiling functionality and state management:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"_profiler = {\n    -- Core profiling methods\n    start = function(self),\n    stop = function(self),\n    report = function(self, sort_by_total_time),\n    prevent = function(self, func, level),\n    \n    -- Internal state\n    running = nil, -- Currently active profiler instance\n    prevented_functions = {}, -- Functions excluded from profiling\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,l.jsx)(n.h3,{id:"new-profiler",children:"newProfiler(variant, sampledelay)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nCreates a new profiler instance with specified profiling method and sampling configuration."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"variant"}),' (string, optional): Profiling method - "time" (default) or "call"']}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sampledelay"})," (number, optional): Sample delay for time-based profiling (default: 100000)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"(table): New profiler instance with profiling methods"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Create time-based profiler (recommended)\nlocal profiler = newProfiler("time", 100000)\n\n-- Create call-based profiler\nlocal call_profiler = newProfiler("call")\n\n-- Use default settings\nlocal default_profiler = newProfiler()\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Profiling Methods:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:'"time"'}),": Real performance-based profiling (recommended)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:'"call"'}),": Function call-based profiling"]}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"profiler-start",children:["profiler",":start","()"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nStarts the profiling session. Only one profiler can be active at a time. Initializes internal state and sets up debug hooks for data collection."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"(void): No return value"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"local profiler = newProfiler()\nprofiler:start()\n\n-- Code to be profiled goes here\nsome_expensive_function()\n\nprofiler:stop()\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Internal Operations:"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Sets ",(0,l.jsx)(n.code,{children:"_profiler.running"})," to current instance"]}),"\n",(0,l.jsxs)(n.li,{children:["Initializes ",(0,l.jsx)(n.code,{children:"rawstats"})," and ",(0,l.jsx)(n.code,{children:"callstack"})," tables"]}),"\n",(0,l.jsx)(n.li,{children:"Sets up appropriate debug hook based on profiling variant"}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"profiler-stop",children:["profiler",":stop","()"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nStops the profiling session and removes debug hooks. Only affects the currently running profiler instance."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"(void): No return value"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"profiler:start()\n-- Profiled code execution\nprofiler:stop()\n\n-- Generate and save report\nlocal report = profiler:report()\nprint(report)\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"profiler-report",children:["profiler",":report","(sort_by_total_time)"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nGenerates a comprehensive profiling report with function statistics, timing information, and call hierarchies."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sort_by_total_time"})," (boolean, optional): If true, sorts by total time; if false/nil, sorts by self time"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"(string): Formatted profiling report"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Report Contents:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Function call/sample counts"}),"\n",(0,l.jsx)(n.li,{children:"Total time spent in functions"}),"\n",(0,l.jsx)(n.li,{children:"Time spent in children vs. self"}),"\n",(0,l.jsx)(n.li,{children:"Per-call/sample timing averages"}),"\n",(0,l.jsx)(n.li,{children:"Child function call statistics"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Basic report sorted by self time\nlocal report = profiler:report()\n\n-- Report sorted by total time\nlocal total_time_report = profiler:report(true)\n\n-- Save to file\nlocal file = io.open("profile_report.txt", "w")\nfile:write(profiler:report())\nfile:close()\n'})}),"\n",(0,l.jsxs)(n.h3,{id:"profiler-prevent",children:["profiler",":prevent","(func, level)"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Status:"})," ",(0,l.jsx)(n.code,{children:"stable"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Description:"}),"\nExcludes specified functions from profiling to reduce overhead or focus analysis on specific code areas."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"func"})," (function): Function reference to exclude from profiling"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"level"})," (number, optional): Prevention level (1 = exclude function, 2 = exclude function and children)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"(void): No return value"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"local profiler = newProfiler()\n\n-- Exclude expensive logging function\nprofiler:prevent(debug_log_function, 1)\n\n-- Exclude entire subsystem\nprofiler:prevent(render_system_main, 2)\n\nprofiler:start()\n-- Profiling with exclusions\nprofiler:stop()\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Prevention Levels:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Level 1"}),": Excludes only the specified function"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Level 2"}),": Excludes function and all its children (call-based profiling)"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"profiling-methods",children:"Profiling Methods"}),"\n",(0,l.jsx)(n.h3,{id:"time-based-profiling",children:"Time-Based Profiling"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Recommended Method:"})," Provides accurate real-performance measurements."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Samples based on actual execution time"}),"\n",(0,l.jsx)(n.li,{children:"Default sample delay: 100,000 opcodes (~2ms intervals)"}),"\n",(0,l.jsx)(n.li,{children:"Approximately 10% performance overhead"}),"\n",(0,l.jsx)(n.li,{children:"More accurate for performance optimization"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'local profiler = newProfiler("time", 50000) -- Higher frequency sampling\nprofiler:start()\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Accuracy Notes:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Lower sample delays increase accuracy but reduce performance"}),"\n",(0,l.jsx)(n.li,{children:"Higher sample delays reduce overhead but may miss short functions"}),"\n",(0,l.jsx)(n.li,{children:"Default settings provide good balance for most use cases"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"call-based-profiling",children:"Call-Based Profiling"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Alternative Method:"})," Tracks function calls and returns."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Profiles every function call and return"}),"\n",(0,l.jsx)(n.li,{children:"Provides exact call counts"}),"\n",(0,l.jsx)(n.li,{children:"May heavily bias towards call-heavy code"}),"\n",(0,l.jsx)(n.li,{children:"Comparable to traditional profilers (gprof)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'local profiler = newProfiler("call")\nprofiler:start()\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Bias Considerations:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Can show significant bias towards areas with many function calls"}),"\n",(0,l.jsx)(n.li,{children:"May report inaccurate timing for call-heavy vs. computation-heavy code"}),"\n",(0,l.jsx)(n.li,{children:"Useful for call count analysis and function coverage"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"internal-architecture",children:"Internal Architecture"}),"\n",(0,l.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"_profiler = {\n    running = nil, -- Currently active profiler instance\n    prevented_functions = {\n        -- Internal profiler functions automatically excluded\n        [_profiler.start] = 2,\n        [_profiler.stop] = 2,\n        [_profiler._internal_profile_by_time] = 2,\n        [_profiler._internal_profile_by_call] = 2,\n        -- Additional internal functions...\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"data-collection",children:"Data Collection"}),"\n",(0,l.jsx)(n.h4,{id:"time-based-collection",children:"Time-Based Collection"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"function _profiler._internal_profile_by_time(self, action)\n    local timetaken = os.clock() - self.lastclock\n    \n    -- Walk call stack and attribute time to each function\n    local depth = 3\n    local caller = debug.getinfo(depth)\n    while caller do\n        -- Update function statistics\n        local info = self:_get_func_rec(caller.func, 1, caller)\n        info.count = info.count + 1\n        info.time = info.time + timetaken\n        -- Handle parent-child relationships\n        depth = depth + 1\n        caller = debug.getinfo(depth)\n    end\n    \n    self.lastclock = os.clock()\nend\n"})}),"\n",(0,l.jsx)(n.h4,{id:"call-based-collection",children:"Call-Based Collection"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'function _profiler._internal_profile_by_call(self, action)\n    local caller_info = debug.getinfo(3)\n    \n    if action == "call" then\n        -- Track function entry\n        local this_ar = {\n            clock_start = os.clock(),\n            children = {},\n            children_time = {}\n        }\n        table.insert(self.callstack, this_ar)\n    else\n        -- Track function exit and calculate timing\n        local this_ar = self.callstack[#self.callstack]\n        this_ar.this_time = os.clock() - this_ar.clock_start\n        -- Update statistics and parent information\n        table.remove(self.callstack)\n    end\nend\n'})}),"\n",(0,l.jsx)(n.h3,{id:"function-record-structure",children:"Function Record Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"local function_record = {\n    func = function_reference,\n    count = 0, -- Number of calls/samples\n    time = 0, -- Total time spent\n    anon_child_time = 0, -- Time in anonymous children\n    name_child_time = 0, -- Time in named children\n    children = {}, -- Child function call counts\n    children_time = {}, -- Time spent in each child\n    func_info = debug_info -- Function metadata\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"report-format",children:"Report Format"}),"\n",(0,l.jsx)(n.h3,{id:"standard-report-structure",children:"Standard Report Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"---------------------------------------- function_name ----------------------------------------\nSample count:         1234\nTime spend total:     123.456ms\nTime spent in children: 98.765ms\nTime spent in self:   24.691ms\nTime spent per sample: 0.10000ms/sample\nTime spent in self per sample: 0.02000ms/sample\n\nChild child_function_name               called   567 times. Took 45.67ms\nChild another_child                     called   890 times. Took 23.45ms\n\n---------------------------------------- next_function ----------------------------------------\n...\n\nTotal time spent in profiled functions: 1234.567ms\n"})}),"\n",(0,l.jsx)(n.h3,{id:"report-sections",children:"Report Sections"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Function Header"}),": Function name with decorative separators"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Count Statistics"}),": Number of samples/calls"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Time Statistics"}),": Total, children, self, and per-call timings"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Child Statistics"}),": Time and call counts for child functions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Summary"}),": Total profiled time"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,l.jsx)(n.h3,{id:"basic-profiling-session",children:"Basic Profiling Session"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Create and configure profiler\nlocal profiler = newProfiler("time", 100000)\n\n-- Start profiling\nprofiler:start()\n\n-- Execute code to be profiled\ngame_update_loop()\nrender_frame()\nprocess_ai()\n\n-- Stop profiling\nprofiler:stop()\n\n-- Generate and save report\nlocal report = profiler:report()\nlocal file = io.open("performance_profile.txt", "w")\nfile:write(report)\nfile:close()\n'})}),"\n",(0,l.jsx)(n.h3,{id:"focused-profiling",children:"Focused Profiling"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'local profiler = newProfiler("time")\n\n-- Exclude logging and debug functions\nprofiler:prevent(log_debug, 1)\nprofiler:prevent(log_info, 1)\nprofiler:prevent(assert_check, 2)\n\n-- Profile only critical game systems\nprofiler:start()\nupdate_world_simulation()\nupdate_character_ai()\nprocess_combat_systems()\nprofiler:stop()\n\nlocal focused_report = profiler:report()\n'})}),"\n",(0,l.jsx)(n.h3,{id:"comparative-analysis",children:"Comparative Analysis"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Profile different algorithms\nlocal algorithms = {\n    algorithm_a = function() --[[ implementation ]] end,\n    algorithm_b = function() --[[ implementation ]] end,\n    algorithm_c = function() --[[ implementation ]] end\n}\n\nfor name, algorithm in pairs(algorithms) do\n    local profiler = newProfiler("time")\n    profiler:start()\n    \n    -- Run algorithm multiple times for statistical accuracy\n    for i = 1, 1000 do\n        algorithm()\n    end\n    \n    profiler:stop()\n    \n    local report = profiler:report()\n    local file = io.open("profile_" .. name .. ".txt", "w")\n    file:write(report)\n    file:close()\nend\n'})}),"\n",(0,l.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsx)(n.h3,{id:"profiling-overhead",children:"Profiling Overhead"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Method"}),(0,l.jsx)(n.th,{children:"Sample Delay"}),(0,l.jsx)(n.th,{children:"Overhead"}),(0,l.jsx)(n.th,{children:"Accuracy"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Time"}),(0,l.jsx)(n.td,{children:"100,000"}),(0,l.jsx)(n.td,{children:"~10%"}),(0,l.jsx)(n.td,{children:"Good"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Time"}),(0,l.jsx)(n.td,{children:"50,000"}),(0,l.jsx)(n.td,{children:"~15%"}),(0,l.jsx)(n.td,{children:"Better"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Time"}),(0,l.jsx)(n.td,{children:"200,000"}),(0,l.jsx)(n.td,{children:"~5%"}),(0,l.jsx)(n.td,{children:"Lower"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Call"}),(0,l.jsx)(n.td,{children:"N/A"}),(0,l.jsx)(n.td,{children:"Variable"}),(0,l.jsx)(n.td,{children:"Call counts accurate"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"optimization-guidelines",children:"Optimization Guidelines"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Use time-based profiling"})," for performance optimization"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Adjust sample delay"})," based on accuracy vs. performance needs"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Exclude frequently called utility functions"})," to reduce noise"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Profile representative workloads"})," for meaningful results"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Run multiple profiling sessions"})," to account for variance"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,l.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:"-- Attempt to start when profiler already running\nlocal profiler1 = newProfiler()\nlocal profiler2 = newProfiler()\n\nprofiler1:start()\nprofiler2:start() -- This will silently fail\n\n-- Check for running profiler\nif not _profiler.running then\n    profiler:start()\nend\n"})}),"\n",(0,l.jsx)(n.h3,{id:"validation",children:"Validation"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Validate profiler method\nlocal profiler = newProfiler("invalid_method") -- Returns nil with error message\n\n-- Safe profiler creation\nlocal function create_safe_profiler(method)\n    local profiler = newProfiler(method)\n    if not profiler then\n        print("Failed to create profiler with method:", method)\n        return newProfiler("time") -- Fallback to default\n    end\n    return profiler\nend\n'})}),"\n",(0,l.jsx)(n.h2,{id:"integration-with-dst",children:"Integration with DST"}),"\n",(0,l.jsx)(n.h3,{id:"game-loop-profiling",children:"Game Loop Profiling"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Profile main game update cycle\nlocal game_profiler = newProfiler("time")\n\nfunction profile_frame()\n    game_profiler:start()\n    -- Game frame execution\n    game_profiler:stop()\n    \n    -- Periodic reporting\n    if frame_count % 3600 == 0 then -- Every minute at 60 FPS\n        local report = game_profiler:report()\n        save_profile_report(report)\n        game_profiler = newProfiler("time") -- Reset for next period\n    end\nend\n'})}),"\n",(0,l.jsx)(n.h3,{id:"mod-development",children:"Mod Development"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-lua",children:'-- Profile mod initialization\nlocal mod_profiler = newProfiler("call")\nmod_profiler:start()\n\n-- Load mod components\nload_mod_assets()\nregister_mod_prefabs()\nsetup_mod_systems()\n\nmod_profiler:stop()\nlocal mod_report = mod_profiler:report()\nprint("Mod loading profile:", mod_report)\n'})}),"\n",(0,l.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./debugtools.md",children:(0,l.jsx)(n.code,{children:"debugtools"})}),": Development and debugging utilities"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./debughelpers.md",children:(0,l.jsx)(n.code,{children:"debughelpers"})}),": Helper functions for debugging"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./main.md",children:(0,l.jsx)(n.code,{children:"main"})}),": Main game loop integration points"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./perfutil.md",children:(0,l.jsx)(n.code,{children:"perfutil"})}),": Performance utility functions"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Only one profiler can be active at a time globally"}),"\n",(0,l.jsx)(n.li,{children:"The profiler automatically excludes its own internal functions from measurement"}),"\n",(0,l.jsx)(n.li,{children:"Time-based profiling is recommended for most performance analysis needs"}),"\n",(0,l.jsx)(n.li,{children:"Call-based profiling is useful for understanding function call patterns"}),"\n",(0,l.jsx)(n.li,{children:"Reports can be saved to files for detailed analysis"}),"\n",(0,l.jsx)(n.li,{children:"Sample delay affects both accuracy and performance overhead"}),"\n",(0,l.jsxs)(n.li,{children:["The profiler uses ",(0,l.jsx)(n.code,{children:"debug.sethook()"})," and may interfere with other debugging tools"]}),"\n",(0,l.jsx)(n.li,{children:"Profiling results should be validated across multiple runs for statistical significance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);