"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[1125],{3797:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-vanilla/node-types/sequence-nodes","title":"Sequence Nodes","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/node-types/sequence-nodes.md","sourceDirName":"api-vanilla/node-types","slug":"/api-vanilla/node-types/sequence-nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"sequence-nodes","title":"Sequence Nodes","sidebar_position":6,"last_updated":"2023-07-06T00:00:00.000Z","version":619045},"sidebar":"docs","previous":{"title":"Priority Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes"},"next":{"title":"Data Types","permalink":"/dst-api-webdocs/docs/category/data-types"}}');var i=t(4848),l=t(8453);const r={id:"sequence-nodes",title:"Sequence Nodes",sidebar_position:6,last_updated:new Date("2023-07-06T00:00:00.000Z"),version:619045},o="Sequence Nodes",d={},c=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Sequence Node States",id:"sequence-node-states",level:2},{value:"Built-in Sequence Nodes",id:"built-in-sequence-nodes",level:2},{value:"SequenceNode",id:"sequencenode",level:3},{value:"DoWhileNode",id:"dowhilenode",level:3},{value:"ParallelNodeAny",id:"parallelnodeany",level:3},{value:"ParallelNodeAll",id:"parallelnodeall",level:3},{value:"Common Sequence Patterns",id:"common-sequence-patterns",level:2},{value:"Multi-step Actions",id:"multi-step-actions",level:3},{value:"Validation Chains",id:"validation-chains",level:3},{value:"State Machines",id:"state-machines",level:3},{value:"Creating Custom Sequence Nodes",id:"creating-custom-sequence-nodes",level:2},{value:"Example: Interruptible Sequence",id:"example-interruptible-sequence",level:2},{value:"Example: Retry Sequence",id:"example-retry-sequence",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sequence-nodes",children:"Sequence Nodes"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"API Version: 619045"})}),"\n",(0,i.jsx)(n.p,{children:"Sequence Nodes are essential components in Don't Starve Together's behavior tree system that execute child nodes in order until one fails or all succeed. They act as a logical \"AND\" operation, executing each child node sequentially and only succeeding if all children succeed."}),"\n",(0,i.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Basic sequence node structure\nlocal MySequence = Class(BehaviorNode, function(self, inst, children)\n    BehaviorNode._ctor(self, "MySequence")\n    self.inst = inst\n    self.children = children\n    self.current_child = 1\nend)\n\nfunction MySequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n\n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- As soon as one child fails, the whole sequence fails\n            self.status = FAILURE\n        end\n    end\n    \n    return self.status\nend\n\n-- Used in a behavior tree\nlocal root = MySequence(inst, {\n    FindFood(inst),\n    GoToFood(inst),\n    EatFood(inst)\n})\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sequence-node-states",children:"Sequence Node States"}),"\n",(0,i.jsx)(n.p,{children:"Sequence nodes can be in one of several states:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"State"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"READY"})}),(0,i.jsx)(n.td,{children:"Node is ready to begin executing children"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"RUNNING"})}),(0,i.jsx)(n.td,{children:"Node is currently executing one of its children"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SUCCESS"})}),(0,i.jsx)(n.td,{children:"All child nodes have executed successfully"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"FAILURE"})}),(0,i.jsx)(n.td,{children:"One of the child nodes has failed"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"built-in-sequence-nodes",children:"Built-in Sequence Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Don't Starve Together includes several pre-defined sequence nodes:"}),"\n",(0,i.jsx)(n.h3,{id:"sequencenode",children:"SequenceNode"}),"\n",(0,i.jsx)(n.p,{children:"The basic sequence node that executes children in order until one fails or all succeed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Basic format\nSequenceNode(inst, {\n    child_node1,\n    child_node2,\n    child_node3\n})\n\n-- Example: Find, go to, and eat food\nSequenceNode(inst, {\n    FindFood(inst, {"fruit", "veggie"}, 20),\n    GoToEntity(inst, function() return inst.components.eater.foodtarget end, 1),\n    DoAction(inst, function(inst) \n        return inst.components.eater:Eat(inst.components.eater.foodtarget)\n    end)\n})\n'})}),"\n",(0,i.jsx)(n.h3,{id:"dowhilenode",children:"DoWhileNode"}),"\n",(0,i.jsx)(n.p,{children:"Executes a sequence of nodes while a condition remains true."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Basic format\nDoWhileNode(inst, condition_fn, {\n    child_node1,\n    child_node2,\n    ...\n})\n\n-- Example: Keep gathering resources while inventory has space\nDoWhileNode(inst, \n    function() \n        -- Continue while inventory has space\n        return not inst.components.inventory:IsFull() \n    end, \n    {\n        FindItem(inst, function(item) return item.prefab == "log" end, 10),\n        DoAction(inst, function(inst) \n            if inst.finditem then\n                return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n            end\n        end)\n    }\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parallelnodeany",children:"ParallelNodeAny"}),"\n",(0,i.jsx)(n.p,{children:"Executes multiple nodes in parallel and succeeds if any child succeeds."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Basic format\nParallelNodeAny(inst, {\n    child_node1,\n    child_node2,\n    ...\n})\n\n-- Example: Try multiple ways to get food in parallel\nParallelNodeAny(inst, {\n    -- Try to find dropped food\n    SequenceNode(inst, {\n        FindItem(inst, function(item) \n            return item.components.edible ~= nil \n        end, 15),\n        DoAction(inst, function(inst) \n            if inst.finditem then\n                return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n            end\n        end)\n    }),\n    -- Or try to harvest berry bushes\n    SequenceNode(inst, {\n        FindEntity(inst, 15, function(ent)\n            return ent.prefab == "berrybush" and \n                   ent.components.pickable and \n                   ent.components.pickable:CanBePicked()\n        end),\n        DoAction(inst, function(inst) \n            if inst.findentity then\n                return BufferedAction(inst, inst.findentity, ACTIONS.PICK)\n            end\n        end)\n    })\n})\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parallelnodeall",children:"ParallelNodeAll"}),"\n",(0,i.jsx)(n.p,{children:"Executes multiple nodes in parallel and only succeeds if all children succeed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Basic format\nParallelNodeAll(inst, {\n    child_node1,\n    child_node2,\n    ...\n})\n\n-- Example: Track multiple conditions simultaneously\nParallelNodeAll(inst, {\n    -- Monitor health\n    DoAction(inst, function() \n        return inst.components.health:GetPercent() > 0.25 \n    end),\n    -- Monitor sanity\n    DoAction(inst, function() \n        return inst.components.sanity:GetPercent() > 0.25\n    end),\n    -- Monitor hunger\n    DoAction(inst, function() \n        return inst.components.hunger:GetPercent() > 0.15\n    end)\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-sequence-patterns",children:"Common Sequence Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Sequence nodes are often used for these common patterns:"}),"\n",(0,i.jsx)(n.h3,{id:"multi-step-actions",children:"Multi-step Actions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Break a task into sequential steps\nSequenceNode(inst, {\n    -- First find a tree\n    FindEntity(inst, 20, function(ent) \n        return ent.prefab == "evergreen" and \n               ent.components.workable and \n               ent.components.workable:CanBeWorked() \n    end),\n    \n    -- Go to the tree\n    GoToEntity(inst, function() return inst.findentity end, 1),\n    \n    -- Chop the tree\n    DoAction(inst, function(inst) \n        if inst.findentity then\n            return BufferedAction(inst, inst.findentity, ACTIONS.CHOP)\n        end\n    end),\n    \n    -- Wait for the tree to fall\n    WaitNode(inst, 1),\n    \n    -- Pick up the logs\n    FindItem(inst, function(item) return item.prefab == "log" end, 10),\n    DoAction(inst, function(inst) \n        if inst.finditem then\n            return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n        end\n    end)\n})\n'})}),"\n",(0,i.jsx)(n.h3,{id:"validation-chains",children:"Validation Chains"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Check multiple conditions before taking action\nSequenceNode(inst, {\n    -- Check if it\'s safe (no monsters nearby)\n    DoAction(inst, function()\n        local x, y, z = inst.Transform:GetWorldPosition()\n        local ents = TheSim:FindEntities(x, y, z, 10, {"monster"})\n        return #ents == 0\n    end),\n    \n    -- Check if we have the right tool\n    DoAction(inst, function()\n        return inst.components.inventory:Has("axe", 1)\n    end),\n    \n    -- Check if our health is high enough\n    DoAction(inst, function()\n        return inst.components.health:GetPercent() > 0.5\n    end),\n    \n    -- If all checks pass, perform the main action\n    DoAction(inst, function() \n        -- Do the actual task\n        return true\n    end)\n})\n'})}),"\n",(0,i.jsx)(n.h3,{id:"state-machines",children:"State Machines"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Implement a simple state machine\nSequenceNode(inst, {\n    -- State: Hungry\n    IfNode(function() \n        return inst.components.hunger:GetPercent() < 0.5 \n    end,\n        SequenceNode(inst, {\n            FindFood(inst),\n            GoToFood(inst),\n            EatFood(inst)\n        })\n    ),\n    \n    -- State: Tired\n    IfNode(function() \n        return inst.components.sleeper:IsVeryTired() \n    end,\n        SequenceNode(inst, {\n            FindSleepLocation(inst),\n            GoToSleepLocation(inst),\n            Sleep(inst)\n        })\n    ),\n    \n    -- State: Default gathering\n    SequenceNode(inst, {\n        FindResources(inst),\n        GatherResources(inst)\n    })\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-custom-sequence-nodes",children:"Creating Custom Sequence Nodes"}),"\n",(0,i.jsx)(n.p,{children:"To create a custom sequence node:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Derive from BehaviorNode"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local CustomSequence = Class(BehaviorNode, function(self, inst, children, ...)\n    BehaviorNode._ctor(self, "CustomSequence")\n    self.inst = inst\n    self.children = children\n    self.current_child = 1\n    -- Store other parameters\nend)\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implement Visit function"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function CustomSequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        -- Implement custom sequence logic here\n        -- Decide how to handle SUCCESS and FAILURE of children\n        -- Update self.current_child as needed\n    end\n    \n    return self.status\nend\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Optional: Implement Stop function"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function CustomSequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\nend\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-interruptible-sequence",children:"Example: Interruptible Sequence"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- A sequence node that can be interrupted by a condition\nlocal InterruptibleSequence = Class(BehaviorNode, function(self, inst, children, interrupt_fn)\n    BehaviorNode._ctor(self, "InterruptibleSequence")\n    self.inst = inst\n    self.children = children\n    self.interrupt_fn = interrupt_fn\n    self.current_child = 1\nend)\n\nfunction InterruptibleSequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        -- Check interrupt condition first\n        if self.interrupt_fn and self.interrupt_fn(self.inst) then\n            -- Interrupt the sequence\n            self.status = FAILURE\n            return self.status\n        end\n        \n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- As soon as one child fails, the whole sequence fails\n            self.status = FAILURE\n        end\n    end\n    \n    return self.status\nend\n\nfunction InterruptibleSequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\nend\n\n-- Usage\nlocal behavior = InterruptibleSequence(inst,\n    {\n        FindFood(inst),\n        GoToFood(inst),\n        EatFood(inst)\n    },\n    function(inst)\n        -- Interrupt if health gets too low or a monster appears\n        return inst.components.health:GetPercent() < 0.2 or\n               FindEntity(inst, 10, {"monster"}) ~= nil\n    end\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"example-retry-sequence",children:"Example: Retry Sequence"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- A sequence node that retries failed children a certain number of times\nlocal RetrySequence = Class(BehaviorNode, function(self, inst, children, max_retries)\n    BehaviorNode._ctor(self, "RetrySequence")\n    self.inst = inst\n    self.children = children\n    self.max_retries = max_retries or 3\n    self.current_child = 1\n    self.retry_count = 0\nend)\n\nfunction RetrySequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.retry_count = 0\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            self.retry_count = 0\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- Child failed, try to retry\n            self.retry_count = self.retry_count + 1\n            \n            if self.retry_count <= self.max_retries then\n                -- Retry the current child\n                self.children[self.current_child]:Stop()\n                self.children[self.current_child]:Start()\n            else\n                -- Max retries exceeded, the sequence fails\n                self.status = FAILURE\n            end\n        end\n    end\n    \n    return self.status\nend\n\nfunction RetrySequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\n    self.retry_count = 0\nend\n\n-- Usage\nlocal behavior = RetrySequence(inst,\n    {\n        FindFood(inst),\n        GoToFood(inst),\n        EatFood(inst)\n    },\n    2 -- Try each step up to 2 additional times if it fails\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Child Order"}),": Arrange children so that the ones most likely to fail come first, to minimize wasted processing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node Count"}),": Keep the number of children in a sequence manageable; consider breaking complex sequences into sub-sequences"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Management"}),": Be careful with managing state across sequence steps to prevent side effects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Consider using custom sequence nodes with retry capabilities for critical operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime Costs"}),": Be aware that deeply nested sequences can have significant runtime costs"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/brain",children:"Brain"})," - For brain implementation using behavior trees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/action-nodes",children:"Action Nodes"})," - For nodes that perform actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes",children:"Priority Nodes"})," - For selecting between different actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes",children:"Condition Nodes"})," - For conditional execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes",children:"Decorator Nodes"})," - For modifying the behavior of other nodes"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},l=s.createContext(i);function r(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);