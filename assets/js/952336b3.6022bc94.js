"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5694],{4803:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-vanilla/examples/snippets/saving-loading","title":"Saving and Loading Snippets","description":"This page provides reusable code snippets for saving and loading data in Don\'t Starve Together mods.","source":"@site/docs/api-vanilla/examples/snippets/saving-loading.md","sourceDirName":"api-vanilla/examples/snippets","slug":"/api-vanilla/examples/snippets/saving-loading","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/saving-loading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"saving-loading","title":"Saving and Loading Snippets","sidebar_position":3},"sidebar":"docs","previous":{"title":"Event Handling Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/event-handling"},"next":{"title":"UI Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/ui-snippets"}}');var i=a(4848),s=a(8453);const d={id:"saving-loading",title:"Saving and Loading Snippets",sidebar_position:3},o="Saving and Loading Snippets",r={},l=[{value:"Basic Saving and Loading",id:"basic-saving-and-loading",level:2},{value:"Saving Component Data",id:"saving-component-data",level:3},{value:"Entity Save/Load Handlers",id:"entity-saveload-handlers",level:3},{value:"Advanced Saving and Loading",id:"advanced-saving-and-loading",level:2},{value:"Saving References to Other Entities",id:"saving-references-to-other-entities",level:3},{value:"Saving Binary Data",id:"saving-binary-data",level:3},{value:"Saving Player-Specific Data",id:"saving-player-specific-data",level:3},{value:"Mod Configuration Saving",id:"mod-configuration-saving",level:2},{value:"Basic Mod Configuration",id:"basic-mod-configuration",level:3},{value:"Per-World Configuration",id:"per-world-configuration",level:3},{value:"Saving Large Data Structures",id:"saving-large-data-structures",level:2},{value:"Chunked Data Saving",id:"chunked-data-saving",level:3},{value:"Versioned Data Saving",id:"versioned-data-saving",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"saving-and-loading-snippets",children:"Saving and Loading Snippets"})}),"\n",(0,i.jsx)(e.p,{children:"This page provides reusable code snippets for saving and loading data in Don't Starve Together mods."}),"\n",(0,i.jsx)(e.h2,{id:"basic-saving-and-loading",children:"Basic Saving and Loading"}),"\n",(0,i.jsx)(e.h3,{id:"saving-component-data",children:"Saving Component Data"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Basic component with save/load functionality\nlocal MyComponent = Class(function(self, inst)\n    self.inst = inst\n    self.value = 0\n    self.items = {}\n    self.enabled = true\nend)\n\n-- Save component data\nfunction MyComponent:OnSave()\n    return {\n        value = self.value,\n        items = self.items,\n        enabled = self.enabled\n    }\nend\n\n-- Load component data\nfunction MyComponent:OnLoad(data)\n    if data then\n        self.value = data.value or self.value\n        self.items = data.items or self.items\n        self.enabled = data.enabled ~= nil and data.enabled or self.enabled\n    end\nend\n\n-- Usage in a prefab\nlocal function fn()\n    local inst = CreateEntity()\n    -- ... other entity setup ...\n    \n    inst:AddComponent("mycomponent")\n    \n    return inst\nend\n'})}),"\n",(0,i.jsx)(e.h3,{id:"entity-saveload-handlers",children:"Entity Save/Load Handlers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Entity with save/load handlers\nlocal function fn()\n    local inst = CreateEntity()\n    -- ... other entity setup ...\n    \n    -- Custom data to save\n    inst.persistent_data = {\n        counter = 0,\n        last_used = nil,\n        settings = {\n            power_level = 1,\n            mode = "normal"\n        }\n    }\n    \n    -- Save handler\n    inst.OnSave = function(inst)\n        local data = {\n            counter = inst.persistent_data.counter,\n            last_used = inst.persistent_data.last_used,\n            settings = inst.persistent_data.settings\n        }\n        return data\n    end\n    \n    -- Load handler\n    inst.OnLoad = function(inst, data)\n        if data then\n            if data.counter then inst.persistent_data.counter = data.counter end\n            if data.last_used then inst.persistent_data.last_used = data.last_used end\n            if data.settings then inst.persistent_data.settings = data.settings end\n        end\n    end\n    \n    return inst\nend\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-saving-and-loading",children:"Advanced Saving and Loading"}),"\n",(0,i.jsx)(e.h3,{id:"saving-references-to-other-entities",children:"Saving References to Other Entities"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"-- Saving references to other entities\nlocal function fn()\n    local inst = CreateEntity()\n    -- ... other entity setup ...\n    \n    -- References to other entities\n    inst.linked_entities = {}\n    \n    -- Function to link to another entity\n    inst.LinkEntity = function(inst, other)\n        if other and other.GUID then\n            table.insert(inst.linked_entities, other)\n        end\n    end\n    \n    -- Save handler with references\n    inst.OnSave = function(inst)\n        local references = {}\n        local data = {\n            linked_entity_guids = {}\n        }\n        \n        -- Save GUIDs of linked entities\n        for i, entity in ipairs(inst.linked_entities) do\n            if entity:IsValid() then\n                table.insert(data.linked_entity_guids, entity.GUID)\n                table.insert(references, entity.GUID)\n            end\n        end\n        \n        return data, references\n    end\n    \n    -- Load handler with references\n    inst.OnLoad = function(inst, data)\n        if data and data.linked_entity_guids then\n            inst.linked_entity_guids = data.linked_entity_guids\n        end\n    end\n    \n    -- Resolve references after world loads\n    inst.OnLoadPostPass = function(inst)\n        if inst.linked_entity_guids then\n            for i, guid in ipairs(inst.linked_entity_guids) do\n                local entity = Ents[guid]\n                if entity then\n                    table.insert(inst.linked_entities, entity)\n                end\n            end\n            inst.linked_entity_guids = nil\n        end\n    end\n    \n    return inst\nend\n"})}),"\n",(0,i.jsx)(e.h3,{id:"saving-binary-data",children:"Saving Binary Data"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Saving binary or complex data with string encoding\nlocal function fn()\n    local inst = CreateEntity()\n    -- ... other entity setup ...\n    \n    -- Complex data structure\n    inst.map_data = {\n        {1, 0, 1, 0, 1},\n        {0, 1, 0, 1, 0},\n        {1, 0, 1, 0, 1}\n    }\n    \n    -- Encode map data to string\n    local function EncodeMapData(map_data)\n        local result = {}\n        table.insert(result, #map_data) -- Height\n        table.insert(result, #map_data[1]) -- Width\n        \n        for y, row in ipairs(map_data) do\n            for x, cell in ipairs(row) do\n                table.insert(result, cell)\n            end\n        end\n        \n        return table.concat(result, ",")\n    end\n    \n    -- Decode map data from string\n    local function DecodeMapData(encoded)\n        local values = {}\n        for value in string.gmatch(encoded, "[^,]+") do\n            table.insert(values, tonumber(value))\n        end\n        \n        local height = values[1]\n        local width = values[2]\n        local map = {}\n        \n        local index = 3\n        for y = 1, height do\n            map[y] = {}\n            for x = 1, width do\n                map[y][x] = values[index]\n                index = index + 1\n            end\n        end\n        \n        return map\n    end\n    \n    -- Save handler with encoding\n    inst.OnSave = function(inst)\n        return {\n            encoded_map = EncodeMapData(inst.map_data)\n        }\n    end\n    \n    -- Load handler with decoding\n    inst.OnLoad = function(inst, data)\n        if data and data.encoded_map then\n            inst.map_data = DecodeMapData(data.encoded_map)\n        end\n    end\n    \n    return inst\nend\n'})}),"\n",(0,i.jsx)(e.h3,{id:"saving-player-specific-data",children:"Saving Player-Specific Data"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:"-- Saving player-specific data\nlocal function fn()\n    local inst = CreateEntity()\n    -- ... other entity setup ...\n    \n    -- Player data storage\n    inst.player_data = {}\n    \n    -- Add data for a player\n    inst.SetPlayerData = function(inst, player, key, value)\n        local userid = player and player.userid\n        if userid then\n            inst.player_data[userid] = inst.player_data[userid] or {}\n            inst.player_data[userid][key] = value\n        end\n    end\n    \n    -- Get data for a player\n    inst.GetPlayerData = function(inst, player, key)\n        local userid = player and player.userid\n        if userid and inst.player_data[userid] then\n            return inst.player_data[userid][key]\n        end\n        return nil\n    end\n    \n    -- Save handler\n    inst.OnSave = function(inst)\n        return {\n            player_data = inst.player_data\n        }\n    end\n    \n    -- Load handler\n    inst.OnLoad = function(inst, data)\n        if data and data.player_data then\n            inst.player_data = data.player_data\n        end\n    end\n    \n    return inst\nend\n"})}),"\n",(0,i.jsx)(e.h2,{id:"mod-configuration-saving",children:"Mod Configuration Saving"}),"\n",(0,i.jsx)(e.h3,{id:"basic-mod-configuration",children:"Basic Mod Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Basic mod configuration system\nlocal ModConfig = {\n    config = {\n        difficulty = "normal",\n        spawn_rate = 0.5,\n        enable_feature = true\n    },\n    \n    -- Default values\n    defaults = {\n        difficulty = "normal",\n        spawn_rate = 0.5,\n        enable_feature = true\n    }\n}\n\n-- Save configuration to mod settings\nfunction ModConfig:Save()\n    local config_str = json.encode(self.config)\n    TheSim:SetPersistentString("my_mod_config", config_str, false)\nend\n\n-- Load configuration from mod settings\nfunction ModConfig:Load()\n    TheSim:GetPersistentString("my_mod_config", function(success, config_str)\n        if success and config_str and #config_str > 0 then\n            local success, config = pcall(function() return json.decode(config_str) end)\n            if success and config then\n                -- Merge with defaults for any missing values\n                for k, v in pairs(self.defaults) do\n                    if config[k] == nil then\n                        config[k] = v\n                    end\n                end\n                self.config = config\n            end\n        end\n    end)\nend\n\n-- Set a configuration value\nfunction ModConfig:Set(key, value)\n    self.config[key] = value\n    self:Save()\nend\n\n-- Get a configuration value\nfunction ModConfig:Get(key)\n    return self.config[key]\nend\n\n-- Reset to defaults\nfunction ModConfig:Reset()\n    self.config = deepcopy(self.defaults)\n    self:Save()\nend\n\n-- Initialize on mod load\nfunction ModConfig:Init()\n    self:Load()\nend\n\n-- Usage\n-- ModConfig:Init()\n-- local difficulty = ModConfig:Get("difficulty")\n-- ModConfig:Set("spawn_rate", 0.75)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"per-world-configuration",children:"Per-World Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Per-world configuration system\nlocal WorldConfig = {\n    world_configs = {},\n    current_config = nil,\n    \n    -- Default values\n    defaults = {\n        structures = {},\n        resources_harvested = 0,\n        events_triggered = {}\n    }\n}\n\n-- Get current world ID\nfunction WorldConfig:GetWorldID()\n    if TheWorld and TheWorld.meta then\n        return TheWorld.meta.session_identifier\n    end\n    return nil\nend\n\n-- Save configuration for current world\nfunction WorldConfig:Save()\n    local world_id = self:GetWorldID()\n    if world_id and self.current_config then\n        self.world_configs[world_id] = deepcopy(self.current_config)\n        \n        local config_str = json.encode(self.world_configs)\n        TheSim:SetPersistentString("my_mod_world_configs", config_str, false)\n    end\nend\n\n-- Load configurations for all worlds\nfunction WorldConfig:LoadAll()\n    TheSim:GetPersistentString("my_mod_world_configs", function(success, config_str)\n        if success and config_str and #config_str > 0 then\n            local success, configs = pcall(function() return json.decode(config_str) end)\n            if success and configs then\n                self.world_configs = configs\n            end\n        end\n    end)\nend\n\n-- Initialize configuration for current world\nfunction WorldConfig:InitForCurrentWorld()\n    local world_id = self:GetWorldID()\n    if world_id then\n        if self.world_configs[world_id] then\n            self.current_config = deepcopy(self.world_configs[world_id])\n        else\n            self.current_config = deepcopy(self.defaults)\n        end\n    else\n        self.current_config = deepcopy(self.defaults)\n    end\nend\n\n-- Set a configuration value for current world\nfunction WorldConfig:Set(key, value)\n    if self.current_config then\n        self.current_config[key] = value\n        self:Save()\n    end\nend\n\n-- Get a configuration value for current world\nfunction WorldConfig:Get(key)\n    if self.current_config then\n        return self.current_config[key]\n    end\n    return nil\nend\n\n-- Initialize on mod load and world load\nfunction WorldConfig:Init()\n    self:LoadAll()\n    \n    -- Initialize when world is ready\n    if TheWorld then\n        self:InitForCurrentWorld()\n    else\n        -- Wait for world to be ready\n        self.world_ready_task = TheWorld:DoTaskInTime(0, function()\n            self:InitForCurrentWorld()\n            self.world_ready_task = nil\n        end)\n    end\nend\n\n-- Usage\n-- WorldConfig:Init()\n-- local resources = WorldConfig:Get("resources_harvested")\n-- WorldConfig:Set("resources_harvested", resources + 1)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"saving-large-data-structures",children:"Saving Large Data Structures"}),"\n",(0,i.jsx)(e.h3,{id:"chunked-data-saving",children:"Chunked Data Saving"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Saving large data structures in chunks\nlocal ChunkedStorage = {\n    chunk_size = 10000, -- Maximum size of each chunk\n    prefix = "my_mod_data_chunk_"\n}\n\n-- Save large data in chunks\nfunction ChunkedStorage:Save(key, data)\n    -- Convert data to string\n    local data_str = json.encode(data)\n    \n    -- Calculate number of chunks needed\n    local num_chunks = math.ceil(#data_str / self.chunk_size)\n    \n    -- Save metadata\n    TheSim:SetPersistentString(self.prefix .. key .. "_meta", json.encode({\n        num_chunks = num_chunks,\n        total_size = #data_str\n    }), false)\n    \n    -- Save each chunk\n    for i = 1, num_chunks do\n        local start_pos = (i - 1) * self.chunk_size + 1\n        local end_pos = math.min(i * self.chunk_size, #data_str)\n        local chunk = string.sub(data_str, start_pos, end_pos)\n        \n        TheSim:SetPersistentString(self.prefix .. key .. "_" .. i, chunk, false)\n    end\n    \n    return true\nend\n\n-- Load large data from chunks\nfunction ChunkedStorage:Load(key, callback)\n    -- Load metadata first\n    TheSim:GetPersistentString(self.prefix .. key .. "_meta", function(success, meta_str)\n        if success and meta_str and #meta_str > 0 then\n            local success, meta = pcall(function() return json.decode(meta_str) end)\n            \n            if success and meta and meta.num_chunks then\n                local chunks = {}\n                local chunks_loaded = 0\n                \n                -- Function to check if all chunks are loaded\n                local function CheckAllChunksLoaded()\n                    if chunks_loaded == meta.num_chunks then\n                        -- Combine all chunks\n                        local full_data_str = table.concat(chunks)\n                        \n                        -- Decode the data\n                        local success, data = pcall(function() return json.decode(full_data_str) end)\n                        \n                        if success and data then\n                            callback(true, data)\n                        else\n                            callback(false)\n                        end\n                    end\n                end\n                \n                -- Load each chunk\n                for i = 1, meta.num_chunks do\n                    TheSim:GetPersistentString(self.prefix .. key .. "_" .. i, function(success, chunk)\n                        if success and chunk then\n                            chunks[i] = chunk\n                            chunks_loaded = chunks_loaded + 1\n                            CheckAllChunksLoaded()\n                        else\n                            callback(false)\n                        end\n                    end)\n                end\n            else\n                callback(false)\n            end\n        else\n            callback(false)\n        end\n    end)\nend\n\n-- Delete saved data\nfunction ChunkedStorage:Delete(key)\n    -- Load metadata to know how many chunks to delete\n    TheSim:GetPersistentString(self.prefix .. key .. "_meta", function(success, meta_str)\n        if success and meta_str and #meta_str > 0 then\n            local success, meta = pcall(function() return json.decode(meta_str) end)\n            \n            if success and meta and meta.num_chunks then\n                -- Delete each chunk\n                for i = 1, meta.num_chunks do\n                    TheSim:ErasePersistentString(self.prefix .. key .. "_" .. i)\n                end\n            end\n            \n            -- Delete metadata\n            TheSim:ErasePersistentString(self.prefix .. key .. "_meta")\n        end\n    end)\nend\n\n-- Usage\n-- local large_data = {/* ... large data structure ... */}\n-- ChunkedStorage:Save("world_map", large_data)\n-- \n-- ChunkedStorage:Load("world_map", function(success, data)\n--     if success then\n--         print("Loaded large data structure!")\n--     else\n--         print("Failed to load data")\n--     end\n-- end)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"versioned-data-saving",children:"Versioned Data Saving"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'-- Versioned data saving system\nlocal VersionedStorage = {\n    current_version = 1, -- Increment when data format changes\n    prefix = "my_mod_versioned_"\n}\n\n-- Upgrade functions for each version\nVersionedStorage.upgraders = {\n    -- Upgrade from v1 to v2\n    [1] = function(data_v1)\n        -- Example: Convert old format to new format\n        local data_v2 = {\n            settings = data_v1.config or {},\n            player_stats = {},\n            version = 2\n        }\n        \n        -- Move player stats from old location to new\n        if data_v1.player_data then\n            for player_id, stats in pairs(data_v1.player_data) do\n                data_v2.player_stats[player_id] = {\n                    score = stats.score or 0,\n                    level = stats.level or 1\n                }\n            end\n        end\n        \n        return data_v2\n    end,\n    \n    -- Add more upgraders as needed for future versions\n}\n\n-- Save data with version\nfunction VersionedStorage:Save(key, data)\n    -- Ensure data has current version\n    data.version = self.current_version\n    \n    -- Convert to string and save\n    local data_str = json.encode(data)\n    TheSim:SetPersistentString(self.prefix .. key, data_str, false)\n    \n    return true\nend\n\n-- Load data and upgrade if needed\nfunction VersionedStorage:Load(key, callback)\n    TheSim:GetPersistentString(self.prefix .. key, function(success, data_str)\n        if success and data_str and #data_str > 0 then\n            local success, data = pcall(function() return json.decode(data_str) end)\n            \n            if success and data then\n                -- Check if data needs upgrading\n                local version = data.version or 1\n                \n                -- Apply upgraders sequentially\n                while version < self.current_version do\n                    if self.upgraders[version] then\n                        data = self.upgraders[version](data)\n                        version = data.version\n                    else\n                        -- Missing upgrader, can\'t proceed\n                        callback(false)\n                        return\n                    end\n                end\n                \n                callback(true, data)\n            else\n                callback(false)\n            end\n        else\n            callback(false)\n        end\n    end)\nend\n\n-- Usage\n-- local data = {\n--     config = {difficulty = "hard"},\n--     player_data = {\n--         ["KU_12345"] = {score = 100, level = 5}\n--     },\n--     version = 1\n-- }\n-- \n-- VersionedStorage:Save("game_state", data)\n-- \n-- VersionedStorage:Load("game_state", function(success, loaded_data)\n--     if success then\n--         -- Data will be automatically upgraded to current version\n--         print("Loaded data version: " .. loaded_data.version)\n--     end\n-- end)\n'})}),"\n",(0,i.jsx)(e.p,{children:"These snippets provide a foundation for various saving and loading scenarios in Don't Starve Together mods. Adapt them to your specific needs and combine them for more complex data persistence requirements."})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>d,x:()=>o});var t=a(6540);const i={},s=t.createContext(i);function d(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);