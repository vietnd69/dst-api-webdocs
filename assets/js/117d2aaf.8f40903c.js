"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[6950],{4737:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-vanilla/examples/network-optimization","title":"Optimizing Network Traffic","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/examples/network-optimization.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/network-optimization","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/network-optimization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"id":"network-optimization","title":"Optimizing Network Traffic","sidebar_position":12,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Reducing Resource Usage","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/resource-usage"},"next":{"title":"Profiling and Debugging Performance Issues","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/profiling-debugging"}}');var i=t(4848),a=t(8453);const o={id:"network-optimization",title:"Optimizing Network Traffic",sidebar_position:12,last_updated:new Date("2023-07-06T00:00:00.000Z")},r="Optimizing Network Traffic in Multiplayer",l={},c=[{value:"Understanding Network Constraints",id:"understanding-network-constraints",level:2},{value:"Network Architecture Overview",id:"network-architecture-overview",level:2},{value:"Key Network Optimization Techniques",id:"key-network-optimization-techniques",level:2},{value:"1. Prioritize Network Updates",id:"1-prioritize-network-updates",level:3},{value:"2. Delta Compression",id:"2-delta-compression",level:3},{value:"3. Relevance-Based Filtering",id:"3-relevance-based-filtering",level:3},{value:"4. Message Batching",id:"4-message-batching",level:3},{value:"5. Compression Techniques",id:"5-compression-techniques",level:3},{value:"6. Adaptive Sync Rates",id:"6-adaptive-sync-rates",level:3},{value:"7. Network Priority Levels",id:"7-network-priority-levels",level:3},{value:"Advanced Network Optimization Strategies",id:"advanced-network-optimization-strategies",level:2},{value:"1. Client-Side Prediction",id:"1-client-side-prediction",level:3},{value:"2. Level of Detail for Network Sync",id:"2-level-of-detail-for-network-sync",level:3},{value:"3. Event-Based Synchronization",id:"3-event-based-synchronization",level:3},{value:"4. Network Throttling",id:"4-network-throttling",level:3},{value:"Case Study: Optimizing a Boss Fight Mod",id:"case-study-optimizing-a-boss-fight-mod",level:2},{value:"Unoptimized Version",id:"unoptimized-version",level:3},{value:"Optimized Version",id:"optimized-version",level:3},{value:"Measuring and Monitoring Network Usage",id:"measuring-and-monitoring-network-usage",level:2},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"optimizing-network-traffic-in-multiplayer",children:"Optimizing Network Traffic in Multiplayer"})}),"\n",(0,i.jsx)(n.p,{children:"This guide focuses on strategies to optimize network traffic in Don't Starve Together mods, ensuring smooth multiplayer experiences even with many players or on connections with limited bandwidth."}),"\n",(0,i.jsx)(n.h2,{id:"understanding-network-constraints",children:"Understanding Network Constraints"}),"\n",(0,i.jsx)(n.p,{children:"When developing multiplayer mods for Don't Starve Together, network optimization is critical because:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bandwidth Limitations"}),": Players may have limited internet connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency Issues"}),": High network traffic increases perceived lag"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Server Performance"}),": Excessive network traffic impacts server performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Player Count Scaling"}),": Network usage multiplies with each additional player"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"network-architecture-overview",children:"Network Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"Don't Starve Together uses a client-server architecture where:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Server \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Client \u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 Client \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The server is authoritative (controls the game state)"}),"\n",(0,i.jsx)(n.li,{children:"Clients send inputs to the server"}),"\n",(0,i.jsx)(n.li,{children:"The server validates and processes inputs"}),"\n",(0,i.jsx)(n.li,{children:"The server sends state updates to clients"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-network-optimization-techniques",children:"Key Network Optimization Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"1-prioritize-network-updates",children:"1. Prioritize Network Updates"}),"\n",(0,i.jsx)(n.p,{children:"Not all data needs to be synchronized at the same frequency:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local SyncComponent = Class(function(self, inst)\n    self.inst = inst\n    self.last_sync = {\n        position = 0,\n        animation = 0,\n        status = 0\n    }\n    self.sync_frequency = {\n        position = 0.1,  -- Position updates frequently (every 0.1s)\n        animation = 0.5, -- Animation state less frequently (every 0.5s)\n        status = 1.0     -- Status updates infrequently (every 1.0s)\n    }\n    \n    self.inst:DoPeriodicTask(0.1, function() self:TrySyncData() end)\nend)\n\nfunction SyncComponent:TrySyncData()\n    local current_time = GetTime()\n    \n    -- Check if it's time to sync each data type\n    if current_time - self.last_sync.position >= self.sync_frequency.position then\n        self:SyncPosition()\n        self.last_sync.position = current_time\n    end\n    \n    if current_time - self.last_sync.animation >= self.sync_frequency.animation then\n        self:SyncAnimation()\n        self.last_sync.animation = current_time\n    end\n    \n    if current_time - self.last_sync.status >= self.sync_frequency.status then\n        self:SyncStatus()\n        self.last_sync.status = current_time\n    end\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-delta-compression",children:"2. Delta Compression"}),"\n",(0,i.jsx)(n.p,{children:"Send only what has changed instead of complete state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local NetworkSync = Class(function(self, inst)\n    self.inst = inst\n    self.last_sent_state = {\n        position = {x=0, y=0, z=0},\n        health = 100,\n        inventory = {}\n    }\n    \n    self.inst:DoPeriodicTask(0.5, function() self:SyncState() end)\nend)\n\nfunction NetworkSync:SyncState()\n    local current_state = self:GetCurrentState()\n    local delta = self:CalculateDelta(self.last_sent_state, current_state)\n    \n    -- Only send if there are changes\n    if next(delta) ~= nil then\n        self:SendStateDelta(delta)\n        self.last_sent_state = current_state\n    end\nend\n\nfunction NetworkSync:CalculateDelta(old_state, new_state)\n    local delta = {}\n    \n    -- Check position change (only if significant)\n    if math.abs(old_state.position.x - new_state.position.x) > 0.1 or\n       math.abs(old_state.position.z - new_state.position.z) > 0.1 then\n        delta.position = new_state.position\n    end\n    \n    -- Check health change\n    if old_state.health ~= new_state.health then\n        delta.health = new_state.health\n    end\n    \n    -- Check inventory changes\n    for item, count in pairs(new_state.inventory) do\n        if old_state.inventory[item] ~= count then\n            delta.inventory = delta.inventory or {}\n            delta.inventory[item] = count\n        end\n    end\n    \n    return delta\nend\n\nfunction NetworkSync:SendStateDelta(delta)\n    -- Convert delta to a compact format\n    local compressed_data = json.encode(delta)\n    \n    -- Send to clients\n    if TheWorld.ismastersim then\n        SendModRPCToClients(GetClientModRPC("MyMod", "SyncDelta"), compressed_data)\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-relevance-based-filtering",children:"3. Relevance-Based Filtering"}),"\n",(0,i.jsx)(n.p,{children:"Only send updates to players who need them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function SyncEntityToRelevantPlayers(entity, data)\n    if not TheWorld.ismastersim then return end\n    \n    local x, y, z = entity.Transform:GetWorldPosition()\n    local relevant_radius = 30 -- Only players within 30 units need updates\n    \n    for _, player in ipairs(AllPlayers) do\n        local px, py, pz = player.Transform:GetWorldPosition()\n        local dist_sq = (x - px)^2 + (z - pz)^2\n        \n        if dist_sq <= relevant_radius * relevant_radius then\n            -- This player is close enough to need updates\n            SendModRPCToClient(GetClientModRPC("MyMod", "EntityUpdate"), \n                              player.userid, entity.GUID, json.encode(data))\n        end\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-message-batching",children:"4. Message Batching"}),"\n",(0,i.jsx)(n.p,{children:"Group multiple updates into a single network message:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local NetworkBatcher = Class(function(self, inst)\n    self.inst = inst\n    self.pending_updates = {}\n    self.last_send_time = 0\n    self.send_interval = 0.5 -- Send batch every 0.5 seconds\n    \n    self.inst:DoPeriodicTask(0.1, function() self:TrySendBatch() end)\nend)\n\nfunction NetworkBatcher:QueueUpdate(entity_id, data)\n    self.pending_updates[entity_id] = self.pending_updates[entity_id] or {}\n    \n    -- Merge the new data with any existing queued data\n    for k, v in pairs(data) do\n        self.pending_updates[entity_id][k] = v\n    end\nend\n\nfunction NetworkBatcher:TrySendBatch()\n    local current_time = GetTime()\n    \n    -- Send batch if it\'s time or if we have too many updates\n    if current_time - self.last_send_time >= self.send_interval or \n       table.count(self.pending_updates) > 10 then\n        if next(self.pending_updates) ~= nil then\n            self:SendBatch(self.pending_updates)\n            self.pending_updates = {}\n            self.last_send_time = current_time\n        end\n    end\nend\n\nfunction NetworkBatcher:SendBatch(batch)\n    -- Convert batch to a compact format\n    local compressed_batch = json.encode(batch)\n    \n    -- Send to all clients\n    if TheWorld.ismastersim then\n        SendModRPCToClients(GetClientModRPC("MyMod", "BatchUpdate"), compressed_batch)\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-compression-techniques",children:"5. Compression Techniques"}),"\n",(0,i.jsx)(n.p,{children:"Reduce the size of transmitted data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Quantize floating point values to reduce precision\nfunction QuantizePosition(x, y, z)\n    -- Round to nearest 0.1 units\n    return {\n        x = math.floor(x * 10 + 0.5) / 10,\n        y = math.floor(y * 10 + 0.5) / 10,\n        z = math.floor(z * 10 + 0.5) / 10\n    }\nend\n\n-- Use integer indices instead of string keys\nlocal KEY_MAPPING = {\n    position = 1,\n    rotation = 2,\n    health = 3,\n    hunger = 4,\n    sanity = 5\n}\n\nfunction CompressData(data)\n    local compressed = {}\n    \n    for key, value in pairs(data) do\n        local index = KEY_MAPPING[key]\n        if index then\n            compressed[index] = value\n        end\n    end\n    \n    return compressed\nend\n\nfunction DecompressData(compressed)\n    local data = {}\n    \n    for index, value in pairs(compressed) do\n        for key, map_index in pairs(KEY_MAPPING) do\n            if map_index == index then\n                data[key] = value\n                break\n            end\n        end\n    end\n    \n    return data\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"6-adaptive-sync-rates",children:"6. Adaptive Sync Rates"}),"\n",(0,i.jsx)(n.p,{children:"Adjust synchronization frequency based on conditions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local AdaptiveSync = Class(function(self, inst)\n    self.inst = inst\n    self.base_sync_interval = 0.5\n    self.current_sync_interval = 0.5\n    self.last_sync_time = 0\n    self.importance = 1.0 -- 0.0 to 1.0\n    \n    self.inst:DoPeriodicTask(0.1, function() self:Update() end)\nend)\n\nfunction AdaptiveSync:Update()\n    local current_time = GetTime()\n    \n    -- Adjust sync rate based on factors\n    self:AdjustSyncRate()\n    \n    -- Check if it's time to sync\n    if current_time - self.last_sync_time >= self.current_sync_interval then\n        self:SyncData()\n        self.last_sync_time = current_time\n    end\nend\n\nfunction AdaptiveSync:AdjustSyncRate()\n    -- Base factors that affect sync rate\n    local distance_factor = self:GetPlayerDistanceFactor()\n    local activity_factor = self:GetActivityFactor()\n    local performance_factor = self:GetPerformanceFactor()\n    \n    -- Calculate new sync interval\n    local adjusted_importance = self.importance * distance_factor * activity_factor\n    \n    -- Clamp between 0.1 and 2.0 seconds\n    self.current_sync_interval = math.clamp(\n        self.base_sync_interval / adjusted_importance * performance_factor,\n        0.1,\n        2.0\n    )\nend\n\nfunction AdaptiveSync:GetPlayerDistanceFactor()\n    -- Return 1.0 if players are nearby, decreasing to 0.2 as they get farther away\n    local closest_dist_sq = self:GetClosestPlayerDistanceSq()\n    local max_dist_sq = 30 * 30\n    \n    if closest_dist_sq > max_dist_sq then\n        return 0.2 -- Far away, sync less frequently\n    else\n        -- Linear falloff from 1.0 to 0.2\n        return 1.0 - (0.8 * closest_dist_sq / max_dist_sq)\n    end\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"7-network-priority-levels",children:"7. Network Priority Levels"}),"\n",(0,i.jsx)(n.p,{children:"Assign priority levels to different types of network traffic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Network priority constants\nlocal NETWORK_PRIORITY = {\n    CRITICAL = 0,  -- Must be delivered immediately (player death, etc.)\n    HIGH = 1,      -- Important for gameplay (combat, interaction)\n    MEDIUM = 2,    -- Standard priority (movement, animations)\n    LOW = 3        -- Can be delayed if needed (cosmetic effects)\n}\n\n-- Set entity network priority\nfunction SetEntityNetworkPriority(entity, priority)\n    entity.entity:SetPriority(priority)\nend\n\n-- Example usage\nfunction OnCombatStart(inst)\n    -- Increase network priority during combat\n    SetEntityNetworkPriority(inst, NETWORK_PRIORITY.HIGH)\n    \n    -- Reset after combat ends\n    inst:DoTaskInTime(5, function()\n        SetEntityNetworkPriority(inst, NETWORK_PRIORITY.MEDIUM)\n    end)\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-network-optimization-strategies",children:"Advanced Network Optimization Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"1-client-side-prediction",children:"1. Client-Side Prediction"}),"\n",(0,i.jsx)(n.p,{children:"Reduce perceived latency by predicting outcomes on the client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Client-side movement prediction\nlocal function PredictMovement(inst, direction, speed, dt)\n    if not TheWorld.ismastersim then\n        -- Client-side prediction\n        local x, y, z = inst.Transform:GetWorldPosition()\n        local predicted_x = x + direction.x * speed * dt\n        local predicted_z = z + direction.z * speed * dt\n        \n        -- Apply predicted position\n        inst.Transform:SetPosition(predicted_x, y, predicted_z)\n        \n        -- Remember we're using prediction\n        inst.using_prediction = true\n    end\nend\n\n-- Handle server correction\nlocal function OnPositionCorrection(inst, correct_x, correct_y, correct_z)\n    if inst.using_prediction then\n        local current_x, current_y, current_z = inst.Transform:GetWorldPosition()\n        local distance_sq = (current_x - correct_x)^2 + (current_z - correct_z)^2\n        \n        if distance_sq > 4 then\n            -- Large correction needed, snap to correct position\n            inst.Transform:SetPosition(correct_x, correct_y, correct_z)\n        else\n            -- Small correction, smoothly interpolate\n            inst:DoTaskInTime(0.1, function()\n                inst.Transform:SetPosition(correct_x, correct_y, correct_z)\n            end)\n        end\n    end\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-level-of-detail-for-network-sync",children:"2. Level of Detail for Network Sync"}),"\n",(0,i.jsx)(n.p,{children:"Adjust detail level based on distance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function SyncEntityWithLOD(entity, player)\n    local x, y, z = entity.Transform:GetWorldPosition()\n    local px, py, pz = player.Transform:GetWorldPosition()\n    local dist_sq = (x - px)^2 + (z - pz)^2\n    \n    local data = {}\n    \n    if dist_sq < 10*10 then\n        -- Close range: high detail\n        data = {\n            position = {x=x, y=y, z=z},\n            rotation = entity.Transform:GetRotation(),\n            animation = entity.AnimState:GetCurrentAnimationName(),\n            health = entity.components.health:GetPercent(),\n            effects = GetEntityEffects(entity),\n            items = GetEntityItems(entity)\n        }\n    elseif dist_sq < 30*30 then\n        -- Medium range: medium detail\n        data = {\n            position = {x=x, y=y, z=z},\n            rotation = entity.Transform:GetRotation(),\n            animation = entity.AnimState:GetCurrentAnimationName(),\n            health = entity.components.health:GetPercent()\n        }\n    else\n        -- Far range: minimal detail\n        data = {\n            position = {x=x, y=y, z=z},\n            health = entity.components.health:GetPercent() < 0.5 -- Just send a boolean flag for low health\n        }\n    end\n    \n    SendModRPCToClient(GetClientModRPC("MyMod", "EntityUpdate"), \n                      player.userid, entity.GUID, json.encode(data))\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-event-based-synchronization",children:"3. Event-Based Synchronization"}),"\n",(0,i.jsx)(n.p,{children:"Only sync when important events occur:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Instead of periodic updates, sync on important events\nfunction SetupEventBasedSync(entity)\n    if not TheWorld.ismastersim then return end\n    \n    -- Sync when health changes significantly\n    entity:ListenForEvent("healthdelta", function(inst, data)\n        if math.abs(data.delta) > 5 or -- Large change\n           inst.components.health:GetPercent() < 0.25 then -- Low health\n            SyncHealthToClients(inst)\n        end\n    end)\n    \n    -- Sync when animation changes\n    local old_play_anim = entity.AnimState.PlayAnimation\n    entity.AnimState.PlayAnimation = function(anim_state, anim_name, ...)\n        old_play_anim(anim_state, anim_name, ...)\n        SyncAnimationToClients(entity, anim_name)\n    end\n    \n    -- Sync when inventory changes\n    entity:ListenForEvent("itemget", function(inst, data)\n        SyncInventoryToClients(inst)\n    end)\n    \n    entity:ListenForEvent("itemlose", function(inst, data)\n        SyncInventoryToClients(inst)\n    end)\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-network-throttling",children:"4. Network Throttling"}),"\n",(0,i.jsx)(n.p,{children:"Prevent network spam during intense activity:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local NetworkThrottler = Class(function(self, inst)\n    self.inst = inst\n    self.message_counts = {}\n    self.last_reset = GetTime()\n    self.reset_interval = 1.0 -- Reset counters every second\n    self.max_messages = {\n        position = 10,  -- Max 10 position updates per second\n        animation = 5,  -- Max 5 animation updates per second\n        effect = 3      -- Max 3 effect updates per second\n    }\n    \n    self.inst:DoPeriodicTask(0.1, function() self:Update() end)\nend)\n\nfunction NetworkThrottler:Update()\n    local current_time = GetTime()\n    \n    -- Reset counters periodically\n    if current_time - self.last_reset >= self.reset_interval then\n        self.message_counts = {}\n        self.last_reset = current_time\n    end\nend\n\nfunction NetworkThrottler:CanSendMessage(message_type)\n    -- Initialize counter if needed\n    self.message_counts[message_type] = self.message_counts[message_type] or 0\n    \n    -- Check if we\'ve hit the limit\n    if self.message_counts[message_type] >= self.max_messages[message_type] then\n        return false\n    end\n    \n    -- Increment counter and allow message\n    self.message_counts[message_type] = self.message_counts[message_type] + 1\n    return true\nend\n\n-- Usage example\nfunction TrySendPositionUpdate(entity, position)\n    if entity.network_throttler:CanSendMessage("position") then\n        SendPositionUpdate(entity, position)\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"case-study-optimizing-a-boss-fight-mod",children:"Case Study: Optimizing a Boss Fight Mod"}),"\n",(0,i.jsx)(n.p,{children:"Let's look at a practical example of optimizing network traffic for a mod that adds a complex boss fight:"}),"\n",(0,i.jsx)(n.h3,{id:"unoptimized-version",children:"Unoptimized Version"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Unoptimized boss fight networking\nlocal function CreateBossFight()\n    local boss = SpawnPrefab("my_custom_boss")\n    \n    -- Update all clients constantly with full state\n    boss:DoPeriodicTask(0, function()\n        if TheWorld.ismastersim then\n            -- Send complete state every frame\n            local x, y, z = boss.Transform:GetWorldPosition()\n            local health = boss.components.health:GetPercent()\n            local phase = boss.current_phase\n            local targets = {}\n            \n            -- Include all target data\n            for i, target in ipairs(boss.targets) do\n                table.insert(targets, {\n                    id = target.GUID,\n                    x = target.Transform:GetWorldPosition()\n                })\n            end\n            \n            -- Send all special effects\n            for i, effect in ipairs(boss.active_effects) do\n                local ex, ey, ez = effect.Transform:GetWorldPosition()\n                SendModRPCToClients(GetClientModRPC("BossMod", "SpawnEffect"), \n                                   effect.prefab, ex, ey, ez)\n            end\n            \n            -- Send complete boss state\n            SendModRPCToClients(GetClientModRPC("BossMod", "UpdateBoss"), \n                               boss.GUID, x, y, z, health, phase, json.encode(targets))\n        end\n    end)\n    \n    return boss\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"optimized-version",children:"Optimized Version"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Optimized boss fight networking\nlocal function CreateBossFight()\n    local boss = SpawnPrefab("my_custom_boss")\n    \n    if TheWorld.ismastersim then\n        -- Initialize network optimization components\n        boss.network_sync = {\n            last_position = {x=0, y=0, z=0},\n            last_health = 1.0,\n            last_phase = 1,\n            last_sync_time = {\n                position = 0,\n                health = 0,\n                phase = 0,\n                targets = 0,\n                effects = 0\n            },\n            sync_intervals = {\n                position = 0.1,  -- Sync position 10 times per second\n                health = 0.5,    -- Sync health twice per second\n                phase = 0,       -- Sync phase immediately when changed\n                targets = 1.0,   -- Sync targets once per second\n                effects = 0      -- Sync effects immediately when they occur\n            },\n            dirty = {\n                position = true,\n                health = true,\n                phase = true,\n                targets = true\n            }\n        }\n        \n        -- Periodic sync task\n        boss:DoPeriodicTask(0.1, function() BossSyncTask(boss) end)\n        \n        -- Event-based synchronization\n        boss:ListenForEvent("healthdelta", function(inst, data)\n            -- Mark health as dirty if it changed significantly\n            if math.abs(data.delta) > 0.05 then\n                inst.network_sync.dirty.health = true\n            end\n        end)\n        \n        -- Phase change events\n        boss.SetPhase = function(self, phase)\n            if self.current_phase ~= phase then\n                self.current_phase = phase\n                self.network_sync.dirty.phase = true\n                \n                -- Phase changes are important - sync immediately\n                SyncBossPhase(self)\n            end\n        end\n        \n        -- Effect spawning\n        boss.SpawnEffect = function(self, effect_name, x, y, z)\n            -- Spawn locally\n            local effect = SpawnPrefab(effect_name)\n            effect.Transform:SetPosition(x, y, z)\n            \n            -- Send to clients immediately - effects are important for visual feedback\n            SendModRPCToClients(GetClientModRPC("BossMod", "SpawnEffect"), \n                               effect_name, x, y, z)\n            \n            return effect\n        end\n    end\n    \n    return boss\nend\n\nfunction BossSyncTask(boss)\n    if not TheWorld.ismastersim then return end\n    \n    local current_time = GetTime()\n    local sync = boss.network_sync\n    \n    -- Check position updates\n    if sync.dirty.position and \n       current_time - sync.last_sync_time.position >= sync.sync_intervals.position then\n        SyncBossPosition(boss)\n        sync.last_sync_time.position = current_time\n        sync.dirty.position = false\n    end\n    \n    -- Check health updates\n    if sync.dirty.health and \n       current_time - sync.last_sync_time.health >= sync.sync_intervals.health then\n        SyncBossHealth(boss)\n        sync.last_sync_time.health = current_time\n        sync.dirty.health = false\n    end\n    \n    -- Check target updates\n    if sync.dirty.targets and \n       current_time - sync.last_sync_time.targets >= sync.sync_intervals.targets then\n        SyncBossTargets(boss)\n        sync.last_sync_time.targets = current_time\n        sync.dirty.targets = false\n    end\n    \n    -- Position is always considered dirty for continuous movement\n    sync.dirty.position = true\nend\n\nfunction SyncBossPosition(boss)\n    local x, y, z = boss.Transform:GetWorldPosition()\n    local last = boss.network_sync.last_position\n    \n    -- Only sync if position changed significantly\n    if math.abs(x - last.x) > 0.1 or math.abs(z - last.z) > 0.1 then\n        SendModRPCToClients(GetClientModRPC("BossMod", "UpdateBossPosition"), \n                           boss.GUID, x, y, z)\n        \n        boss.network_sync.last_position = {x=x, y=y, z=z}\n    end\nend\n\nfunction SyncBossHealth(boss)\n    local health = boss.components.health:GetPercent()\n    \n    -- Only sync if health changed significantly\n    if math.abs(health - boss.network_sync.last_health) > 0.01 then\n        SendModRPCToClients(GetClientModRPC("BossMod", "UpdateBossHealth"), \n                           boss.GUID, health)\n        \n        boss.network_sync.last_health = health\n    end\nend\n\nfunction SyncBossPhase(boss)\n    SendModRPCToClients(GetClientModRPC("BossMod", "UpdateBossPhase"), \n                       boss.GUID, boss.current_phase)\n    \n    boss.network_sync.last_phase = boss.current_phase\n}\n\nfunction SyncBossTargets(boss)\n    -- Only send minimal target information\n    local target_data = {}\n    for i, target in ipairs(boss.targets) do\n        table.insert(target_data, target.GUID)\n    end\n    \n    SendModRPCToClients(GetClientModRPC("BossMod", "UpdateBossTargets"), \n                       boss.GUID, json.encode(target_data))\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"measuring-and-monitoring-network-usage",children:"Measuring and Monitoring Network Usage"}),"\n",(0,i.jsx)(n.p,{children:"To optimize effectively, you need to measure network usage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Track RPC frequency\nlocal rpc_counters = {}\n\n-- Wrap RPC sending functions to count usage\nlocal original_send_rpc = SendModRPCToClients\nSendModRPCToClients = function(rpc, ...)\n    -- Count RPC usage\n    local rpc_name = GetRPCNameFromID(rpc)\n    rpc_counters[rpc_name] = (rpc_counters[rpc_name] or 0) + 1\n    \n    -- Call original function\n    return original_send_rpc(rpc, ...)\nend\n\n-- Periodically log RPC usage\nTheWorld:DoPeriodicTask(10, function()\n    print("RPC Usage Statistics:")\n    for name, count in pairs(rpc_counters) do\n        print(string.format("  %s: %d calls (%.1f/sec)", \n                           name, count, count/10))\n    end\n    rpc_counters = {}\nend)\n\n-- Console command to show network stats\nfunction c_networkstats()\n    print("Network Statistics:")\n    print("Bandwidth In: " .. TheSim:GetBandwidthIn() .. " KB/s")\n    print("Bandwidth Out: " .. TheSim:GetBandwidthOut() .. " KB/s")\n    print("Packet Loss: " .. TheSim:GetPacketLoss() .. "%")\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,i.jsx)(n.p,{children:"Use this checklist to ensure your mod's network usage is optimized:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Sync Frequency"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use appropriate sync intervals for different data types"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Prioritize critical gameplay data over cosmetic effects"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement event-based synchronization where possible"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Data Efficiency"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Send only changed data (delta updates)"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Compress data before sending (reduce precision, use integer keys)"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Batch related updates together"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Relevance Filtering"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Only send updates to players who need them"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement distance-based level of detail"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Filter out irrelevant information"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Network Load Management"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement rate limiting for frequent updates"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use network priority levels appropriately"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Scale back network usage during high-activity periods"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Client-Side Techniques"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement client-side prediction where appropriate"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use interpolation for smooth transitions"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cache data to reduce redundant requests"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"By implementing these network optimization techniques, your mods will use bandwidth more efficiently and provide a smoother multiplayer experience, especially on servers with many players or for players with limited internet connections."}),"\n",(0,i.jsx)(n.p,{children:"Remember these key principles:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only send what has changed"}),"\n",(0,i.jsx)(n.li,{children:"Only send to who needs it"}),"\n",(0,i.jsx)(n.li,{children:"Only send when it matters"}),"\n",(0,i.jsx)(n.li,{children:"Prioritize gameplay-critical information"}),"\n",(0,i.jsx)(n.li,{children:"Measure and monitor network usage"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," - Core networking concepts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/rpc-system",children:"RPC System"})," - Remote procedure call system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/optimization",children:"Performance Optimization"})," - General performance optimization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/resource-usage",children:"Reducing Resource Usage"})," - Strategies for minimizing resource consumption"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);