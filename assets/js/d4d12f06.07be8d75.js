"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[3500],{836:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api-vanilla/core/handling-latency-network-drops","title":"Handling Latency and Network Drops","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/core/handling-latency-network-drops.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/handling-latency-network-drops","permalink":"/dst-api-webdocs/docs/api-vanilla/core/handling-latency-network-drops","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"id":"handling-latency-network-drops","title":"Handling Latency and Network Drops","sidebar_position":9,"last_updated":"2023-07-06T00:00:00.000Z"}}');var s=t(4848),o=t(8453);const r={id:"handling-latency-network-drops",title:"Handling Latency and Network Drops",sidebar_position:9,last_updated:new Date("2023-07-06T00:00:00.000Z")},a="Handling Latency and Network Drops",l={},c=[{value:"Understanding Network Challenges in DST",id:"understanding-network-challenges-in-dst",level:2},{value:"Detecting Network Issues",id:"detecting-network-issues",level:2},{value:"Monitoring Connection Quality",id:"monitoring-connection-quality",level:3},{value:"Detecting Disconnections",id:"detecting-disconnections",level:3},{value:"Strategies for Handling Latency",id:"strategies-for-handling-latency",level:2},{value:"Client-Side Prediction",id:"client-side-prediction",level:3},{value:"Input Buffering",id:"input-buffering",level:3},{value:"Action Queueing",id:"action-queueing",level:3},{value:"Handling Network Drops",id:"handling-network-drops",level:2},{value:"State Saving and Recovery",id:"state-saving-and-recovery",level:3},{value:"Graceful Degradation",id:"graceful-degradation",level:3},{value:"Reconnection Handling",id:"reconnection-handling",level:3},{value:"Testing Network Conditions",id:"testing-network-conditions",level:2},{value:"Simulating Network Issues",id:"simulating-network-issues",level:3},{value:"Testing Different Network Scenarios",id:"testing-different-network-scenarios",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"handling-latency-and-network-drops",children:"Handling Latency and Network Drops"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"API Version: 619045"})}),"\n",(0,s.jsx)(n.p,{children:"In multiplayer games like Don't Starve Together, network latency and disconnections are inevitable challenges that modders must address. This guide covers techniques for creating mods that gracefully handle network issues while maintaining a smooth player experience."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-network-challenges-in-dst",children:"Understanding Network Challenges in DST"}),"\n",(0,s.jsx)(n.p,{children:"Don't Starve Together uses a client-server architecture where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"server"}),' is authoritative and maintains the "true" game state']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clients"})," receive updates from the server and predict some behaviors"]}),"\n",(0,s.jsx)(n.li,{children:"Network issues can disrupt this communication flow"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Common network problems include:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latency"}),": Delay between client actions and server responses"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Packet Loss"}),": Some network messages never arrive"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Disconnections"}),": Temporary or prolonged loss of connection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Desynchronization"}),": Client and server states diverge"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"detecting-network-issues",children:"Detecting Network Issues"}),"\n",(0,s.jsx)(n.h3,{id:"monitoring-connection-quality",children:"Monitoring Connection Quality"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In your mod\'s main file\nlocal function MonitorNetworkStatus()\n    -- Check if we\'re in a networked game\n    if not TheNet:GetIsClient() and not TheNet:GetIsServer() then\n        return\n    end\n    \n    -- Get current ping\n    local ping = TheNet:GetAveragePing()\n    \n    -- Classify connection quality\n    local connection_quality = "good"\n    if ping > 300 then\n        connection_quality = "poor"\n    elseif ping > 150 then\n        connection_quality = "fair"\n    end\n    \n    -- Log or react to connection quality\n    print("Current connection quality:", connection_quality, "Ping:", ping)\n    \n    -- Adjust mod behavior based on connection quality\n    if connection_quality == "poor" then\n        -- Reduce visual effects, batch updates, etc.\n    end\nend\n\n-- Run this check periodically\ninst:DoPeriodicTask(5, MonitorNetworkStatus)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"detecting-disconnections",children:"Detecting Disconnections"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Listen for disconnection events\nTheWorld:ListenForEvent("ms_playerdisconnected", function(world, player)\n    print("Player disconnected:", player.name)\n    -- Handle player disconnection\nend)\n\n-- Listen for reconnection events\nTheWorld:ListenForEvent("ms_playerreconnected", function(world, player)\n    print("Player reconnected:", player.name)\n    -- Handle player reconnection\nend)\n\n-- Listen for server pauses (often indicates network issues)\nTheWorld:ListenForEvent("ms_serverpauseddirty", function(world)\n    local is_paused = TheNet:GetServerPaused()\n    print("Server paused state changed:", is_paused)\nend)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"strategies-for-handling-latency",children:"Strategies for Handling Latency"}),"\n",(0,s.jsx)(n.h3,{id:"client-side-prediction",children:"Client-Side Prediction"}),"\n",(0,s.jsx)(n.p,{children:"Client-side prediction allows players to see immediate responses to their actions while waiting for server confirmation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Example of client-side prediction for movement\nlocal PlayerController = Class(function(self, inst)\n    self.inst = inst\n    self.predicted_position = Vector3(0, 0, 0)\n    self.last_server_position = Vector3(0, 0, 0)\n    self.last_input_time = 0\n    self.pending_moves = {}\nend)\n\nfunction PlayerController:Move(direction, delta_time)\n    -- Record this move\n    local move = {\n        direction = direction,\n        delta_time = delta_time,\n        timestamp = GetTime()\n    }\n    table.insert(self.pending_moves, move)\n    \n    -- Apply prediction locally\n    if not TheWorld.ismastersim then\n        -- Update predicted position\n        local speed = 4 -- units per second\n        local dx = direction.x * speed * delta_time\n        local dz = direction.z * speed * delta_time\n        \n        self.predicted_position.x = self.predicted_position.x + dx\n        self.predicted_position.z = self.predicted_position.z + dz\n        \n        -- Apply predicted position\n        self.inst.Transform:SetPosition(self.predicted_position:Get())\n    end\n    \n    -- Send move to server\n    SendModRPCToServer(MOD_RPC.MyMod.PlayerMove, direction.x, direction.z, delta_time)\nend\n\n-- When server position update arrives\nfunction PlayerController:OnServerPositionUpdate(x, y, z)\n    self.last_server_position = Vector3(x, y, z)\n    \n    -- Calculate error between prediction and reality\n    local error_distance = self.predicted_position:Dist(self.last_server_position)\n    \n    -- If error is significant, correct position\n    if error_distance > 2 then\n        -- Immediate correction (teleport)\n        self.predicted_position = Vector3(x, y, z)\n        self.inst.Transform:SetPosition(x, y, z)\n        \n        -- Clear pending moves that have been resolved\n        self:ClearPendingMoves()\n    else if error_distance > 0.5 then\n        -- Smooth correction (interpolate)\n        self:SmoothCorrection()\n    end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"input-buffering",children:"Input Buffering"}),"\n",(0,s.jsx)(n.p,{children:"Input buffering helps maintain responsiveness during latency spikes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local InputBuffer = Class(function(self, inst)\n    self.inst = inst\n    self.buffer = {}\n    self.buffer_size = 10 -- Maximum buffered inputs\n    self.processing = false\nend)\n\nfunction InputBuffer:AddInput(input_type, data)\n    if #self.buffer >= self.buffer_size then\n        -- Buffer full, remove oldest input\n        table.remove(self.buffer, 1)\n    end\n    \n    -- Add new input to buffer\n    table.insert(self.buffer, {\n        type = input_type,\n        data = data,\n        timestamp = GetTime()\n    })\n    \n    -- Try to process buffer\n    self:ProcessBuffer()\nend\n\nfunction InputBuffer:ProcessBuffer()\n    if self.processing then return end\n    \n    self.processing = true\n    \n    while #self.buffer > 0 do\n        local input = table.remove(self.buffer, 1)\n        \n        -- Check if input is still valid (not too old)\n        if GetTime() - input.timestamp < 1.0 then\n            -- Process the input\n            if input.type == "attack" then\n                self:ProcessAttack(input.data)\n            elseif input.type == "use_item" then\n                self:ProcessItemUse(input.data)\n            end\n        end\n    end\n    \n    self.processing = false\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"action-queueing",children:"Action Queueing"}),"\n",(0,s.jsx)(n.p,{children:"Action queueing ensures that player commands are executed in sequence, even with network delays:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local ActionQueue = Class(function(self, inst)\n    self.inst = inst\n    self.queue = {}\n    self.executing = false\nend)\n\nfunction ActionQueue:PushAction(action, target)\n    -- Add action to queue\n    table.insert(self.queue, {\n        action = action,\n        target = target,\n        timestamp = GetTime()\n    })\n    \n    -- Try to execute next action\n    self:TryExecuteNext()\nend\n\nfunction ActionQueue:TryExecuteNext()\n    if self.executing or #self.queue == 0 then\n        return\n    end\n    \n    self.executing = true\n    local action_data = table.remove(self.queue, 1)\n    \n    -- Execute the action\n    if action_data.action == "harvest" then\n        self:ExecuteHarvest(action_data.target, function()\n            -- Action completed callback\n            self.executing = false\n            self:TryExecuteNext() -- Try next action\n        end)\n    elseif action_data.action == "attack" then\n        self:ExecuteAttack(action_data.target, function()\n            -- Action completed callback\n            self.executing = false\n            self:TryExecuteNext() -- Try next action\n        end)\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"handling-network-drops",children:"Handling Network Drops"}),"\n",(0,s.jsx)(n.h3,{id:"state-saving-and-recovery",children:"State Saving and Recovery"}),"\n",(0,s.jsx)(n.p,{children:"Implement state saving to recover from disconnections:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Save important state periodically\nlocal function SaveModState(inst)\n    if not TheWorld.ismastersim then return end\n    \n    local state = {\n        version = MOD_VERSION,\n        timestamp = GetTime(),\n        player_states = {},\n        world_state = {\n            day = TheWorld.state.cycles,\n            season = TheWorld.state.season\n        }\n    }\n    \n    -- Save state for each player\n    for i, player in ipairs(AllPlayers) do\n        if player.userid then\n            state.player_states[player.userid] = {\n                position = { player.Transform:GetWorldPosition() },\n                health = player.components.health.currenthealth,\n                inventory_items = GetPlayerInventoryItems(player)\n            }\n        end\n    end\n    \n    -- Save to mod storage\n    SaveModData(state)\nend\n\n-- Set up periodic saving\nTheWorld:DoPeriodicTask(60, SaveModState) -- Save every minute\n\n-- Try to restore state on reconnection\nlocal function TryRestoreState(player)\n    if not player.userid then return false end\n    \n    local state = LoadModData()\n    if not state or not state.player_states or not state.player_states[player.userid] then\n        return false\n    end\n    \n    local player_state = state.player_states[player.userid]\n    \n    -- Check if state is still valid (not too old)\n    if GetTime() - state.timestamp > MAX_STATE_AGE then\n        return false\n    end\n    \n    -- Restore player state\n    if player_state.position then\n        player.Transform:SetPosition(unpack(player_state.position))\n    end\n    \n    if player_state.health and player.components.health then\n        player.components.health:SetVal(player_state.health)\n    end\n    \n    -- Restore inventory if needed\n    if player_state.inventory_items then\n        RestorePlayerInventory(player, player_state.inventory_items)\n    end\n    \n    return true\nend\n\n-- Listen for player spawns (including reconnections)\nTheWorld:ListenForEvent("ms_playerspawn", function(world, player)\n    TryRestoreState(player)\nend)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"graceful-degradation",children:"Graceful Degradation"}),"\n",(0,s.jsx)(n.p,{children:"Design your mod to function with reduced features during connection issues:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Check connection before performing network-intensive operations\nlocal function PerformComplexNetworkOperation()\n    local ping = TheNet:GetAveragePing()\n    \n    if ping > 300 then\n        -- Connection is poor, use simplified version\n        PerformSimplifiedOperation()\n    else\n        -- Connection is good, use full version\n        PerformFullOperation()\n    end\nend\n\n-- Example of degrading visual quality based on network performance\nlocal function UpdateVisualEffects()\n    local ping = TheNet:GetAveragePing()\n    \n    if ping > 300 then\n        -- Reduce particle effects\n        MAX_PARTICLES = 10\n        PARTICLE_DETAIL = "LOW"\n    elseif ping > 150 then\n        -- Medium quality\n        MAX_PARTICLES = 30\n        PARTICLE_DETAIL = "MEDIUM"\n    else\n        -- Full quality\n        MAX_PARTICLES = 50\n        PARTICLE_DETAIL = "HIGH"\n    end\n    \n    -- Apply settings\n    UpdateParticleSystem(MAX_PARTICLES, PARTICLE_DETAIL)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"reconnection-handling",children:"Reconnection Handling"}),"\n",(0,s.jsx)(n.p,{children:"Implement proper reconnection logic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Track connection state\nlocal was_connected = false\nlocal pending_actions = {}\nlocal last_known_position = nil\n\nlocal function OnConnectionChanged()\n    local is_connected = TheNet:IsConnected()\n    \n    if is_connected and not was_connected then\n        -- Just reconnected\n        print("Reconnected to server")\n        \n        -- Resync critical data\n        SendModRPCToServer(MOD_RPC.MyMod.RequestFullSync)\n        \n        -- Replay any pending actions\n        for _, action in ipairs(pending_actions) do\n            SendModRPCToServer(MOD_RPC.MyMod.PerformAction, \n                action.type, action.target, action.data)\n        end\n        pending_actions = {}\n        \n    elseif not is_connected and was_connected then\n        -- Just disconnected\n        print("Disconnected from server")\n        \n        -- Save current position\n        if ThePlayer then\n            last_known_position = Vector3(ThePlayer.Transform:GetWorldPosition())\n        end\n    end\n    \n    was_connected = is_connected\nend\n\n-- Listen for connection changes\nTheNet:ListenForEvent("connectionchanged", OnConnectionChanged)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-network-conditions",children:"Testing Network Conditions"}),"\n",(0,s.jsx)(n.h3,{id:"simulating-network-issues",children:"Simulating Network Issues"}),"\n",(0,s.jsx)(n.p,{children:"For testing how your mod handles network problems:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Network condition simulator\nlocal NetworkSimulator = Class(function(self)\n    self.enabled = false\n    self.latency = 0\n    self.packet_loss = 0\n    self.original_send_fn = nil\nend)\n\nfunction NetworkSimulator:Enable()\n    if self.enabled then return end\n    \n    self.enabled = true\n    \n    -- Save original network send function\n    self.original_send_fn = SendModRPCToServer\n    \n    -- Override with our simulated version\n    _G.SendModRPCToServer = function(...)\n        local args = {...}\n        \n        -- Simulate packet loss\n        if math.random() < self.packet_loss then\n            print("NetworkSimulator: Dropped packet")\n            return\n        end\n        \n        -- Simulate latency\n        if self.latency > 0 then\n            local delay = self.latency * (0.8 + math.random() * 0.4) -- Add some variance\n            ThePlayer:DoTaskInTime(delay, function()\n                self.original_send_fn(unpack(args))\n            end)\n        else\n            self.original_send_fn(unpack(args))\n        end\n    end\nend\n\nfunction NetworkSimulator:Disable()\n    if not self.enabled then return end\n    \n    self.enabled = false\n    \n    -- Restore original function\n    if self.original_send_fn then\n        _G.SendModRPCToServer = self.original_send_fn\n        self.original_send_fn = nil\n    end\nend\n\nfunction NetworkSimulator:SetLatency(ms)\n    self.latency = ms / 1000 -- Convert to seconds\nend\n\nfunction NetworkSimulator:SetPacketLoss(percentage)\n    self.packet_loss = percentage / 100\nend\n\n-- Usage example (in development only!)\nlocal network_sim = NetworkSimulator()\nnetwork_sim:Enable()\nnetwork_sim:SetLatency(200) -- 200ms latency\nnetwork_sim:SetPacketLoss(5) -- 5% packet loss\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-different-network-scenarios",children:"Testing Different Network Scenarios"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Test scenarios for different network conditions\nlocal function TestNetworkScenarios()\n    local scenarios = {\n        {name = "Good Connection", latency = 50, packet_loss = 0},\n        {name = "Moderate Latency", latency = 150, packet_loss = 1},\n        {name = "High Latency", latency = 300, packet_loss = 2},\n        {name = "Very Poor Connection", latency = 500, packet_loss = 10}\n    }\n    \n    local current_scenario = 1\n    \n    -- Function to apply next scenario\n    local function ApplyNextScenario()\n        if current_scenario > #scenarios then\n            network_sim:Disable()\n            print("Network testing complete")\n            return\n        end\n        \n        local scenario = scenarios[current_scenario]\n        print("Testing scenario:", scenario.name)\n        network_sim:SetLatency(scenario.latency)\n        network_sim:SetPacketLoss(scenario.packet_loss)\n        \n        -- Move to next scenario after delay\n        ThePlayer:DoTaskInTime(30, function()\n            current_scenario = current_scenario + 1\n            ApplyNextScenario()\n        end)\n    end\n    \n    -- Start testing\n    network_sim:Enable()\n    ApplyNextScenario()\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always validate on the server"}),": Never trust client data that could be affected by network issues"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use prediction wisely"}),": Predict common actions but be ready to correct when server data arrives"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement timeouts"}),": Don't wait indefinitely for network responses"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Provide feedback"}),": Let players know when network issues are affecting gameplay"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch network messages"}),": Combine multiple small updates into larger, less frequent ones"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prioritize critical data"}),": Ensure important game state updates are sent reliably"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Design for disconnections"}),": Make sure your mod can handle players dropping and reconnecting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test with poor connections"}),": Regularly test your mod under various network conditions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/client-server-synchronization",children:"Client-Server Synchronization"})," - For synchronization techniques"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/rpc-system",children:"RPC System"})," - For communication between client and server"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," - For core networking concepts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/security-considerations-networking",children:"Security Considerations in Networking"})," - For network security best practices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-bandwidth-optimization",children:"Network Bandwidth Optimization"})," - For optimizing network usage"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);