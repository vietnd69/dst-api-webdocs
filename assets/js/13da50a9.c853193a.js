"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[2983],{8453:(n,t,e)=>{e.d(t,{R:()=>o,x:()=>r});var i=e(6540);const a={},s=i.createContext(a);function o(n){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function r(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(s.Provider,{value:t},n.children)}},9190:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"api-vanilla/stategraphs/animation-integration","title":"Animation Integration","description":"One of the most powerful aspects of the State Graph system in Don\'t Starve Together is its seamless integration with the animation system. This integration allows developers to create responsive, fluid entity behaviors where gameplay mechanics, visual effects, and sound all work together in perfect harmony.","source":"@site/docs/api-vanilla/stategraphs/animation-integration.md","sourceDirName":"api-vanilla/stategraphs","slug":"/api-vanilla/stategraphs/animation-integration","permalink":"/dst-api-webdocs/docs/api-vanilla/stategraphs/animation-integration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"animation-integration","title":"Animation Integration","sidebar_position":7,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Common States","permalink":"/dst-api-webdocs/docs/api-vanilla/stategraphs/commonstates"},"next":{"title":"Stategraph Examples","permalink":"/dst-api-webdocs/docs/api-vanilla/stategraphs/examples"}}');var a=e(4848),s=e(8453);const o={id:"animation-integration",title:"Animation Integration",sidebar_position:7,last_updated:new Date("2023-07-06T00:00:00.000Z")},r="State Graph Animation Integration",l={},m=[{value:"Understanding Animation States",id:"understanding-animation-states",level:2},{value:"Animation Playback Methods",id:"animation-playback-methods",level:2},{value:"Animation-Driven State Transitions",id:"animation-driven-state-transitions",level:2},{value:"Timeline Events and Animation Frames",id:"timeline-events-and-animation-frames",level:2},{value:"Multi-Stage Animations",id:"multi-stage-animations",level:2},{value:"Animation Blending for Smooth Transitions",id:"animation-blending-for-smooth-transitions",level:2},{value:"Handling Animation Banks and Builds",id:"handling-animation-banks-and-builds",level:2},{value:"Syncing Animations with Sound",id:"syncing-animations-with-sound",level:2},{value:"Working with Animation Events",id:"working-with-animation-events",level:2},{value:"Best Practices for Animation Integration",id:"best-practices-for-animation-integration",level:2},{value:"Animation Debugging Tips",id:"animation-debugging-tips",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(n){const t={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"state-graph-animation-integration",children:"State Graph Animation Integration"})}),"\n",(0,a.jsx)(t.p,{children:"One of the most powerful aspects of the State Graph system in Don't Starve Together is its seamless integration with the animation system. This integration allows developers to create responsive, fluid entity behaviors where gameplay mechanics, visual effects, and sound all work together in perfect harmony."}),"\n",(0,a.jsx)(t.h2,{id:"understanding-animation-states",children:"Understanding Animation States"}),"\n",(0,a.jsxs)(t.p,{children:["Animations in Don't Starve Together are managed through the ",(0,a.jsx)(t.code,{children:"AnimState"})," component. When combined with the State Graph system, each state typically corresponds to one or more animations that represent the visual aspect of that state."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'State{\n    name = "idle",\n    tags = {"idle", "canrotate"},\n    \n    onenter = function(inst)\n        -- Play an animation when entering this state\n        inst.AnimState:PlayAnimation("idle_loop", true)\n    end,\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"animation-playback-methods",children:"Animation Playback Methods"}),"\n",(0,a.jsx)(t.p,{children:"The AnimState component provides several methods for playing animations:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'-- Play a single animation (looping optional)\ninst.AnimState:PlayAnimation("walk", true)  -- true means loop\n\n-- Queue animations to play in sequence\ninst.AnimState:PlayAnimation("attack_pre")\ninst.AnimState:PushAnimation("attack_loop", true)  -- will play after attack_pre\ninst.AnimState:PushAnimation("attack_pst", false)  -- will play after attack_loop stops\n\n-- Blend between animations for smooth transitions\ninst.AnimState:SetTime(0.5)  -- Set time position in the current animation\n'})}),"\n",(0,a.jsx)(t.h2,{id:"animation-driven-state-transitions",children:"Animation-Driven State Transitions"}),"\n",(0,a.jsxs)(t.p,{children:["One of the most common patterns in stategraphs is to transition to a new state when an animation completes. This is achieved using the ",(0,a.jsx)(t.code,{children:"animover"})," and ",(0,a.jsx)(t.code,{children:"animqueueover"})," events:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'State{\n    name = "attack",\n    tags = {"attack", "busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("attack")\n    end,\n    \n    events = {\n        -- Transition to idle when the animation finishes\n        EventHandler("animover", function(inst)\n            inst.sg:GoToState("idle")\n        end),\n    },\n}\n\n-- For queued animations, use animqueueover\nState{\n    name = "elaborate_action",\n    tags = {"busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("action_pre")\n        inst.AnimState:PushAnimation("action_loop", false)\n        inst.AnimState:PushAnimation("action_pst", false)\n    end,\n    \n    events = {\n        -- This triggers when all queued animations finish\n        EventHandler("animqueueover", function(inst)\n            inst.sg:GoToState("idle")\n        end),\n    },\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"timeline-events-and-animation-frames",children:"Timeline Events and Animation Frames"}),"\n",(0,a.jsx)(t.p,{children:"The State Graph system provides a powerful way to synchronize code execution with specific animation frames using timeline events. This is crucial for making sure that gameplay mechanics, visual effects, and sounds happen at exactly the right moment in an animation."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'State{\n    name = "attack",\n    tags = {"attack", "busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("attack")\n    end,\n    \n    timeline = {\n        -- Wind-up sound at the start of the attack\n        TimeEvent(0*FRAMES, function(inst) \n            inst.SoundEmitter:PlaySound("dontstarve/creatures/spider/attack_growl")\n        end),\n        \n        -- Actual attack damage happens at a specific frame\n        TimeEvent(10*FRAMES, function(inst) \n            -- This is timed to match exactly when the attack animation shows impact\n            inst.components.combat:DoAttack()\n            -- Impact sound precisely when the attack lands\n            inst.SoundEmitter:PlaySound("dontstarve/creatures/spider/attack_impact")\n        end),\n        \n        -- Recovery phase\n        TimeEvent(20*FRAMES, function(inst) \n            -- After attack is complete, we can be interrupted\n            inst.sg:RemoveStateTag("busy")\n        end),\n    },\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"FRAMES"})," constant represents 1/30 of a second, which is the frame rate of animations in Don't Starve Together. Using ",(0,a.jsx)(t.code,{children:"TimeEvent(10*FRAMES, ...)"}),' means "run this function 10 frames (1/3 of a second) after entering the state."']}),"\n",(0,a.jsx)(t.h2,{id:"multi-stage-animations",children:"Multi-Stage Animations"}),"\n",(0,a.jsx)(t.p,{children:"For complex animations, it's often cleaner to break them into multiple states:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'-- Pre-attack windup\nState{\n    name = "attack_pre",\n    tags = {"attack", "busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("attack_pre")\n    end,\n    \n    events = {\n        EventHandler("animover", function(inst)\n            inst.sg:GoToState("attack_loop")\n        end),\n    },\n},\n\n-- Attack loop\nState{\n    name = "attack_loop",\n    tags = {"attack", "busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("attack_loop")\n        -- How many times to repeat the attack\n        inst.sg.statemem.attack_count = 0\n    end,\n    \n    timeline = {\n        TimeEvent(10*FRAMES, function(inst)\n            inst.components.combat:DoAttack()\n            inst.sg.statemem.attack_count = inst.sg.statemem.attack_count + 1\n        end),\n    },\n    \n    events = {\n        EventHandler("animover", function(inst)\n            if inst.sg.statemem.attack_count >= 3 then\n                inst.sg:GoToState("attack_pst")\n            else\n                inst.AnimState:PlayAnimation("attack_loop")\n            end\n        end),\n    },\n},\n\n-- Post-attack recovery\nState{\n    name = "attack_pst",\n    tags = {"busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("attack_pst")\n    end,\n    \n    events = {\n        EventHandler("animover", function(inst)\n            inst.sg:GoToState("idle")\n        end),\n    },\n},\n'})}),"\n",(0,a.jsx)(t.h2,{id:"animation-blending-for-smooth-transitions",children:"Animation Blending for Smooth Transitions"}),"\n",(0,a.jsx)(t.p,{children:"To create smoother transitions between states, you can use animation blending techniques:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'-- Blend from walking to running\nState{\n    name = "walk_to_run",\n    tags = {"moving", "running", "canrotate"},\n    \n    onenter = function(inst)\n        -- Start with walk animation but at a higher speed\n        inst.AnimState:PlayAnimation("walk_loop", true)\n        inst.AnimState:SetRate(1.5)\n        \n        -- Increase movement speed gradually\n        inst.components.locomotor:RunForward()\n        \n        -- Schedule a transition to the full run state\n        inst.sg:SetTimeout(0.5)\n    end,\n    \n    ontimeout = function(inst)\n        inst.sg:GoToState("run")\n    end,\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"handling-animation-banks-and-builds",children:"Handling Animation Banks and Builds"}),"\n",(0,a.jsx)(t.p,{children:"For entities that can change their appearance, you might need to adjust animation banks and builds in your stategraph:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'State{\n    name = "transform",\n    tags = {"busy"},\n    \n    onenter = function(inst)\n        inst.AnimState:PlayAnimation("transform")\n    end,\n    \n    timeline = {\n        TimeEvent(15*FRAMES, function(inst)\n            -- Midway through the transform animation, change appearance\n            inst.AnimState:SetBuild("spider_warrior")\n            inst.AnimState:SetBank("spider_warrior")\n            \n            -- Visual effect at transformation point\n            SpawnPrefab("statue_transition").Transform:SetPosition(inst.Transform:GetWorldPosition())\n        end),\n    },\n    \n    events = {\n        EventHandler("animover", function(inst)\n            inst.sg:GoToState("idle")\n        end),\n    },\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"syncing-animations-with-sound",children:"Syncing Animations with Sound"}),"\n",(0,a.jsx)(t.p,{children:"Sound effects should be precisely timed with animations for maximum impact:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'State{\n    name = "walk",\n    tags = {"moving", "canrotate"},\n    \n    onenter = function(inst)\n        inst.components.locomotor:WalkForward()\n        inst.AnimState:PlayAnimation("walk_loop", true)\n    end,\n    \n    -- Footstep sounds precisely timed to when feet hit the ground\n    timeline = {\n        TimeEvent(5*FRAMES, function(inst)\n            inst.SoundEmitter:PlaySound("dontstarve/movement/run_dirt")\n        end),\n        TimeEvent(15*FRAMES, function(inst)\n            inst.SoundEmitter:PlaySound("dontstarve/movement/run_dirt")\n        end),\n    },\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"working-with-animation-events",children:"Working with Animation Events"}),"\n",(0,a.jsx)(t.p,{children:"Some animations have built-in events that you can respond to:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'onenter = function(inst)\n    inst.AnimState:PlayAnimation("attack")\n    -- Listen for a specific animation event\n    inst:ListenForEvent("attack_start", function()\n        inst.SoundEmitter:PlaySound("dontstarve/creatures/spitter/spit")\n    end)\nend,\n'})}),"\n",(0,a.jsx)(t.h2,{id:"best-practices-for-animation-integration",children:"Best Practices for Animation Integration"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Match timeline events to animation keyframes"}),(0,a.jsx)(t.br,{}),"\n","Study your animations carefully and place timeline events at the exact frames where they make the most visual sense."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Use state tags to control animation behavior"}),(0,a.jsx)(t.br,{}),"\n",'Tags like "busy" can prevent interruptions during important animations.']}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Break complex animations into multiple states"}),(0,a.jsx)(t.br,{}),"\n","For readability and maintainability, divide long sequences into pre/loop/post states."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Test animations at different speeds"}),(0,a.jsx)(t.br,{}),"\n","Make sure your timeline events still make sense if animation rates change."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Use statemem to store animation context"}),(0,a.jsx)(t.br,{}),"\n","The state memory table is ideal for tracking information across animation frames."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Leverage animation blending for smooth transitions"}),(0,a.jsx)(t.br,{}),"\n","Use techniques like animation rates, crossfades, and transition states."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Document animation frame numbers"}),(0,a.jsx)(t.br,{}),"\n","Add comments to indicate which frame numbers correspond to important events in the animation."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"animation-debugging-tips",children:"Animation Debugging Tips"}),"\n",(0,a.jsx)(t.p,{children:"When working with stategraphs and animations, these debugging techniques can be helpful:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'-- Print the current animation name and frame\nprint("Current animation:", inst.AnimState:GetCurrentAnimationName())\nprint("Current time:", inst.AnimState:GetCurrentAnimationTime())\n\n-- Slow down animations to see exact timing\ninst.AnimState:SetRate(0.25)  -- Quarter speed\n\n-- Force immediate transition to a specific animation frame\ninst.AnimState:SetTime(0.5)   -- Jump to middle of animation\n'})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"The integration between State Graphs and animations is what gives Don't Starve Together entities their fluid, responsive feel. By carefully synchronizing code execution with animation frames, you can create entities that not only look good but also have gameplay mechanics that feel perfectly timed and satisfying to interact with."}),"\n",(0,a.jsx)(t.p,{children:"When creating your own entities, invest time in getting this synchronization right, as it's one of the most noticeable aspects of quality implementation."})]})}function d(n={}){const{wrapper:t}={...(0,s.R)(),...n.components};return t?(0,a.jsx)(t,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}}}]);