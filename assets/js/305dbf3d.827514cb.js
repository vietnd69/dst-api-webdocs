"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[4444],{3572:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api-vanilla/examples/case-wormhole","title":"Case Study - Wormhole Marks","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/examples/case-wormhole.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/case-wormhole","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-wormhole","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"id":"case-wormhole","title":"Case Study - Wormhole Marks","sidebar_position":12,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Case Study - Geometric Placement","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-geometric"},"next":{"title":"Case Study - Combined Status","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-status"}}');var s=i(4848),o=i(8453);const a={id:"case-wormhole",title:"Case Study - Wormhole Marks",sidebar_position:12,last_updated:new Date("2023-07-06T00:00:00.000Z")},l="Case Study: Wormhole Marks Mod",r={},d=[{value:"Mod Overview",id:"mod-overview",level:2},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"Core Techniques Used",id:"core-techniques-used",level:3},{value:"1. Custom Components",id:"1-custom-components",level:2},{value:"Key Code Elements",id:"key-code-elements",level:3},{value:"The wormhole_marks Component",id:"the-wormhole_marks-component",level:3},{value:"The wormhole_counter Component",id:"the-wormhole_counter-component",level:3},{value:"Implementation Analysis",id:"implementation-analysis",level:3},{value:"2. Minimap Integration",id:"2-minimap-integration",level:2},{value:"Key Code Elements",id:"key-code-elements-1",level:3},{value:"Implementation Analysis",id:"implementation-analysis-1",level:3},{value:"3. Configuration Options",id:"3-configuration-options",level:2},{value:"Implementation Analysis",id:"implementation-analysis-2",level:3},{value:"4. Data Persistence",id:"4-data-persistence",level:2},{value:"Implementation Analysis",id:"implementation-analysis-3",level:3},{value:"5. Server-Client Synchronization",id:"5-server-client-synchronization",level:2},{value:"Implementation Analysis",id:"implementation-analysis-4",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"1. Component-Based Architecture",id:"1-component-based-architecture",level:3},{value:"2. Visual Enhancement Without Gameplay Changes",id:"2-visual-enhancement-without-gameplay-changes",level:3},{value:"3. Efficient Implementation",id:"3-efficient-implementation",level:3},{value:"4. User Experience Focus",id:"4-user-experience-focus",level:3},{value:"Implementing Similar Features",id:"implementing-similar-features",level:2},{value:"Step 1: Create Custom Components",id:"step-1-create-custom-components",level:3},{value:"Step 2: Hook Into Appropriate Events",id:"step-2-hook-into-appropriate-events",level:3},{value:"Step 3: Add Minimap Integration",id:"step-3-add-minimap-integration",level:3},{value:"Step 4: Handle Multiplayer Considerations",id:"step-4-handle-multiplayer-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"case-study-wormhole-marks-mod",children:"Case Study: Wormhole Marks Mod"})}),"\n",(0,s.jsx)(n.p,{children:"This case study examines the \"Wormhole Marks\" mod for Don't Starve Together, which helps players track wormhole connections by adding visual markers. We'll analyze its implementation and extract valuable modding techniques."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://steamcommunity.com/sharedfiles/filedetails/?id=362175979",children:"Steam Workshop"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mod-overview",children:"Mod Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Wormhole Marks mod solves a common gameplay challenge: remembering which wormhole pairs connect to each other. The mod:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Assigns matching symbols to connected wormhole pairs"}),"\n",(0,s.jsx)(n.li,{children:"Displays these symbols on the minimap for easy navigation"}),"\n",(0,s.jsx)(n.li,{children:"Persists markings between game sessions"}),"\n",(0,s.jsx)(n.li,{children:"Optionally allows marks to be visible through fog of war"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"core-techniques-used",children:"Core Techniques Used"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Custom Components"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Minimap Integration"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Configuration Options"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Data Persistence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Server-Client Synchronization"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's examine each of these techniques in detail."}),"\n",(0,s.jsx)(n.h2,{id:"1-custom-components",children:"1. Custom Components"}),"\n",(0,s.jsx)(n.p,{children:"The mod implements two custom components to manage wormhole marking functionality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"wormhole_marks"}),": Applied to each wormhole to track and display its mark"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"wormhole_counter"}),": Applied to the world to track the global pair count"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua: Adding components to prefabs\nfunction WormholePrefabPostInit(inst)\n    if not inst.components.wormhole_marks then\n        inst:AddComponent("wormhole_marks")\n    end\n    inst:ListenForEvent("starttravelsound", Mark)\nend\n\nAddPrefabPostInit("wormhole", WormholePrefabPostInit)\n\nfunction WorldPrefabPostInit(inst)\n    if inst:HasTag("forest") then\n        inst:AddComponent("wormhole_counter")\n    end\nend\n\nif GLOBAL.TheNet:GetIsServer() or GLOBAL.TheNet:IsDedicated() then\n    AddPrefabPostInit("world", WorldPrefabPostInit)\nend\n\n-- The Mark function, triggered when a wormhole is used\nlocal function Mark(inst)\n    if not inst.components.wormhole_marks:CheckMark() then\n        inst.components.wormhole_marks:MarkEntrance()\n    end\n    \n    local other = inst.components.teleporter.targetTeleporter    \n    if not other.components.wormhole_marks:CheckMark() then\n        other.components.wormhole_marks:MarkExit()\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"the-wormhole_marks-component",children:"The wormhole_marks Component"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In scripts/components/wormhole_marks.lua\nlocal Wormhole_Marks = Class(function(self, inst)\n    self.inst = inst\n    self.marked = false\n    self.wormhole_number = nil\nend)\n\nfunction Wormhole_Marks:MarkEntrance()\n    self:GetNumber()\n    if self.wormhole_number <= 22 then \n        self.marked = true\n        if fow_setting == "enabled" then\n            self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\n        end\n        self.inst.MiniMapEntity:SetIcon("mark_"..self.wormhole_number..".tex")\n    end\nend\n\nfunction Wormhole_Marks:MarkExit()\n    self:GetNumber()\n    if self.wormhole_number <= 22 then \n        self.marked = true\n        if fow_setting == "enabled" then\n            self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\n        end\n        self.inst.MiniMapEntity:SetIcon("mark_"..self.wormhole_number..".tex")\n        TheWorld.components.wormhole_counter:Set()\n    end\nend\n\n-- Save/load functionality for persistence\nfunction Wormhole_Marks:OnSave()\n    local data = {}\n    data.marked = self.marked\n    data.wormhole_number = self.wormhole_number\n    return data\nend\n\nfunction Wormhole_Marks:OnLoad(data)\n    if data then\n        self.marked = data.marked\n        self.wormhole_number = data.wormhole_number\n        if self.marked and self.wormhole_number then\n            self.inst.entity:AddMiniMapEntity()\n            self.inst.MiniMapEntity:SetIcon("mark_"..self.wormhole_number..".tex")\n            if fow_setting == "enabled" then\n                self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\n            end\n        end\n    else\n        self.marked = false\n        self.wormhole_number = 0\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"the-wormhole_counter-component",children:"The wormhole_counter Component"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In scripts/components/wormhole_counter.lua\nreturn Class(function(self, inst)\n    assert(TheWorld.ismastersim, "Wormhole_Counter should not exist on client")\n\n    self.inst = inst\n    self.wormhole_count = 1\n\n    function self:Set()\n        self.wormhole_count = self.wormhole_count + 1\n    end\n\n    function self:Get()\n        return self.wormhole_count\n    end\n\n    function self:OnSave()\n        local data = {}\n        data.wormhole_count = self.wormhole_count\n        return data\n    end\n\n    function self:OnLoad(data)\n        if data then\n            self.wormhole_count = data.wormhole_count\n        else\n            self.wormhole_count = 1\n        end\n    end\nend)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The custom components demonstrate:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Architecture"}),": Following Don't Starve Together's component-based design pattern"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event System Integration"}),": Using ",(0,s.jsx)(n.code,{children:"ListenForEvent"})," to trigger functionality when wormholes are used"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Interaction"}),": Coordinating between wormhole and world components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefab Modification"}),": Using ",(0,s.jsx)(n.code,{children:"AddPrefabPostInit"})," to modify existing prefabs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server-Side Validation"}),": Ensuring world components only exist on the server"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-minimap-integration",children:"2. Minimap Integration"}),"\n",(0,s.jsx)(n.p,{children:"The mod uses the game's MiniMapEntity system to display custom icons for marked wormholes."}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements-1",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua: Adding minimap assets\nAssets = {\n    Asset("ATLAS", "images/mark_1.xml"),\n    Asset("ATLAS", "images/mark_2.xml"),\n    -- [Additional assets omitted for brevity]\n    Asset("ATLAS", "images/mark_22.xml"),\n}\n\n-- Registering assets with the minimap system\nAddMinimapAtlas("images/mark_1.xml")\nAddMinimapAtlas("images/mark_2.xml")\n-- [Additional registrations omitted for brevity]\nAddMinimapAtlas("images/mark_22.xml")\n\n-- In wormhole_marks component: Setting the minimap icon\nself.inst.MiniMapEntity:SetIcon("mark_"..self.wormhole_number..".tex")\n\n-- Optional fog of war visibility\nif fow_setting == "enabled" then\n    self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-1",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The minimap integration demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom Icons"}),": Using game-styled icons for wormhole pairs (22 different symbols)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asset Registration"}),": Properly registering assets for use with the minimap system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Icon Assignment"}),": Assigning icons based on wormhole pair IDs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fog of War Integration"}),": Optional visibility through unexplored areas"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Experience Focus"}),": Making connected wormholes visually distinct"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-configuration-options",children:"3. Configuration Options"}),"\n",(0,s.jsx)(n.p,{children:"The mod includes a configuration option to control whether wormhole marks should be visible through fog of war."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modinfo.lua\nconfiguration_options =\n{    \n    {\n        name = "Draw over FoW",\n        options =\n        {\n            {description = "Disabled", data = "disabled"},\n            {description = "Enabled", data = "enabled"},\n        },\n        default = "disabled",\n    },    \n}\n\n-- In wormhole_marks.lua: Accessing the configuration option\nlocal modname = KnownModIndex:GetModActualName("Wormhole Marks")\nlocal fow_setting = GetModConfigData("Draw over FoW", modname)\n\n-- Using the setting in component functions\nif fow_setting == "enabled" then\n    self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-2",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The configuration system demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Customization"}),": Providing options to tailor the experience"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mod Configuration API"}),": Using the game's built-in configuration system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Behavior Adjustment"}),": Adapting functionality based on user preferences"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default Value Selection"}),": Choosing appropriate default behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-data-persistence",children:"4. Data Persistence"}),"\n",(0,s.jsx)(n.p,{children:"The mod saves wormhole pairing information between game sessions using the component save/load system."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In wormhole_marks.lua: Save function\nfunction Wormhole_Marks:OnSave()\n    local data = {}\n    data.marked = self.marked\n    data.wormhole_number = self.wormhole_number\n    return data\nend\n\n-- In wormhole_marks.lua: Load function\nfunction Wormhole_Marks:OnLoad(data)\n    if data then\n        self.marked = data.marked\n        self.wormhole_number = data.wormhole_number\n        if self.marked and self.wormhole_number then\n            self.inst.entity:AddMiniMapEntity()\n            self.inst.MiniMapEntity:SetIcon("mark_"..self.wormhole_number..".tex")\n            if fow_setting == "enabled" then\n                self.inst.MiniMapEntity:SetDrawOverFogOfWar(true)\n            end\n        end\n    else\n        self.marked = false\n        self.wormhole_number = 0\n    end\nend\n\n-- In wormhole_counter.lua: Save/load for the global counter\nfunction self:OnSave()\n    local data = {}\n    data.wormhole_count = self.wormhole_count\n    return data\nend\n\nfunction self:OnLoad(data)\n    if data then\n        self.wormhole_count = data.wormhole_count\n    else\n        self.wormhole_count = 1\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-3",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The data persistence system demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Save/Load Hooks"}),": Using the standard DST persistence mechanism"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Validation"}),": Checking loaded data before applying"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Restoration"}),": Rebuilding visual state from saved data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimal Data Storage"}),": Saving only what's necessary (marked status and ID number)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default Values"}),": Providing fallbacks when data is not available"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"5-server-client-synchronization",children:"5. Server-Client Synchronization"}),"\n",(0,s.jsx)(n.p,{children:"The mod uses the world component's server authority to manage wormhole marking, ensuring all clients see consistent information."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua: Server-side validation\nif GLOBAL.TheNet:GetIsServer() or GLOBAL.TheNet:IsDedicated() then\n    AddPrefabPostInit("world", WorldPrefabPostInit)\nend\n\n-- In wormhole_counter.lua: Server-side assertion\nassert(TheWorld.ismastersim, "Wormhole_Counter should not exist on client")\n'})}),"\n",(0,s.jsx)(n.p,{children:"The mod leverages the game's built-in entity replication system, which automatically synchronizes MiniMapEntity changes to clients."}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-4",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The network synchronization demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server Authority"}),": Ensuring the wormhole counter only exists on the server"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Replication"}),": Using the game's built-in entity replication for minimaps"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimized Network Traffic"}),": Only sending necessary information (mark assignments)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection-Time Synchronization"}),": New clients automatically receive the correct state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Ensuring components only run in appropriate environments"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,s.jsx)(n.p,{children:"From analyzing the Wormhole Marks mod, we can extract several valuable lessons for mod development:"}),"\n",(0,s.jsx)(n.h3,{id:"1-component-based-architecture",children:"1. Component-Based Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The mod demonstrates excellent use of the component pattern:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creating focused components with single responsibilities"}),"\n",(0,s.jsx)(n.li,{children:"Using world components for global state"}),"\n",(0,s.jsx)(n.li,{children:"Leveraging the built-in save/load hooks for persistence"}),"\n",(0,s.jsx)(n.li,{children:"Separating presentation (marks) from data management (counter)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-visual-enhancement-without-gameplay-changes",children:"2. Visual Enhancement Without Gameplay Changes"}),"\n",(0,s.jsx)(n.p,{children:"The mod enhances the game experience by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adding visual information without changing core mechanics"}),"\n",(0,s.jsx)(n.li,{children:"Respecting the game's existing systems and interfaces"}),"\n",(0,s.jsx)(n.li,{children:"Integrating cleanly with the minimap system"}),"\n",(0,s.jsx)(n.li,{children:"Using clear visual language (distinct symbols for pairs)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-efficient-implementation",children:"3. Efficient Implementation"}),"\n",(0,s.jsx)(n.p,{children:"The mod shows good practices for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Minimal processing (only marking when wormholes are used)"}),"\n",(0,s.jsx)(n.li,{children:"Efficient asset management (22 distinct symbols, reused when needed)"}),"\n",(0,s.jsx)(n.li,{children:"Strategic event listening rather than continuous checking"}),"\n",(0,s.jsx)(n.li,{children:"Using built-in systems rather than reinventing functionality"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-user-experience-focus",children:"4. User Experience Focus"}),"\n",(0,s.jsx)(n.p,{children:"The mod prioritizes user experience through:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Solving a specific gameplay pain point"}),"\n",(0,s.jsx)(n.li,{children:"Providing configuration options for player preference"}),"\n",(0,s.jsx)(n.li,{children:"Maintaining visual consistency with the game"}),"\n",(0,s.jsx)(n.li,{children:"Working consistently in multiplayer environments"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementing-similar-features",children:"Implementing Similar Features"}),"\n",(0,s.jsx)(n.p,{children:"If you want to create a mod with similar entity-relationship visualization features, follow these steps:"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-create-custom-components",children:"Step 1: Create Custom Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Define your custom component\nlocal MyComponent = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Initialize component state\n    self.marked = false\n    self.identifier = nil\nend)\n\n-- Add save/load functionality\nfunction MyComponent:OnSave()\n    return {\n        marked = self.marked,\n        identifier = self.identifier\n    }\nend\n\nfunction MyComponent:OnLoad(data)\n    if data then\n        self.marked = data.marked\n        self.identifier = data.identifier\n        \n        -- Restore visual state if needed\n        if self.marked and self.identifier then\n            self:ApplyVisualState()\n        end\n    end\nend\n\nreturn MyComponent\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-hook-into-appropriate-events",children:"Step 2: Hook Into Appropriate Events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\nlocal function OnEntityInteraction(inst)\n    if inst.components.my_component then\n        inst.components.my_component:MarkEntity()\n        \n        -- Find related entities and mark them too\n        local related = FindRelatedEntity(inst)\n        if related and related.components.my_component then\n            related.components.my_component:MarkEntity()\n        end\n    end\nend\n\n-- Add component to entities and listen for events\nfunction EntityPostInit(inst)\n    inst:AddComponent("my_component")\n    inst:ListenForEvent("relevant_event", OnEntityInteraction)\nend\n\nAddPrefabPostInit("target_prefab", EntityPostInit)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-add-minimap-integration",children:"Step 3: Add Minimap Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua: Register assets\nAssets = {\n    Asset("ATLAS", "images/custom_icon_1.xml"),\n    Asset("ATLAS", "images/custom_icon_2.xml"),\n    -- Add more as needed\n}\n\nAddMinimapAtlas("images/custom_icon_1.xml")\nAddMinimapAtlas("images/custom_icon_2.xml")\n\n-- In your component: Apply minimap icons\nfunction MyComponent:ApplyVisualState()\n    -- Ensure entity has a minimap entity\n    if not self.inst.MiniMapEntity then\n        self.inst.entity:AddMiniMapEntity()\n    end\n    \n    -- Set the appropriate icon\n    self.inst.MiniMapEntity:SetIcon("custom_icon_" .. self.identifier .. ".tex")\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-handle-multiplayer-considerations",children:"Step 4: Handle Multiplayer Considerations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Ensure server authority for global components\nif TheNet:GetIsServer() or TheNet:IsDedicated() then\n    -- Add world component for tracking global state\n    AddPrefabPostInit("world", function(inst)\n        inst:AddComponent("my_global_component")\n    end)\nend\n\n-- In your global component\nlocal MyGlobalComponent = Class(function(self, inst)\n    self.inst = inst\n    assert(TheWorld.ismastersim, "MyGlobalComponent should not exist on client")\n    \n    -- Initialize global state\n    self.entity_count = 0\nend)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The Wormhole Marks mod exemplifies excellent mod design through:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Focused Problem-Solving"}),": Addressing a specific player pain point"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Integration"}),": Working with existing game systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Technical Excellence"}),": Using components and events appropriately"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiplayer Support"}),": Ensuring consistent experience across all players"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By studying this mod, we can learn how to create effective quality-of-life improvements that enhance the game while respecting its design and systems."}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/entity-system",children:"Entity System"})," - For understanding entity management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/component-system",children:"Component System"})," - For component-based architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/event-system",children:"Event System"})," - For event handling and communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/worldstate",children:"WorldState"})," - For world state persistence"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/prefab",children:"Prefab System"})," - For understanding prefab initialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," - For multiplayer synchronization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/case-status",children:"Case Study - Combined Status"})," - Another UI enhancement mod example"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/case-geometric",children:"Case Study - Geometric Placement"})," - Another QoL improvement mod"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);