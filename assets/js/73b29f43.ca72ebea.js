"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[41379],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var t=i(96540);const a={},r=t.createContext(a);function s(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},62935:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"game-scripts/core-systems/localization-content/content/giantutils","title":"Giant Utilities","description":"Utility functions for giant creature movement and pathfinding behaviors","source":"@site/docs/game-scripts/core-systems/localization-content/content/giantutils.md","sourceDirName":"game-scripts/core-systems/localization-content/content","slug":"/game-scripts/core-systems/localization-content/content/giantutils","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/localization-content/content/giantutils","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"giantutils","title":"Giant Utilities","description":"Utility functions for giant creature movement and pathfinding behaviors","sidebar_position":5,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Content Systems Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/localization-content/content/"},"next":{"title":"Guitar Tab - DST Main Theme","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/localization-content/content/guitartab-dsmaintheme"}}');var a=i(74848),r=i(28453);const s={id:"giantutils",title:"Giant Utilities",description:"Utility functions for giant creature movement and pathfinding behaviors",sidebar_position:5,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},o="Giant Utilities",l={},d=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Constants",id:"constants",level:2},{value:"WANDER_AWAY_DIST",id:"wander_away_dist",level:3},{value:"Functions",id:"functions",level:2},{value:"GetWanderAwayPoint(pt)",id:"get-wander-away-point",level:3},{value:"Pathfinding Considerations",id:"pathfinding-considerations",level:2},{value:"Terrain Validation",id:"terrain-validation",level:3},{value:"Path Clearance",id:"path-clearance",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"Basic Giant Movement",id:"basic-giant-movement",level:3},{value:"Fallback Behavior",id:"fallback-behavior",level:3},{value:"Defensive Positioning",id:"defensive-positioning",level:3},{value:"Giant-Specific Considerations",id:"giant-specific-considerations",level:2},{value:"Movement Characteristics",id:"movement-characteristics",level:3},{value:"Scale and Distance",id:"scale-and-distance",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"No Valid Point Found",id:"no-valid-point-found",level:3},{value:"Terrain Edge Cases",id:"terrain-edge-cases",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Search Optimization",id:"search-optimization",level:3},{value:"Pathfinding Efficiency",id:"pathfinding-efficiency",level:3},{value:"Integration with AI Systems",id:"integration-with-ai-systems",level:2},{value:"Brain Integration",id:"brain-integration",level:3},{value:"State Graph Integration",id:"state-graph-integration",level:3},{value:"Related Modules",id:"related-modules",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"giant-utilities",children:"Giant Utilities"})}),"\n",(0,a.jsx)(e.h2,{id:"version-history",children:"Version History"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Build Version"}),(0,a.jsx)(e.th,{children:"Change Date"}),(0,a.jsx)(e.th,{children:"Change Type"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"676042"}),(0,a.jsx)(e.td,{children:"2025-06-21"}),(0,a.jsx)(e.td,{children:"stable"}),(0,a.jsx)(e.td,{children:"Current version"})]})})]}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"giantutils.lua"})," module provides utility functions specifically designed for giant creatures in Don't Starve Together. It contains pathfinding and movement logic to help giant entities navigate away from their current position while respecting terrain constraints."]}),"\n",(0,a.jsx)(e.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Get a wander away point for a giant creature\nlocal giant_pos = giant.Transform:GetWorldPosition()\nlocal wander_point = GetWanderAwayPoint(giant_pos)\n\nif wander_point then\n    -- Move the giant to the new position\n    giant.components.locomotor:GoToPoint(wander_point)\nelse\n    -- No valid wander point found\n    print("Could not find valid wander point")\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"constants",children:"Constants"}),"\n",(0,a.jsx)(e.h3,{id:"wander_away_dist",children:"WANDER_AWAY_DIST"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Value:"})," ",(0,a.jsx)(e.code,{children:"100"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Status:"})," ",(0,a.jsx)(e.code,{children:"stable"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Description:"})," The distance in world units that giants should wander away from their current position when seeking a new location."]}),"\n",(0,a.jsx)(e.h2,{id:"functions",children:"Functions"}),"\n",(0,a.jsx)(e.h3,{id:"get-wander-away-point",children:"GetWanderAwayPoint(pt)"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Status:"})," ",(0,a.jsx)(e.code,{children:"stable"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Description:"}),"\nFinds a valid point for a giant creature to wander to, at a fixed distance away from the current position. The function attempts to find passable terrain that has a clear path from the starting point."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"pt"})," (Vector3): The current position to wander away from"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"(Vector3/nil): A valid wander destination point, or nil if no suitable point found"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Basic usage\nlocal current_pos = Vector3(0, 0, 0)\nlocal destination = GetWanderAwayPoint(current_pos)\n\nif destination then\n    print("Found wander point at:", destination.x, destination.z)\n    -- Use destination for movement\nelse\n    print("No valid wander point available")\nend\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Algorithm Details:"})}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Circular Search Pattern"}),": Uses a circle around the starting point with radius ",(0,a.jsx)(e.code,{children:"WANDER_AWAY_DIST"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Step Division"}),": Divides the circle into 12 equal steps (30-degree increments)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validation Checks"}),": For each potential point:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Checks if terrain is passable using ",(0,a.jsx)(e.code,{children:"TheWorld.Map:IsPassableAtPoint()"})]}),"\n",(0,a.jsxs)(e.li,{children:["Verifies clear pathfinding route using ",(0,a.jsx)(e.code,{children:"TheWorld.Pathfinder:IsClear()"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Wall Ignoring"}),": Uses ",(0,a.jsx)(e.code,{children:"ignorewalls = true"})," for pathfinding to allow giants to move through walls"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Technical Implementation:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Pseudocode of the algorithm\nlocal radius = WANDER_AWAY_DIST  -- 100 units\nlocal steps = 12                 -- 30-degree increments\nlocal theta = random_angle()     -- Random starting angle\n\nfor each step do\n    local offset = Vector3(\n        radius * cos(theta), \n        0, \n        -radius * sin(theta)\n    )\n    local test_point = starting_point + offset\n    \n    if is_passable(test_point) and has_clear_path(test_point) then\n        return test_point\n    end\n    \n    theta = theta - (360_degrees / steps)\nend\n\nreturn nil  -- No valid point found\n"})}),"\n",(0,a.jsx)(e.h2,{id:"pathfinding-considerations",children:"Pathfinding Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"terrain-validation",children:"Terrain Validation"}),"\n",(0,a.jsx)(e.p,{children:"The function performs comprehensive terrain validation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Passability check\nlocal passable = ground.Map:IsPassableAtPoint(wx, wy, wz, false, true)\n\n-- Parameters explained:\n-- wx, wy, wz: World coordinates to test\n-- false: Not ignoring walls for passability\n-- true: Allowing water tiles (giants can often cross water)\n"})}),"\n",(0,a.jsx)(e.h3,{id:"path-clearance",children:"Path Clearance"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Clear path verification\nlocal clear_path = ground.Pathfinder:IsClear(\n    start_x, start_y, start_z,      -- Starting position\n    end_x, end_y, end_z,            -- Destination position\n    { ignorewalls = true }          -- Configuration options\n)\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Path Options:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"ignorewalls = true"}),": Allows giants to move through walls and obstacles that would block normal entities"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"basic-giant-movement",children:"Basic Giant Movement"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Simple wander behavior for giants\nlocal function WanderAway(giant)\n    local current_pos = giant.Transform:GetWorldPosition()\n    local wander_point = GetWanderAwayPoint(current_pos)\n    \n    if wander_point then\n        if giant.components.locomotor then\n            giant.components.locomotor:GoToPoint(wander_point)\n            return true\n        end\n    end\n    return false\nend\n"})}),"\n",(0,a.jsx)(e.h3,{id:"fallback-behavior",children:"Fallback Behavior"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Robust wander with fallback\nlocal function TryWanderOrIdle(giant)\n    local pos = giant.Transform:GetWorldPosition()\n    local destination = GetWanderAwayPoint(pos)\n    \n    if destination then\n        -- Found valid wander point\n        giant.components.locomotor:GoToPoint(destination)\n        giant.wander_time = GetTime() + math.random(10, 30)\n    else\n        -- No valid point, enter idle state\n        giant.components.locomotor:Stop()\n        giant.sg:GoToState("idle")\n    end\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"defensive-positioning",children:"Defensive Positioning"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Move away from threats or players\nlocal function RetreatFromThreat(giant, threat_position)\n    -- Use threat position as reference for wander direction\n    local retreat_point = GetWanderAwayPoint(threat_position)\n    \n    if retreat_point then\n        -- Ensure we're moving away from the threat\n        local giant_pos = giant.Transform:GetWorldPosition()\n        local threat_to_giant = giant_pos - threat_position\n        local threat_to_retreat = retreat_point - threat_position\n        \n        -- Check if retreat point is in the right direction\n        if threat_to_giant:Dot(threat_to_retreat) > 0 then\n            giant.components.locomotor:GoToPoint(retreat_point)\n            return true\n        end\n    end\n    \n    -- Fallback: move in opposite direction of threat\n    return false\nend\n"})}),"\n",(0,a.jsx)(e.h2,{id:"giant-specific-considerations",children:"Giant-Specific Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"movement-characteristics",children:"Movement Characteristics"}),"\n",(0,a.jsx)(e.p,{children:"Giants have unique movement properties that this utility accommodates:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Giants can ignore certain obstacles\nlocal pathfinder_options = {\n    ignorewalls = true,      -- Can break through walls\n    ignorecreeps = true,     -- Not blocked by ground creep\n    allowwater = true        -- Can wade through water\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"scale-and-distance",children:"Scale and Distance"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"WANDER_AWAY_DIST"})," value of 100 units is calibrated for giant creatures:"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Large Movement Range"}),": Ensures giants don't get stuck in small areas"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Terrain Clearance"}),": Provides enough distance to clear obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance Balance"}),": Large enough for meaningful movement, small enough for quick pathfinding"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(e.h3,{id:"no-valid-point-found",children:"No Valid Point Found"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local function HandleWanderFailure(giant)\n    local wander_point = GetWanderAwayPoint(giant.Transform:GetWorldPosition())\n    \n    if not wander_point then\n        -- Possible reasons:\n        -- 1. Surrounded by impassable terrain\n        -- 2. On isolated island/platform\n        -- 3. Pathfinder limitations\n        \n        -- Fallback strategies:\n        giant.sg:GoToState("idle")\n        -- or try smaller movement distances\n        -- or enter special "stuck" behavior\n    end\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"terrain-edge-cases",children:"Terrain Edge Cases"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Giants near world edges or special terrain\nlocal function SafeWander(giant)\n    local pos = giant.Transform:GetWorldPosition()\n    \n    -- Check if we're near world boundaries\n    local world_size = TheWorld.Map:GetSize()\n    local margin = WANDER_AWAY_DIST + 20\n    \n    if pos.x < margin or pos.x > world_size - margin or\n       pos.z < margin or pos.z > world_size - margin then\n        -- Near edge, use more conservative movement\n        return GetWanderAwayPoint(pos)  -- Still try, but expect failures\n    end\n    \n    return GetWanderAwayPoint(pos)\nend\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"search-optimization",children:"Search Optimization"}),"\n",(0,a.jsx)(e.p,{children:"The function uses an efficient search pattern:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fixed Step Count"}),": Only tests 12 positions maximum"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Early Exit"}),": Returns immediately when valid point found"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Circular Distribution"}),": Ensures even coverage around starting point"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"pathfinding-efficiency",children:"Pathfinding Efficiency"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- Optimized for giant movement patterns\nlocal pathfind_config = {\n    ignorewalls = true,  -- Reduces pathfinding complexity\n    maxdist = 100,       -- Limits search range\n    quick_check = true   -- Fast validation for giants\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-with-ai-systems",children:"Integration with AI Systems"}),"\n",(0,a.jsx)(e.h3,{id:"brain-integration",children:"Brain Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Use in giant brain behaviors\nlocal function CreateWanderNode()\n    return WhileNode(\n        function(inst) \n            return not inst.components.combat:HasTarget() \n        end,\n        "Wander",\n        DoAction(inst, function()\n            local pos = inst.Transform:GetWorldPosition()\n            local wander_pos = GetWanderAwayPoint(pos)\n            if wander_pos then\n                return BufferedAction(inst, nil, ACTIONS.WALKTO, nil, wander_pos)\n            end\n        end)\n    )\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"state-graph-integration",children:"State Graph Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Use in giant state graphs\nlocal function wander_state()\n    return State{\n        name = "wander",\n        tags = {"moving", "canrotate"},\n        \n        onenter = function(inst)\n            local pos = inst.Transform:GetWorldPosition()\n            local destination = GetWanderAwayPoint(pos)\n            \n            if destination then\n                inst.components.locomotor:GoToPoint(destination)\n            else\n                inst.sg:GoToState("idle")\n            end\n        end,\n        \n        events = {\n            EventHandler("locomotor_arrived", function(inst)\n                inst.sg:GoToState("idle")\n            end),\n        }\n    }\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"./vector3.md",children:"Vector3"}),": 3D vector mathematics for position calculations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"./pathfinder.md",children:"Pathfinder"}),": Pathfinding system for navigation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"./map.md",children:"Map"}),": World map and terrain information"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"../components/locomotor.md",children:"Locomotor Component"}),": Entity movement component"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"../brains/index.md",children:"Giant Brains"}),": AI behavior systems for giant creatures"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}}}]);