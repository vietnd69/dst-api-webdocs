"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5784],{3128:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"api-vanilla/core/mod-interaction","title":"Mod Interaction and Compatibility","description":"This document explains how mods interact with each other in Don\'t Starve Together, including dependency management, compatibility checking, and conflict resolution.","source":"@site/docs/api-vanilla/core/mod-interaction.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/mod-interaction","permalink":"/dst-api-webdocs/docs/api-vanilla/core/mod-interaction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"mod-interaction","title":"Mod Interaction and Compatibility","sidebar_position":10,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"WorldState API","permalink":"/dst-api-webdocs/docs/api-vanilla/core/worldstate"},"next":{"title":"UI System","permalink":"/dst-api-webdocs/docs/api-vanilla/core/ui-system"}}');var t=i(4848),d=i(8453);const a={id:"mod-interaction",title:"Mod Interaction and Compatibility",sidebar_position:10,last_updated:new Date("2023-07-06T00:00:00.000Z")},s="Mod Interaction and Compatibility",r={},l=[{value:"Mod Dependencies",id:"mod-dependencies",level:2},{value:"Declaring Dependencies",id:"declaring-dependencies",level:3},{value:"Dependency Resolution",id:"dependency-resolution",level:3},{value:"Checking for Dependencies",id:"checking-for-dependencies",level:3},{value:"Mod Compatibility",id:"mod-compatibility",level:2},{value:"API Version Checking",id:"api-version-checking",level:3},{value:"Client-Server Mod Compatibility",id:"client-server-mod-compatibility",level:3},{value:"Checking Mod Compatibility",id:"checking-mod-compatibility",level:3},{value:"Handling Mod Conflicts",id:"handling-mod-conflicts",level:2},{value:"Priority-Based Resolution",id:"priority-based-resolution",level:3},{value:"Conditional Modifications",id:"conditional-modifications",level:3},{value:"Shared Resources",id:"shared-resources",level:3},{value:"Event-Based Communication",id:"event-based-communication",level:3},{value:"Advanced Hook Management",id:"advanced-hook-management",level:3},{value:"Network Interaction Between Mods",id:"network-interaction-between-mods",level:2},{value:"RPC ID Management",id:"rpc-id-management",level:3},{value:"RPC Compatibility Checking",id:"rpc-compatibility-checking",level:3},{value:"Network Variable Conflicts",id:"network-variable-conflicts",level:3},{value:"Sharing Network Data Between Mods",id:"sharing-network-data-between-mods",level:3},{value:"Coordinating Network Replication",id:"coordinating-network-replication",level:3},{value:"Best Practices for Mod Compatibility",id:"best-practices-for-mod-compatibility",level:2},{value:"Advanced Conflict Resolution Techniques",id:"advanced-conflict-resolution-techniques",level:2},{value:"Component Method Chaining",id:"component-method-chaining",level:3},{value:"Conflict Detection System",id:"conflict-detection-system",level:3},{value:"Troubleshooting Mod Conflicts",id:"troubleshooting-mod-conflicts",level:2},{value:"Common Conflict Patterns and Solutions",id:"common-conflict-patterns-and-solutions",level:3},{value:"Example: Creating a Compatible Mod",id:"example-creating-a-compatible-mod",level:2},{value:"Example: Advanced Component Modification with Compatibility",id:"example-advanced-component-modification-with-compatibility",level:3},{value:"Example: Network-Safe Mod Interaction",id:"example-network-safe-mod-interaction",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"mod-interaction-and-compatibility",children:"Mod Interaction and Compatibility"})}),"\n",(0,t.jsx)(e.p,{children:"This document explains how mods interact with each other in Don't Starve Together, including dependency management, compatibility checking, and conflict resolution."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:'flowchart TD\n    subgraph "Mod Interaction Flow"\n    A[Mod A] --\x3e |"Depends on"| B[Mod B]\n    C[Mod C] --\x3e |"Conflicts with"| D[Mod D]\n    E[Mod E] --\x3e |"Enhances"| F[Mod F]\n    G[Client Mod] --\x3e |"Works with"| H[Server Mod]\n    end\n    \n    subgraph "Dependency Resolution"\n    DR1[Mod Loading] --\x3e DR2[Check Dependencies]\n    DR2 --\x3e |"Missing"| DR3[Disable Mod or Show Warning]\n    DR2 --\x3e |"Present"| DR4[Load Dependencies First]\n    DR4 --\x3e DR5[Load Dependent Mod]\n    end\n    \n    subgraph "Conflict Resolution"\n    CR1[Mod Loading] --\x3e CR2[Check for Conflicts]\n    CR2 --\x3e |"Conflict Detected"| CR3[Priority Resolution]\n    CR3 --\x3e CR4[Load Higher Priority Mod]\n    CR2 --\x3e |"No Conflict"| CR5[Load Both Mods]\n    end\n'})}),"\n",(0,t.jsx)(e.h2,{id:"mod-dependencies",children:"Mod Dependencies"}),"\n",(0,t.jsx)(e.p,{children:"Don't Starve Together provides a system for mods to declare dependencies on other mods. This ensures that required mods are loaded in the correct order and prevents mods from being enabled when their dependencies are missing."}),"\n",(0,t.jsx)(e.h3,{id:"declaring-dependencies",children:"Declaring Dependencies"}),"\n",(0,t.jsxs)(e.p,{children:["In your ",(0,t.jsx)(e.code,{children:"modinfo.lua"}),", you can declare dependencies using the ",(0,t.jsx)(e.code,{children:"mod_dependencies"})," field:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In modinfo.lua\nmod_dependencies = {\n    -- Simple format: just list the mod names or workshop IDs\n    "workshop-123456789", -- Dependency by Workshop ID\n    "AnotherModName",     -- Dependency by mod folder name\n    \n    -- Advanced format with alternatives\n    {\n        -- Workshop ID is the primary dependency\n        workshop = "workshop-987654321",\n        \n        -- Alternative mods that can satisfy this dependency\n        "AlternativeMod1",\n        "AlternativeMod2"\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"When using the advanced format:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.code,{children:"workshop"})," field specifies the preferred dependency (usually a Workshop mod)"]}),"\n",(0,t.jsx)(e.li,{children:"Additional entries provide alternatives if the preferred mod isn't available"}),"\n",(0,t.jsx)(e.li,{children:"The system will use the first available mod in the list"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"dependency-resolution",children:"Dependency Resolution"}),"\n",(0,t.jsx)(e.p,{children:"When a mod with dependencies is loaded:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"The system checks if each dependency is available"}),"\n",(0,t.jsxs)(e.li,{children:["If a dependency is missing:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"In the main menu: The user is prompted to subscribe to and enable the dependency"}),"\n",(0,t.jsx)(e.li,{children:"During game startup: The dependent mod is disabled with a warning"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.li,{children:"If dependencies are present, they are loaded before the dependent mod"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"checking-for-dependencies",children:"Checking for Dependencies"}),"\n",(0,t.jsx)(e.p,{children:"You can check if a mod depends on another mod or if a mod is a dependency for others:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Check if a mod has dependencies\nlocal dependencies = KnownModIndex:GetModDependencies(modname, recursive)\n-- recursive: if true, includes dependencies of dependencies\n\n-- Check if a mod is depended upon by other mods\nlocal dependents = KnownModIndex:GetModDependents(modname, recursive)\n-- recursive: if true, includes mods that depend on mods that depend on this mod\n\n-- Check if a mod is depended on by any enabled mod\nlocal is_dependency = KnownModIndex:IsModDependedOn(modname)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"mod-compatibility",children:"Mod Compatibility"}),"\n",(0,t.jsx)(e.p,{children:"Ensuring compatibility between mods is crucial for a stable game experience. DST provides several mechanisms to help with this."}),"\n",(0,t.jsx)(e.h3,{id:"api-version-checking",children:"API Version Checking"}),"\n",(0,t.jsxs)(e.p,{children:["Each mod declares its API version in ",(0,t.jsx)(e.code,{children:"modinfo.lua"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"api_version = 10  -- Current DST API version\n"})}),"\n",(0,t.jsx)(e.p,{children:"The game checks this version against the current game API version to ensure compatibility. If a mod's API version is:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Lower than the game's: A warning is displayed about possible outdated functionality"}),"\n",(0,t.jsx)(e.li,{children:"Higher than the game's: The mod is disabled as it was designed for a newer version of the game"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"client-server-mod-compatibility",children:"Client-Server Mod Compatibility"}),"\n",(0,t.jsx)(e.p,{children:"Mods can specify whether they need to be installed on both client and server:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- In modinfo.lua\nall_clients_require_mod = true  -- All clients must have this mod\nclient_only_mod = false         -- Is this a client-only mod?\n"})}),"\n",(0,t.jsxs)(e.p,{children:["When ",(0,t.jsx)(e.code,{children:"all_clients_require_mod"})," is true:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Clients without the mod cannot connect to servers with the mod"}),"\n",(0,t.jsx)(e.li,{children:"The server checks for mod presence during connection"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["When ",(0,t.jsx)(e.code,{children:"client_only_mod"})," is true:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"The mod only runs on clients and doesn't affect server behavior"}),"\n",(0,t.jsx)(e.li,{children:"No synchronization is needed between clients and server"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"checking-mod-compatibility",children:"Checking Mod Compatibility"}),"\n",(0,t.jsx)(e.p,{children:"You can check if another mod exists or is enabled:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Check if a mod exists (installed)\nlocal exists = KnownModIndex:DoesModExistAnyVersion(modname)\n\n-- Check if a mod is enabled\nlocal enabled = KnownModIndex:IsModEnabled(modname)\n\n-- Check if a mod is enabled by any means (normal, forced, or temp)\nlocal enabled_any = KnownModIndex:IsModEnabledAny(modname)\n\n-- Get information about a mod\nlocal modinfo = KnownModIndex:GetModInfo(modname)\nif modinfo then\n    local version = modinfo.version -- Get the mod's version\n    local api_version = modinfo.api_version -- Get the mod's API version\nend\n\n-- Get all enabled mods\nlocal enabled_mods = KnownModIndex:GetEnabledModNames()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"handling-mod-conflicts",children:"Handling Mod Conflicts"}),"\n",(0,t.jsx)(e.p,{children:"Mods may conflict when they modify the same game elements. Here are strategies to handle conflicts:"}),"\n",(0,t.jsx)(e.h3,{id:"priority-based-resolution",children:"Priority-Based Resolution"}),"\n",(0,t.jsx)(e.p,{children:"When multiple mods modify the same function or component, the load order determines which mod's changes take precedence:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In modmain.lua\n-- Use a higher priority number to load later (and override earlier mods)\nGLOBAL.MOD_PRIORITY = 200  -- Default is 0\n\n-- Check if another mod is loaded before making changes\nif GLOBAL.KnownModIndex:IsModEnabled("PotentialConflictingMod") then\n    -- Adjust your modifications to be compatible\nend\n'})}),"\n",(0,t.jsx)(e.h3,{id:"conditional-modifications",children:"Conditional Modifications"}),"\n",(0,t.jsx)(e.p,{children:"Make your modifications conditional based on the presence of other mods:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In modmain.lua\nlocal conflicting_mod_enabled = KnownModIndex:IsModEnabled("ConflictingMod")\n\nif conflicting_mod_enabled then\n    -- Alternative implementation that\'s compatible with the other mod\nelse\n    -- Standard implementation\nend\n'})}),"\n",(0,t.jsx)(e.h3,{id:"shared-resources",children:"Shared Resources"}),"\n",(0,t.jsx)(e.p,{children:"For mods that need to share resources or communicate:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Create a global table for inter-mod communication\nif not GLOBAL.MY_MOD_API then\n    GLOBAL.MY_MOD_API = {}\nend\n\n-- Register your mod's functionality\nGLOBAL.MY_MOD_API.MyFunction = function(...)\n    -- Implementation\nend\n\n-- Check if another mod's API is available\nif GLOBAL.OTHER_MOD_API and GLOBAL.OTHER_MOD_API.SomeFunction then\n    -- Use the other mod's functionality\nend\n"})}),"\n",(0,t.jsx)(e.h3,{id:"event-based-communication",children:"Event-Based Communication"}),"\n",(0,t.jsx)(e.p,{children:"Mods can communicate with each other using the event system:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In Mod A: Broadcast an event\nTheWorld:PushEvent("mod_a_special_event", {data = "some_value"})\n\n-- In Mod B: Listen for the event\nAddPrefabPostInit("world", function(inst)\n    inst:ListenForEvent("mod_a_special_event", function(world, data)\n        print("Received event from Mod A with data:", data.data)\n    end)\nend)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"advanced-hook-management",children:"Advanced Hook Management"}),"\n",(0,t.jsx)(e.p,{children:"When multiple mods modify the same components or prefabs, you can use a more sophisticated approach:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Create a hook management system\nif not GLOBAL.MOD_HOOKS then\n    GLOBAL.MOD_HOOKS = {\n        health_postinit = {},\n        player_postinit = {},\n    }\nend\n\n-- Register your hook with a priority\nlocal MOD_NAME = "MyAwesomeMod"\ntable.insert(GLOBAL.MOD_HOOKS.health_postinit, {\n    name = MOD_NAME,\n    priority = 50,\n    fn = function(health_component)\n        -- Your modifications\n    end\n})\n\n-- Apply hooks in priority order\nAddComponentPostInit("health", function(health)\n    -- Sort hooks by priority (higher numbers run later)\n    table.sort(GLOBAL.MOD_HOOKS.health_postinit, function(a, b)\n        return a.priority < b.priority\n    end)\n    \n    -- Apply each hook in order\n    for _, hook in ipairs(GLOBAL.MOD_HOOKS.health_postinit) do\n        hook.fn(health)\n    end\nend)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"network-interaction-between-mods",children:"Network Interaction Between Mods"}),"\n",(0,t.jsx)(e.p,{children:"When multiple mods need to communicate over the network or modify network behavior, special care must be taken to avoid conflicts and ensure compatibility."}),"\n",(0,t.jsx)(e.h3,{id:"rpc-id-management",children:"RPC ID Management"}),"\n",(0,t.jsx)(e.p,{children:"RPC (Remote Procedure Call) IDs must be unique across all mods to prevent conflicts:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Bad: Using hardcoded IDs can conflict with other mods\nMOD_RPC = {\n    MyMod = {\n        DoSomething = 0,  -- Could conflict with another mod\n        DoSomethingElse = 1\n    }\n}\n\n-- Good: Using a namespace based on your mod name\nMOD_RPC = {\n    MyUniqueModName = {  -- Use a unique mod name as namespace\n        DoSomething = 0,\n        DoSomethingElse = 1\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"rpc-compatibility-checking",children:"RPC Compatibility Checking"}),"\n",(0,t.jsx)(e.p,{children:"Check if another mod has registered RPCs before defining your own:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Check if another mod\'s RPC exists\nif MOD_RPC and MOD_RPC.OtherMod and MOD_RPC.OtherMod.SomeAction then\n    -- The other mod\'s RPC exists, adapt accordingly\n    print("Found OtherMod\'s SomeAction RPC")\nend\n\n-- Register your RPC handlers only if they haven\'t been registered\nif not GLOBAL.MOD_RPC_HANDLERS or not GLOBAL.MOD_RPC_HANDLERS["MyMod_DoSomething"] then\n    AddModRPCHandler("MyMod", "DoSomething", function(player, ...)\n        -- Handle the RPC\n    end)\n    \n    -- Track that we\'ve registered this handler\n    if not GLOBAL.MOD_RPC_HANDLERS then\n        GLOBAL.MOD_RPC_HANDLERS = {}\n    end\n    GLOBAL.MOD_RPC_HANDLERS["MyMod_DoSomething"] = true\nend\n'})}),"\n",(0,t.jsx)(e.h3,{id:"network-variable-conflicts",children:"Network Variable Conflicts"}),"\n",(0,t.jsx)(e.p,{children:"Network variables (netvars) can conflict if multiple mods try to use the same variable path:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Bad: Generic variable path could conflict\ninst.mynetvar = net_bool(inst.GUID, "myvar", "myvardirty")\n\n-- Good: Namespaced variable path avoids conflicts\ninst.mynetvar = net_bool(inst.GUID, "mymod:myvar", "mymod:myvardirty")\n'})}),"\n",(0,t.jsx)(e.h3,{id:"sharing-network-data-between-mods",children:"Sharing Network Data Between Mods"}),"\n",(0,t.jsx)(e.p,{children:"Create a system for mods to share network data:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In a library mod that others depend on\nif not GLOBAL.SHARED_NETVAR_REGISTRY then\n    GLOBAL.SHARED_NETVAR_REGISTRY = {\n        variables = {},\n        Register = function(owner_mod, var_name, netvar)\n            local key = owner_mod .. ":" .. var_name\n            GLOBAL.SHARED_NETVAR_REGISTRY.variables[key] = netvar\n        end,\n        Get = function(owner_mod, var_name)\n            local key = owner_mod .. ":" .. var_name\n            return GLOBAL.SHARED_NETVAR_REGISTRY.variables[key]\n        end\n    }\nend\n\n-- In Mod A: Register a network variable\nAddPrefabPostInit("player", function(inst)\n    if not TheWorld.ismastersim then return end\n    \n    local netvar = net_float(inst.GUID, "ModA:special_stat", "ModA:special_stat_dirty")\n    GLOBAL.SHARED_NETVAR_REGISTRY.Register("ModA", "special_stat", netvar)\n    \n    -- Set initial value\n    netvar:set(100)\nend)\n\n-- In Mod B: Access the shared network variable\nAddPrefabPostInit("player", function(inst)\n    if not TheWorld.ismastersim then\n        inst:ListenForEvent("ModA:special_stat_dirty", function()\n            local netvar = GLOBAL.SHARED_NETVAR_REGISTRY.Get("ModA", "special_stat")\n            if netvar then\n                local value = netvar:value()\n                print("ModA\'s special_stat changed to:", value)\n            end\n        end)\n    end\nend)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"coordinating-network-replication",children:"Coordinating Network Replication"}),"\n",(0,t.jsx)(e.p,{children:"When multiple mods modify the same entity, coordinate replication:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Create a replication coordinator\nif not GLOBAL.MOD_REPLICATION_COORDINATOR then\n    GLOBAL.MOD_REPLICATION_COORDINATOR = {\n        batch_updates = {},\n        StartBatch = function(entity_guid)\n            if not GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid] then\n                GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid] = {\n                    count = 0,\n                    mods = {}\n                }\n            end\n            GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid].count = \n                GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid].count + 1\n        end,\n        EndBatch = function(entity_guid, mod_name)\n            local batch = GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid]\n            if batch then\n                batch.count = batch.count - 1\n                batch.mods[mod_name] = true\n                \n                -- If all mods have finished their updates, trigger replication\n                if batch.count <= 0 then\n                    local entity = Ents[entity_guid]\n                    if entity and entity.components.container then\n                        entity.components.container:TriggerUpdate()\n                    end\n                    GLOBAL.MOD_REPLICATION_COORDINATOR.batch_updates[entity_guid] = nil\n                end\n            end\n        end\n    }\nend\n\n-- In your mod: Use the coordinator\nlocal function ModifyContainer(container, mod_name)\n    local guid = container.inst.GUID\n    GLOBAL.MOD_REPLICATION_COORDINATOR.StartBatch(guid)\n    \n    -- Make your changes\n    container:GiveItem(SpawnPrefab("goldnugget"))\n    container:GiveItem(SpawnPrefab("flint"))\n    \n    GLOBAL.MOD_REPLICATION_COORDINATOR.EndBatch(guid, mod_name)\nend\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-mod-compatibility",children:"Best Practices for Mod Compatibility"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Minimal Overrides"}),": Only override what you need to change"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Instead of replacing the entire function\nlocal old_fn = GLOBAL.SomeComponent.SomeFunction\nGLOBAL.SomeComponent.SomeFunction = function(self, ...)\n    -- Custom pre-processing\n    local result = old_fn(self, ...)\n    -- Custom post-processing\n    return result\nend\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use AddComponentPostInit and AddPrefabPostInit"}),": These hooks are designed for multiple mods to modify the same components"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'AddComponentPostInit("health", function(self)\n    -- Your modifications to the health component\nend)\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Check for Existing Modifications"}),": Before modifying a function or component, check if it's already been modified"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"if GLOBAL.SomeComponent.ModifiedByOtherMod then\n    -- Handle the conflict\nelse\n    GLOBAL.SomeComponent.ModifiedByOtherMod = true\n    -- Make your modifications\nend\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Document Your Mod's API"}),": If your mod provides functionality for other mods, document it clearly"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- At the top of your modmain.lua\n--[[\nAPI for other mods:\n- GLOBAL.MY_MOD_API.Function1: Description\n- GLOBAL.MY_MOD_API.Function2: Description\n]]\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Version Your API"}),": When updating your mod, maintain backward compatibility or version your API"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'GLOBAL.MY_MOD_API = {\n    version = "1.2",\n    Function1_v1 = function() -- Old version for compatibility\n    end,\n    Function1 = function() -- New version\n    end\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use ModSettings API"}),": For configuration that other mods might need to access"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Create a settings API\nif not GLOBAL.MOD_SETTINGS then\n    GLOBAL.MOD_SETTINGS = {}\nend\n\nGLOBAL.MOD_SETTINGS.MY_MOD = {\n    difficulty = GetModConfigData("difficulty"),\n    spawn_rate = GetModConfigData("spawn_rate"),\n    \n    GetDifficulty = function()\n        return GLOBAL.MOD_SETTINGS.MY_MOD.difficulty\n    end\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Namespace Your Functions and Variables"}),": Avoid polluting the global namespace"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:"-- Bad: adds to global namespace\nfunction DoSomething() end\n\n-- Good: keeps function within mod namespace\nif not GLOBAL.MY_MOD then GLOBAL.MY_MOD = {} end\nGLOBAL.MY_MOD.DoSomething = function() end\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use Unique Network Identifiers"}),": Namespace your network variables and RPC IDs"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Network variables with mod prefix\ninst.mynetvar = net_bool(inst.GUID, "mymod:myvar", "mymod:myvardirty")\n\n-- RPC definitions with unique mod namespace\nMOD_RPC = {\n    MyUniqueModName = {  -- Use your mod folder name\n        DoSomething = 0\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"advanced-conflict-resolution-techniques",children:"Advanced Conflict Resolution Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"component-method-chaining",children:"Component Method Chaining"}),"\n",(0,t.jsx)(e.p,{children:"When multiple mods need to modify the same component method:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Create a chain system if it doesn\'t exist\nif not GLOBAL.COMPONENT_CHAINS then\n    GLOBAL.COMPONENT_CHAINS = {}\nend\n\n-- Set up chain for a specific component method\nlocal component_name = "health"\nlocal method_name = "DoDelta"\n\nif not GLOBAL.COMPONENT_CHAINS[component_name] then\n    GLOBAL.COMPONENT_CHAINS[component_name] = {}\nend\n\n-- Store the original method before any mods change it\nif not GLOBAL.COMPONENT_CHAINS[component_name][method_name] then\n    GLOBAL.COMPONENT_CHAINS[component_name][method_name] = {\n        original = GLOBAL[component_name].components[component_name][method_name],\n        chain = {}\n    }\n    \n    -- Replace the method with our chain handler\n    GLOBAL[component_name].components[component_name][method_name] = function(self, ...)\n        local args = {...}\n        local chain = GLOBAL.COMPONENT_CHAINS[component_name][method_name].chain\n        local result\n        \n        -- Pre-processing hooks\n        for _, hook in ipairs(chain) do\n            if hook.pre then\n                args = hook.pre(self, unpack(args)) or args\n            end\n        end\n        \n        -- Call original method\n        result = GLOBAL.COMPONENT_CHAINS[component_name][method_name].original(self, unpack(args))\n        \n        -- Post-processing hooks\n        for _, hook in ipairs(chain) do\n            if hook.post then\n                result = hook.post(self, result, unpack(args)) or result\n            end\n        end\n        \n        return result\n    end\nend\n\n-- Add your mod\'s hooks to the chain\ntable.insert(GLOBAL.COMPONENT_CHAINS[component_name][method_name].chain, {\n    name = "MyMod",\n    pre = function(self, delta, ...)\n        -- Pre-processing\n        print("Before health change:", delta)\n        return delta * 1.5, ... -- Modify delta\n    end,\n    post = function(self, result, ...)\n        -- Post-processing\n        print("After health change, result:", result)\n        return result\n    end\n})\n'})}),"\n",(0,t.jsx)(e.h3,{id:"conflict-detection-system",children:"Conflict Detection System"}),"\n",(0,t.jsx)(e.p,{children:"Create a system to detect and report conflicts:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In modmain.lua\nif not GLOBAL.MOD_CONFLICT_DETECTOR then\n    GLOBAL.MOD_CONFLICT_DETECTOR = {\n        modified_components = {},\n        modified_prefabs = {},\n        \n        RegisterComponentModification = function(component_name, mod_name)\n            if not GLOBAL.MOD_CONFLICT_DETECTOR.modified_components[component_name] then\n                GLOBAL.MOD_CONFLICT_DETECTOR.modified_components[component_name] = {}\n            end\n            table.insert(GLOBAL.MOD_CONFLICT_DETECTOR.modified_components[component_name], mod_name)\n            \n            -- If more than one mod modifies this component, log a potential conflict\n            if #GLOBAL.MOD_CONFLICT_DETECTOR.modified_components[component_name] > 1 then\n                print("POTENTIAL MOD CONFLICT: Component \'" .. component_name .. "\' is modified by multiple mods:")\n                for _, name in ipairs(GLOBAL.MOD_CONFLICT_DETECTOR.modified_components[component_name]) do\n                    print("  - " .. name)\n                end\n            end\n        end\n    }\nend\n\n-- Register your mod\'s modifications\nlocal MY_MOD_NAME = "BetterCombat"\nAddComponentPostInit("combat", function(component)\n    GLOBAL.MOD_CONFLICT_DETECTOR.RegisterComponentModification("combat", MY_MOD_NAME)\n    -- Your modifications...\nend)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-mod-conflicts",children:"Troubleshooting Mod Conflicts"}),"\n",(0,t.jsx)(e.p,{children:"When conflicts occur, they can manifest as:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Crashes"}),": The game crashes during loading or when certain actions are performed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Visual Glitches"}),": UI elements overlap or game objects appear incorrectly"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Functionality Failures"}),": Features from one or both mods don't work as expected"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Network Desynchronization"}),": Clients get disconnected or experience different game states"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Steps to identify and resolve conflicts:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Isolate the Conflict"}),": Disable mods one by one to identify which combination causes the issue"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Check Load Order"}),": Try changing the load order by renaming mod folders (prefixing with numbers)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Examine Error Logs"}),": Look for error messages in the log file (",(0,t.jsx)(e.code,{children:"log.txt"})," in the game directory)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact Mod Authors"}),": Report the conflict to both mod authors so they can coordinate a solution"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use Debug Tools"}),": Enable the debug console with ",(0,t.jsx)(e.code,{children:"debug_enabled=true"})," in settings.ini"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"common-conflict-patterns-and-solutions",children:"Common Conflict Patterns and Solutions"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Conflict Type"}),(0,t.jsx)(e.th,{children:"Symptoms"}),(0,t.jsx)(e.th,{children:"Solution"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Function Override"}),(0,t.jsx)(e.td,{children:"One mod's changes aren't applied"}),(0,t.jsx)(e.td,{children:"Use function chaining pattern"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Component Conflict"}),(0,t.jsx)(e.td,{children:"Unexpected component behavior"}),(0,t.jsx)(e.td,{children:"Use ComponentPostInit with compatibility checks"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Prefab Conflict"}),(0,t.jsx)(e.td,{children:"Entities have wrong properties"}),(0,t.jsx)(e.td,{children:"Use PrefabPostInit with compatibility checks"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"UI Conflict"}),(0,t.jsx)(e.td,{children:"Overlapping or missing UI elements"}),(0,t.jsx)(e.td,{children:"Use unique screen names and check for existing screens"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Network Conflict"}),(0,t.jsx)(e.td,{children:"Desync or disconnects"}),(0,t.jsx)(e.td,{children:"Ensure consistent RPC IDs and network variables"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"example-creating-a-compatible-mod",children:"Example: Creating a Compatible Mod"}),"\n",(0,t.jsx)(e.p,{children:"Here's an example of a mod designed to be compatible with other mods:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- In modmain.lua\n\n-- Create a namespace for your mod\nif not GLOBAL.MY_FISHING_MOD then\n    GLOBAL.MY_FISHING_MOD = {\n        version = "1.0",\n        config = {},\n        -- Store original functions for other mods to access\n        original_functions = {}\n    }\nend\n\n-- Check for conflicting mods\nlocal other_fishing_mod = KnownModIndex:IsModEnabled("OtherFishingMod")\n\n-- Store original function before modifying\nGLOBAL.MY_FISHING_MOD.original_functions.GoFishing = GLOBAL.GoFishing\n\n-- Modify game function with compatibility handling\nlocal old_GoFishing = GLOBAL.GoFishing\nGLOBAL.GoFishing = function(inst, ...)\n    if other_fishing_mod and GLOBAL.OTHER_FISHING_MOD then\n        -- Coordinate with the other fishing mod\n        if GLOBAL.OTHER_FISHING_MOD.version >= "2.0" then\n            -- Use the other mod\'s enhanced system\n            return GLOBAL.OTHER_FISHING_MOD.EnhancedFishing(inst, ...)\n        end\n    end\n    \n    -- Your custom implementation\n    local result = old_GoFishing(inst, ...)\n    -- Enhance the result\n    return result\nend\n\n-- Provide API for other mods\nGLOBAL.MY_FISHING_MOD.GetFishingBonus = function(player)\n    -- Implementation\n    return bonus\nend\n\n-- Register events that other mods can listen for\nTheWorld:PushEvent("my_fishing_mod_loaded", {version = "1.0"})\n\n-- Listen for events from other mods\nTheWorld:ListenForEvent("other_mod_special_event", function(world, data)\n    print("Received event from another mod:", data)\nend)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"example-advanced-component-modification-with-compatibility",children:"Example: Advanced Component Modification with Compatibility"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Example of modifying the Health component with compatibility in mind\nAddComponentPostInit("health", function(self)\n    -- Store the original method\n    local original_DoDelta = self.DoDelta\n    \n    -- Replace with our enhanced version\n    self.DoDelta = function(self, amount, ...)\n        -- Check for other mods that might modify health\n        if GLOBAL.OTHER_HEALTH_MOD and GLOBAL.OTHER_HEALTH_MOD.ProcessHealthChange then\n            -- Let the other mod process the health change first\n            amount = GLOBAL.OTHER_HEALTH_MOD.ProcessHealthChange(self.inst, amount) or amount\n        end\n        \n        -- Apply our own modifications\n        if amount > 0 and self.inst:HasTag("player") then\n            -- Enhance healing for players\n            amount = amount * 1.1\n        end\n        \n        -- Call the original function with our modified amount\n        return original_DoDelta(self, amount, ...)\n    end\nend)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"example-network-safe-mod-interaction",children:"Example: Network-Safe Mod Interaction"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-lua",children:'-- Define unique RPC IDs\nMOD_RPC = {\n    MyFishingMod = {  -- Use your mod folder name as namespace\n        SyncFishingData = 0,\n        RequestFishingStats = 1\n    }\n}\n\n-- Register RPC handlers\nAddModRPCHandler("MyFishingMod", "RequestFishingStats", function(player)\n    -- Validate request\n    if not player or not player.components.fishingstats then\n        return\n    end\n    \n    -- Get fishing stats\n    local stats = {\n        fish_caught = player.components.fishingstats.fish_caught,\n        biggest_fish = player.components.fishingstats.biggest_fish,\n        fishing_skill = player.components.fishingstats.skill_level\n    }\n    \n    -- Send stats back to requesting client\n    SendModRPCToClient(MOD_RPC.MyFishingMod.SyncFishingData, player, \n        stats.fish_caught, stats.biggest_fish, stats.fishing_skill)\nend)\n\n-- Client-side handler\nAddClientModRPCHandler("MyFishingMod", "SyncFishingData", function(fish_caught, biggest_fish, fishing_skill)\n    -- Update local UI with received data\n    if GLOBAL.MY_FISHING_MOD and GLOBAL.MY_FISHING_MOD.ui then\n        GLOBAL.MY_FISHING_MOD.ui:UpdateStats(fish_caught, biggest_fish, fishing_skill)\n    end\n    \n    -- Notify other mods about the updated data\n    ThePlayer:PushEvent("fishing_stats_updated", {\n        fish_caught = fish_caught,\n        biggest_fish = biggest_fish,\n        fishing_skill = fishing_skill\n    })\nend)\n\n-- Create network variables with namespaced paths\nAddPrefabPostInit("player", function(inst)\n    -- Network variables for fishing stats\n    inst.fishing_level = net_byte(inst.GUID, "myfishingmod:fishing_level", "myfishingmod:fishing_level_dirty")\n    inst.fish_caught = net_uint(inst.GUID, "myfishingmod:fish_caught", "myfishingmod:fish_caught_dirty")\n    \n    if not TheWorld.ismastersim then\n        -- Client-side event handlers for network variable changes\n        inst:ListenForEvent("myfishingmod:fishing_level_dirty", function()\n            local level = inst.fishing_level:value()\n            -- Update UI or notify other mods\n            ThePlayer:PushEvent("fishing_level_changed", {level = level})\n        end)\n    end\nend)\n'})}),"\n",(0,t.jsx)(e.p,{children:"By following these practices, your mods will be more likely to work well with other mods, providing a better experience for players who use multiple mods together."})]})}function h(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>s});var o=i(6540);const t={},d=o.createContext(t);function a(n){const e=o.useContext(d);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(d.Provider,{value:e},n.children)}}}]);