"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[2562],{7818:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"api-vanilla/node-types/priority-nodes","title":"Priority Nodes","description":"Last Update: 2023-08-15","source":"@site/docs/api-vanilla/node-types/priority-nodes.md","sourceDirName":"api-vanilla/node-types","slug":"/api-vanilla/node-types/priority-nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"priority-nodes","title":"Priority Nodes","sidebar_position":5,"last_updated":"2023-08-15T00:00:00.000Z","version":624447},"sidebar":"docs","previous":{"title":"Decorator Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes"},"next":{"title":"Sequence Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes"}}');var r=i(4848),o=i(8453);const s={id:"priority-nodes",title:"Priority Nodes",sidebar_position:5,last_updated:new Date("2023-08-15T00:00:00.000Z"),version:624447},d="Priority Nodes",l={},a=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Priority Node States",id:"priority-node-states",level:2},{value:"Properties",id:"properties",level:2},{value:"Key Methods",id:"key-methods",level:2},{value:"PriorityNode()",id:"prioritynode",level:3},{value:"Returns",id:"returns",level:4},{value:"PriorityNode()",id:"prioritynode-1",level:3},{value:"PriorityNode()",id:"prioritynode-2",level:3},{value:"Built-in Priority Node Types",id:"built-in-priority-node-types",level:2},{value:"PriorityNode",id:"prioritynode-3",level:3},{value:"LoopPriorityNode",id:"loopprioritynode",level:3},{value:"WeightedPriorityNode",id:"weightedprioritynode",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Creating Custom Priority Nodes",id:"creating-custom-priority-nodes",level:2},{value:"Example: Dynamic Priority Node",id:"example-dynamic-priority-node",level:2},{value:"Integration with Other Node Types",id:"integration-with-other-node-types",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Last Update: 2023-08-15"})}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"priority-nodes",children:"Priority Nodes"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"API Version: 624447"})}),"\n",(0,r.jsx)(n.p,{children:'Priority Nodes are specialized behavior tree nodes in Don\'t Starve Together that execute child nodes in order of priority until one succeeds. They function as a logical "OR" operation, trying each child node in sequence and stopping at the first one that succeeds.'}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Basic priority node structure\nlocal PriorityNode = Class(BehaviorNode, function(self, inst, children, period)\n    BehaviorNode._ctor(self, "PriorityNode")\n    self.inst = inst\n    self.children = children\n    self.period = period or 0\n    self.lasttime = 0\n    self.currentchild = nil\nend)\n\n-- Used in a behavior tree\nlocal root = PriorityNode(\n{\n    -- Higher priority actions come first\n    RunAway(inst, "character", 4, 6),\n    ChaseAndAttack(inst, 10),\n    Wander(inst)\n}, 0.5) -- Evaluate priority every 0.5 seconds\n'})}),"\n",(0,r.jsx)(n.h2,{id:"priority-node-states",children:"Priority Node States"}),"\n",(0,r.jsx)(n.p,{children:"Like other behavior nodes, priority nodes can be in one of several states:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"State"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"READY"})}),(0,r.jsx)(n.td,{children:"Node is ready to evaluate children"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"RUNNING"})}),(0,r.jsx)(n.td,{children:"Node is currently running a child node"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SUCCESS"})}),(0,r.jsx)(n.td,{children:"A child node has succeeded"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"FAILURE"})}),(0,r.jsx)(n.td,{children:"All child nodes have failed"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Property"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"children"})}),(0,r.jsx)(n.td,{children:"Array"}),(0,r.jsx)(n.td,{children:"List of child nodes to execute in priority order"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"period"})}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Time between re-evaluations of the node (0 = evaluate every frame)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"lasttime"})}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Last time the node was evaluated"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"currentchild"})}),(0,r.jsx)(n.td,{children:"BehaviorNode"}),(0,r.jsx)(n.td,{children:"Currently executing child node"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsxs)(n.h3,{id:"prioritynode",children:["PriorityNode",":Visit","()"]}),"\n",(0,r.jsx)(n.p,{children:"Evaluates the priority node, trying each child in order until one succeeds."}),"\n",(0,r.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"(Status): The status of the priority node (RUNNING, SUCCESS, or FAILURE)"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"prioritynode-1",children:["PriorityNode",":Stop","()"]}),"\n",(0,r.jsx)(n.p,{children:"Stops the priority node and all its children."}),"\n",(0,r.jsxs)(n.h3,{id:"prioritynode-2",children:["PriorityNode",":Reset","()"]}),"\n",(0,r.jsx)(n.p,{children:"Resets the priority node and all its children to READY state."}),"\n",(0,r.jsx)(n.h2,{id:"built-in-priority-node-types",children:"Built-in Priority Node Types"}),"\n",(0,r.jsx)(n.p,{children:"Don't Starve Together includes several specialized priority node implementations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- Standard priority node\nPriorityNode(children, period)\n\n-- Loop priority node - returns to first child after reaching the end\nLoopPriorityNode(children, period)\n\n-- Weighted priority node - chooses based on weights rather than order\nWeightedPriorityNode(weighted_children, period)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"prioritynode-3",children:"PriorityNode"}),"\n",(0,r.jsx)(n.p,{children:"The standard priority node that tries each child in order."}),"\n",(0,r.jsx)(n.h3,{id:"loopprioritynode",children:"LoopPriorityNode"}),"\n",(0,r.jsx)(n.p,{children:"Similar to PriorityNode, but loops back to the first child after reaching the end."}),"\n",(0,r.jsx)(n.h3,{id:"weightedprioritynode",children:"WeightedPriorityNode"}),"\n",(0,r.jsx)(n.p,{children:"Selects children based on weights rather than strict order:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- Example weighted priority\nlocal root = WeightedPriorityNode({\n    {weight = 5, node = FindFood(inst)},\n    {weight = 3, node = ChaseAndAttack(inst, 10)},\n    {weight = 1, node = Wander(inst)}\n})\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.p,{children:"Priority nodes are commonly used for these patterns:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Fallback behavior pattern\nPriorityNode({\n    -- Try high-priority critical behavior first\n    IfNode(function() return inst.components.health:GetPercent() < 0.25 end,\n        RunAway(inst, "character", 5, 8)\n    ),\n    \n    -- Medium priority - fulfill needs\n    IfNode(function() return inst.components.hunger:GetPercent() < 0.5 end,\n        FindAndEatFood(inst)\n    ),\n    \n    -- Low priority - default behavior\n    Wander(inst)\n})\n\n-- Multiple ways to solve the same problem\nPriorityNode({\n    -- Try to pick up existing food first\n    FindAndPickupFood(inst),\n    \n    -- If no food exists, try to harvest some\n    FindAndHarvestFood(inst),\n    \n    -- Last resort - hunt for food\n    FindAndHuntFood(inst)\n})\n'})}),"\n",(0,r.jsx)(n.h2,{id:"creating-custom-priority-nodes",children:"Creating Custom Priority Nodes"}),"\n",(0,r.jsx)(n.p,{children:"To create a custom priority node:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Derive from BehaviorNode"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local CustomPriorityNode = Class(BehaviorNode, function(self, inst, children, ...)\n    BehaviorNode._ctor(self, "CustomPriorityNode")\n    self.inst = inst\n    self.children = children\n    -- Initialize additional properties\nend)\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement Visit function"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CustomPriorityNode:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.currentchild = nil\n    end\n    \n    if self.status == RUNNING then\n        -- Implement custom priority logic here\n        -- Try children in order based on your custom rules\n    end\n    \n    return self.status\nend\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement Stop function"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"function CustomPriorityNode:Stop()\n    for i, v in ipairs(self.children) do\n        v:Stop()\n    end\n    self.currentchild = nil\n    self.status = READY\nend\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-dynamic-priority-node",children:"Example: Dynamic Priority Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- A priority node that dynamically adjusts priorities based on state\nlocal DynamicPriorityNode = Class(BehaviorNode, function(self, inst, children, priority_fn)\n    BehaviorNode._ctor(self, "DynamicPriorityNode")\n    self.inst = inst\n    self.children = children\n    self.priority_fn = priority_fn  -- Function that returns ordered indices\n    self.currentchild = nil\nend)\n\nfunction DynamicPriorityNode:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.currentchild = nil\n    end\n    \n    if self.status == RUNNING then\n        -- Get current priorities\n        local priorities = self.priority_fn(self.inst)\n        \n        if self.currentchild then\n            local status = self.currentchild:Visit()\n            \n            if status == RUNNING then\n                return self.status\n            else\n                if status == SUCCESS then\n                    self.status = SUCCESS\n                    return self.status\n                end\n                self.currentchild:Stop()\n                self.currentchild = nil\n            end\n        end\n        \n        -- Try children in dynamic priority order\n        for i = 1, #priorities do\n            local idx = priorities[i]\n            if idx > 0 and idx <= #self.children then\n                local child = self.children[idx]\n                child:Start()\n                local status = child:Visit()\n                \n                if status == RUNNING then\n                    self.currentchild = child\n                    return self.status\n                elseif status == SUCCESS then\n                    self.status = SUCCESS\n                    return self.status\n                else\n                    child:Stop()\n                end\n            end\n        end\n        \n        -- If we get here, all children failed\n        self.status = FAILURE\n    end\n    \n    return self.status\nend\n\nfunction DynamicPriorityNode:Stop()\n    if self.currentchild then\n        self.currentchild:Stop()\n    end\n    \n    for i, v in ipairs(self.children) do\n        if v ~= self.currentchild then\n            v:Stop()\n        end\n    end\n    \n    self.currentchild = nil\n    self.status = READY\nend\n\n-- Example usage\nlocal behavior = DynamicPriorityNode(inst, \n    {\n        FindFood(inst),\n        ChaseAndAttack(inst, 10),\n        Wander(inst)\n    },\n    function(inst)\n        -- Return indices in priority order based on current state\n        if inst.components.hunger:GetPercent() < 0.25 then\n            return {1, 3, 2}  -- Food, wander, attack\n        elseif inst.components.combat:HasTarget() then\n            return {2, 1, 3}  -- Attack, food, wander\n        else\n            return {3, 1, 2}  -- Wander, food, attack\n        end\n    end\n)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-other-node-types",children:"Integration with Other Node Types"}),"\n",(0,r.jsx)(n.p,{children:"Priority nodes are often used with other node types to create complex behaviors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Complex behavior combining multiple node types\nlocal behavior = PriorityNode({\n    -- Emergency response\n    IfNode(function() \n        return inst.components.health:GetPercent() < 0.3 \n    end,\n        SequenceNode(inst, {\n            FindItem(inst, function(item) \n                return item.prefab == "healing_item" \n            end, 20),\n            DoAction(inst, function() \n                return inst.components.health:GetPercent() < 0.3 and\n                       inst.components.inventory:Has("healing_item", 1) and\n                       inst.components.inventory:GetItemByName("healing_item")\n            end)\n        })\n    ),\n    \n    -- Combat behavior\n    WhileNode(function() \n        return inst.components.combat:HasTarget() and\n               inst.components.combat:CanAttack() \n    end,\n        "Attack Enemy",\n        ChaseAndAttack(inst, 10)\n    ),\n    \n    -- Gathering behavior\n    NotDecorator(inst, \n        IfNode(function() \n            return inst.components.inventory:IsFull() \n        end,\n            LoopNode(inst, \n                FindAndCollectItems(inst)\n            )\n        )\n    ),\n    \n    -- Default behavior\n    Wander(inst, function() \n        return inst.components.knownlocations:GetLocation("home") \n    end, 20)\n}, 0.5)  -- Re-evaluate every 0.5 seconds\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Child Order"}),": Put most commonly successful nodes first for better performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evaluation Period"}),": Use an appropriate period value (not 0) for non-critical priority nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Child Count"}),": Keep the number of children manageable; consider nested priority nodes for complex hierarchies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reset State"}),": Properly handle the reset state for children that may run for multiple frames"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stop Method"}),": Always implement a proper Stop method to clean up resources"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/brain",children:"Brain"})," - For brain implementation using behavior trees"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/action-nodes",children:"Action Nodes"})," - For nodes that perform actions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes",children:"Condition Nodes"})," - For conditional execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes",children:"Sequence Nodes"})," - For executing actions in sequence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes",children:"Decorator Nodes"})," - For modifying node behavior"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>d});var t=i(6540);const r={},o=t.createContext(r);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);