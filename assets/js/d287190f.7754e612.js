"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[70070],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(96540);const a={},o=t.createContext(a);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},55029:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>f,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"game-scripts/core-systems/fundamentals/actions/bufferedaction","title":"Buffered Action System","description":"Documentation of the Don\'t Starve Together buffered action system for deferred action execution and validation","source":"@site/docs/game-scripts/core-systems/fundamentals/actions/bufferedaction.md","sourceDirName":"game-scripts/core-systems/fundamentals/actions","slug":"/game-scripts/core-systems/fundamentals/actions/bufferedaction","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/bufferedaction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Buffered Action System","description":"Documentation of the Don\'t Starve Together buffered action system for deferred action execution and validation","sidebar_position":2,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Actions","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/actions"},"next":{"title":"Component Actions","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/componentactions"}}');var a=i(74848),o=i(28453);const s={title:"Buffered Action System",description:"Documentation of the Don't Starve Together buffered action system for deferred action execution and validation",sidebar_position:2,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},c="Buffered Action System",r={},l=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"BufferedAction Class",id:"bufferedaction-class",level:3},{value:"Key Properties",id:"key-properties",level:3},{value:"Internal State Properties",id:"internal-state-properties",level:3},{value:"Core Methods",id:"core-methods",level:2},{value:"Action Execution",id:"action-execution",level:3},{value:"Do Method",id:"do-method",level:4},{value:"Validation System",id:"validation-system",level:3},{value:"IsValid Method",id:"isvalid-method",level:4},{value:"TestForStart Method",id:"testforstart-method",level:4},{value:"Display and Debug",id:"display-and-debug",level:3},{value:"GetActionString Method",id:"getactionstring-method",level:4},{value:"ToString Method",id:"tostring-method",level:4},{value:"Callback Management",id:"callback-management",level:3},{value:"AddSuccessAction",id:"addsuccessaction",level:4},{value:"AddFailAction",id:"addfailaction",level:4},{value:"Succeed Method",id:"succeed-method",level:4},{value:"Fail Method",id:"fail-method",level:4},{value:"Position Management",id:"position-management",level:3},{value:"GetActionPoint",id:"getactionpoint",level:4},{value:"GetDynamicActionPoint",id:"getdynamicactionpoint",level:4},{value:"SetActionPoint",id:"setactionpoint",level:4},{value:"Implementation Examples",id:"implementation-examples",level:2},{value:"Basic Action Creation",id:"basic-action-creation",level:3},{value:"Tool-Based Action",id:"tool-based-action",level:3},{value:"Position-Based Action",id:"position-based-action",level:3},{value:"Crafting Action",id:"crafting-action",level:3},{value:"Advanced Action with Custom Validation",id:"advanced-action-with-custom-validation",level:3},{value:"Integration with Game Systems",id:"integration-with-game-systems",level:2},{value:"Component Integration",id:"component-integration",level:3},{value:"Locomotor Integration",id:"locomotor-integration",level:3},{value:"State Graph Integration",id:"state-graph-integration",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Validation Debugging",id:"validation-debugging",level:3},{value:"Safe Action Execution",id:"safe-action-execution",level:3},{value:"Action Queue Management",id:"action-queue-management",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Action Validation Optimization",id:"action-validation-optimization",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Design Guidelines",id:"design-guidelines",level:3},{value:"Performance Best Practices",id:"performance-best-practices",level:3},{value:"Integration Guidelines",id:"integration-guidelines",level:3},{value:"Related Systems",id:"related-systems",level:2},{value:"Status: \ud83d\udfe2 Stable",id:"status--stable",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"buffered-action-system",children:"Buffered Action System"})}),"\n",(0,a.jsx)(n.p,{children:"The Buffered Action system in Don't Starve Together provides a framework for managing deferred action execution with validation and callback support. This system enables actions to be queued, validated, and executed at the appropriate time while maintaining game state consistency and providing robust error handling."}),"\n",(0,a.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Build Version"}),(0,a.jsx)(n.th,{children:"Change Date"}),(0,a.jsx)(n.th,{children:"Change Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"675312"}),(0,a.jsx)(n.td,{children:"2025-06-21"}),(0,a.jsx)(n.td,{children:"stable"}),(0,a.jsx)(n.td,{children:"Updated documentation to match current implementation"})]})})]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The buffered action system serves multiple purposes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Queuing"}),": Allows actions to be prepared and executed later"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State Validation"}),": Ensures action prerequisites remain valid before execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Callback Management"}),": Provides success/failure callback mechanisms"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Preservation"}),": Maintains action context and parameters"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The system is built around the ",(0,a.jsx)(n.code,{children:"BufferedAction"})," class which encapsulates all necessary information for executing an action while providing validation and callback mechanisms."]}),"\n",(0,a.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"bufferedaction-class",children:"BufferedAction Class"}),"\n",(0,a.jsx)(n.p,{children:"The main class that represents a queued action with all its parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"BufferedAction = Class(function(self, doer, target, action, invobject, pos, recipe, distance, forced, rotation, arrivedist)\n    self.doer = doer                     -- Entity performing the action\n    self.target = target                 -- Target entity or object\n    self.action = action                 -- Action definition to execute\n    self.invobject = invobject           -- Inventory object being used\n    self.pos = pos                       -- Position for action execution\n    self.recipe = recipe                 -- Recipe if crafting action\n    self.distance = distance             -- Maximum distance for action\n    self.forced = forced                 -- Whether action is forced\n    self.rotation = rotation             -- Rotation for action\n    self.arrivedist = arrivedist         -- Distance when arrived at target\nend)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Property"}),(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"doer"})}),(0,a.jsx)(n.td,{children:"Entity"}),(0,a.jsx)(n.td,{children:"The entity performing the action"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"target"})}),(0,a.jsx)(n.td,{children:"Entity"}),(0,a.jsx)(n.td,{children:"The target of the action (can be nil)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"action"})}),(0,a.jsx)(n.td,{children:"Action"}),(0,a.jsx)(n.td,{children:"The action definition containing execution logic"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"invobject"})}),(0,a.jsx)(n.td,{children:"Entity"}),(0,a.jsx)(n.td,{children:"Inventory item being used in the action"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"pos"})}),(0,a.jsx)(n.td,{children:"DynamicPosition"}),(0,a.jsx)(n.td,{children:"Position where action should be performed"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"recipe"})}),(0,a.jsx)(n.td,{children:"String"}),(0,a.jsx)(n.td,{children:"Recipe name for crafting actions"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"distance"})}),(0,a.jsx)(n.td,{children:"Number"}),(0,a.jsx)(n.td,{children:"Maximum distance for action execution"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"forced"})}),(0,a.jsx)(n.td,{children:"Boolean"}),(0,a.jsx)(n.td,{children:"Whether action bypasses normal restrictions"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"rotation"})}),(0,a.jsx)(n.td,{children:"Number"}),(0,a.jsx)(n.td,{children:"Rotation angle for directional actions"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"arrivedist"})}),(0,a.jsx)(n.td,{children:"Number"}),(0,a.jsx)(n.td,{children:'Distance considered "arrived" at target'})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"internal-state-properties",children:"Internal State Properties"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Property"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"initialtargetowner"})}),(0,a.jsx)(n.td,{children:"Original owner of target (for validation)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"doerownsobject"})}),(0,a.jsx)(n.td,{children:"Whether doer owns the inventory object"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"onsuccess"})}),(0,a.jsx)(n.td,{children:"Array of success callback functions"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"onfail"})}),(0,a.jsx)(n.td,{children:"Array of failure callback functions"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"options"})}),(0,a.jsx)(n.td,{children:"Additional action options"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"autoequipped"})}),(0,a.jsx)(n.td,{children:"Whether inventory object was auto-equipped"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"skin"})}),(0,a.jsx)(n.td,{children:"Skin variant for the action"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"validfn"})}),(0,a.jsx)(n.td,{children:"Custom validation function"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"core-methods",children:"Core Methods"}),"\n",(0,a.jsx)(n.h3,{id:"action-execution",children:"Action Execution"}),"\n",(0,a.jsx)(n.h4,{id:"do-method",children:"Do Method"}),"\n",(0,a.jsx)(n.p,{children:"Executes the buffered action with validation and callback handling:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:Do()\n    if not self:IsValid() then\n        return false\n    end\n    \n    local success, reason = self.action.fn(self)\n    if success then\n        if self.invobject ~= nil and self.invobject:IsValid() then\n            self.invobject:OnUsedAsItem(self.action, self.doer, self.target)\n        end\n        self:Succeed()\n    else\n        self:Fail()\n    end\n    return success, reason\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns"}),": ",(0,a.jsx)(n.code,{children:"success"})," (boolean), ",(0,a.jsx)(n.code,{children:"reason"})," (string, optional)"]}),"\n",(0,a.jsx)(n.h3,{id:"validation-system",children:"Validation System"}),"\n",(0,a.jsx)(n.h4,{id:"isvalid-method",children:"IsValid Method"}),"\n",(0,a.jsx)(n.p,{children:"Comprehensive validation of action prerequisites:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:IsValid()\n    return (self.invobject == nil or self.invobject:IsValid()) and\n           (self.doer == nil or (self.doer:IsValid() and \n            (not self.autoequipped or self.doer.replica.inventory:GetActiveItem() == nil))) and\n           (self.target == nil or (self.target:IsValid() and \n            self.initialtargetowner == (self.target.components.inventoryitem ~= nil and \n            self.target.components.inventoryitem.owner or nil))) and\n           (self.pos == nil or self.pos.walkable_platform == nil or \n            self.pos.walkable_platform:IsValid()) and\n           (not self.doerownsobject or (self.doer ~= nil and self.invobject ~= nil and \n            self.invobject.replica.inventoryitem ~= nil and \n            self.invobject.replica.inventoryitem:IsHeldBy(self.doer))) and\n           (self.validfn == nil or self.validfn(self)) and\n           (not TheWorld.ismastersim or (self.action.validfn == nil or self.action.validfn(self)))\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Validation Checks"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Inventory object validity"}),"\n",(0,a.jsx)(n.li,{children:"Doer entity validity and equipment state"}),"\n",(0,a.jsx)(n.li,{children:"Target entity validity and ownership consistency"}),"\n",(0,a.jsx)(n.li,{children:"Position and platform validity"}),"\n",(0,a.jsx)(n.li,{children:"Inventory object ownership"}),"\n",(0,a.jsx)(n.li,{children:"Custom validation functions"}),"\n",(0,a.jsx)(n.li,{children:"Action-specific validation"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"testforstart-method",children:"TestForStart Method"}),"\n",(0,a.jsx)(n.p,{children:"Alias for IsValid method for compatibility:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"BufferedAction.TestForStart = BufferedAction.IsValid\n"})}),"\n",(0,a.jsx)(n.h3,{id:"display-and-debug",children:"Display and Debug"}),"\n",(0,a.jsx)(n.h4,{id:"getactionstring-method",children:"GetActionString Method"}),"\n",(0,a.jsx)(n.p,{children:"Retrieves human-readable action description:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:GetActionString()\n    local str, overriden = nil, nil\n    if self.doer ~= nil and self.doer.ActionStringOverride ~= nil then\n        str, overriden = self.doer:ActionStringOverride(self)\n    end\n    if str ~= nil then\n        return str, overriden\n    elseif self.action.stroverridefn ~= nil then\n        str = self.action.stroverridefn(self)\n        if str ~= nil then\n            return str, true\n        end\n    end\n    return GetActionString(self.action.id, self.action.strfn ~= nil and self.action.strfn(self) or nil)\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Priority Order"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Doer-specific action string override"}),"\n",(0,a.jsx)(n.li,{children:"Action-specific string override function"}),"\n",(0,a.jsx)(n.li,{children:"Standard action string lookup"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"tostring-method",children:"ToString Method"}),"\n",(0,a.jsx)(n.p,{children:"Debug representation of the buffered action:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function BufferedAction:__tostring()\n    return (self:GetActionString().." "..tostring(self.target))\n        ..(self.invobject ~= nil and (" With Inv: "..tostring(self.invobject)) or "")\n        ..(self.recipe ~= nil and (" Recipe: "..self.recipe) or "")\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"callback-management",children:"Callback Management"}),"\n",(0,a.jsx)(n.h4,{id:"addsuccessaction",children:"AddSuccessAction"}),"\n",(0,a.jsx)(n.p,{children:"Registers callback for successful action execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:AddSuccessAction(fn)\n    table.insert(self.onsuccess, fn)\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"addfailaction",children:"AddFailAction"}),"\n",(0,a.jsx)(n.p,{children:"Registers callback for failed action execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:AddFailAction(fn)\n    table.insert(self.onfail, fn)\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"succeed-method",children:"Succeed Method"}),"\n",(0,a.jsx)(n.p,{children:"Executes all success callbacks and cleans up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:Succeed()\n    for k, v in pairs(self.onsuccess) do\n        v()\n    end\n    self.onsuccess = {}\n    self.onfail = {}\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"fail-method",children:"Fail Method"}),"\n",(0,a.jsx)(n.p,{children:"Executes all failure callbacks and cleans up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:Fail()\n    for k,v in pairs(self.onfail) do\n        v()\n    end\n    self.onsuccess = {}\n    self.onfail = {}\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"position-management",children:"Position Management"}),"\n",(0,a.jsx)(n.h4,{id:"getactionpoint",children:"GetActionPoint"}),"\n",(0,a.jsx)(n.p,{children:"Returns static position as Vector3:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:GetActionPoint()\n    -- returns a Vector3 or nil\n    return self.pos ~= nil and self.pos:GetPosition() or nil\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"getdynamicactionpoint",children:"GetDynamicActionPoint"}),"\n",(0,a.jsx)(n.p,{children:"Returns dynamic position object:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:GetDynamicActionPoint()\n    -- returns a DynamicPosition or nil\n    return self.pos\nend\n"})}),"\n",(0,a.jsx)(n.h4,{id:"setactionpoint",children:"SetActionPoint"}),"\n",(0,a.jsx)(n.p,{children:"Sets action position with dynamic positioning:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function BufferedAction:SetActionPoint(pt)\n    self.pos = DynamicPosition(pt)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,a.jsx)(n.h3,{id:"basic-action-creation",children:"Basic Action Creation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create a simple action to chop a tree\nlocal action = ACTIONS.CHOP\nlocal tree = GetClosestEntity(player, 10, nil, {"tree"})\n\nlocal buffered_action = BufferedAction(\n    player,      -- doer\n    tree,        -- target\n    action,      -- action\n    nil,         -- invobject (no tool needed)\n    nil,         -- pos (use target position)\n    nil,         -- recipe\n    nil,         -- distance (use action default)\n    false        -- forced\n)\n\n-- Execute the action\nlocal success = buffered_action:Do()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tool-based-action",children:"Tool-Based Action"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create action using a tool\nlocal axe = player.components.inventory:GetActiveItem()\nlocal tree = GetClosestEntity(player, 10, nil, {"tree"})\n\nif axe and axe:HasTag("axe") then\n    local buffered_action = BufferedAction(\n        player,    -- doer\n        tree,      -- target\n        ACTIONS.CHOP, -- action\n        axe,       -- invobject (tool)\n        nil,       -- pos\n        nil,       -- recipe\n        4,         -- distance (custom range)\n        false      -- forced\n    )\n    \n    -- Add callbacks\n    buffered_action:AddSuccessAction(function()\n        print("Tree chopped successfully!")\n    end)\n    \n    buffered_action:AddFailAction(function()\n        print("Failed to chop tree")\n    end)\n    \n    local success = buffered_action:Do()\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"position-based-action",children:"Position-Based Action"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create action at specific position\nlocal dig_pos = Vector3(100, 0, 50)\nlocal shovel = player.components.inventory:FindItem(function(item)\n    return item:HasTag("shovel")\nend)\n\nif shovel then\n    local buffered_action = BufferedAction(\n        player,           -- doer\n        nil,              -- target (no specific target)\n        ACTIONS.DIG,      -- action\n        shovel,           -- invobject\n        dig_pos,          -- pos (specific position)\n        nil,              -- recipe\n        2,                -- distance\n        false             -- forced\n    )\n    \n    if buffered_action:IsValid() then\n        local success = buffered_action:Do()\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"crafting-action",children:"Crafting Action"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create crafting action\nlocal recipe_name = "axe"\nlocal science_machine = GetClosestEntity(player, 20, nil, {"prototyper"})\n\nlocal buffered_action = BufferedAction(\n    player,           -- doer\n    science_machine,  -- target (crafting station)\n    ACTIONS.BUILD,    -- action\n    nil,              -- invobject\n    nil,              -- pos\n    recipe_name,      -- recipe\n    3,                -- distance\n    false             -- forced\n)\n\n-- Validate before execution\nif buffered_action:IsValid() then\n    local success, reason = buffered_action:Do()\n    if not success then\n        print("Crafting failed:", reason)\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"advanced-action-with-custom-validation",children:"Advanced Action with Custom Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Action with custom validation logic\nlocal buffered_action = BufferedAction(\n    player,\n    target,\n    ACTIONS.PICKUP,\n    nil,\n    nil,\n    nil,\n    2,\n    false\n)\n\n-- Add custom validation\nbuffered_action.validfn = function(action)\n    -- Only allow pickup during day\n    if TheWorld.state.isday then\n        return true\n    else\n        return false, "Can only pickup during day"\n    end\nend\n\n-- Add sophisticated callbacks\nbuffered_action:AddSuccessAction(function()\n    player.components.talker:Say("Got it!")\nend)\n\nbuffered_action:AddFailAction(function()\n    player.components.talker:Say("Can\'t pick that up right now")\nend)\n\nif buffered_action:IsValid() then\n    buffered_action:Do()\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-game-systems",children:"Integration with Game Systems"}),"\n",(0,a.jsx)(n.h3,{id:"component-integration",children:"Component Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Integration with inventory component\nfunction PerformInventoryAction(player, action_id, target)\n    local inventory = player.components.inventory\n    local active_item = inventory:GetActiveItem()\n    \n    local buffered_action = BufferedAction(\n        player,\n        target,\n        ACTIONS[action_id],\n        active_item,\n        nil, nil, nil, false\n    )\n    \n    -- Validate inventory state\n    if active_item and not active_item:IsValid() then\n        return false, "Invalid inventory item"\n    end\n    \n    return buffered_action:Do()\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"locomotor-integration",children:"Locomotor Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Action that requires movement\nfunction ActionWithMovement(player, target, action)\n    local buffered_action = BufferedAction(\n        player, target, action, nil, nil, nil, nil, false\n    )\n    \n    -- Check if player needs to move to target\n    local dist = player:GetDistanceSqToInst(target)\n    if dist > (buffered_action.distance * buffered_action.distance) then\n        -- Queue action after movement\n        player.components.locomotor:GoToEntity(target, nil, true)\n        \n        -- Defer action execution\n        player:DoTaskInTime(1.0, function()\n            if buffered_action:IsValid() then\n                buffered_action:Do()\n            end\n        end)\n    else\n        -- Execute immediately\n        return buffered_action:Do()\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"state-graph-integration",children:"State Graph Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Action that triggers animation\nfunction AnimatedAction(player, action, target)\n    local buffered_action = BufferedAction(\n        player, target, action, nil, nil, nil, nil, false\n    )\n    \n    -- Play animation before action\n    if player.components.stategraph then\n        player.components.stategraph:PushEvent("startaction", {\n            action = buffered_action\n        })\n    end\n    \n    -- Add animation callback\n    buffered_action:AddSuccessAction(function()\n        if player.components.stategraph then\n            player.components.stategraph:PushEvent("actioncomplete")\n        end\n    end)\n    \n    return buffered_action\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,a.jsx)(n.h3,{id:"validation-debugging",children:"Validation Debugging"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function DebugBufferedAction(buffered_action)\n    print("=== Buffered Action Debug ===")\n    print("Action:", buffered_action.action.id)\n    print("Doer:", buffered_action.doer)\n    print("Target:", buffered_action.target)\n    print("Inventory Object:", buffered_action.invobject)\n    print("Position:", buffered_action.pos)\n    print("Recipe:", buffered_action.recipe)\n    print("Valid:", buffered_action:IsValid())\n    \n    -- Test individual validation components\n    if buffered_action.doer and not buffered_action.doer:IsValid() then\n        print("ERROR: Invalid doer")\n    end\n    \n    if buffered_action.target and not buffered_action.target:IsValid() then\n        print("ERROR: Invalid target")\n    end\n    \n    if buffered_action.invobject and not buffered_action.invobject:IsValid() then\n        print("ERROR: Invalid inventory object")\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"safe-action-execution",children:"Safe Action Execution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function SafeExecuteAction(buffered_action)\n    local success, error_msg = pcall(function()\n        if not buffered_action:IsValid() then\n            return false, "Action validation failed"\n        end\n        \n        return buffered_action:Do()\n    end)\n    \n    if not success then\n        print("Action execution error:", error_msg)\n        buffered_action:Fail()\n        return false\n    end\n    \n    return success\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"action-queue-management",children:"Action Queue Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Simple action queue system\nlocal ActionQueue = Class(function(self)\n    self.queue = {}\n    self.processing = false\nend)\n\nfunction ActionQueue:Add(buffered_action)\n    table.insert(self.queue, buffered_action)\nend\n\nfunction ActionQueue:ProcessNext()\n    if self.processing or #self.queue == 0 then\n        return\n    end\n    \n    self.processing = true\n    local action = table.remove(self.queue, 1)\n    \n    -- Add completion callback to process next action\n    action:AddSuccessAction(function()\n        self.processing = false\n        self:ProcessNext()\n    end)\n    \n    action:AddFailAction(function()\n        self.processing = false\n        self:ProcessNext()\n    end)\n    \n    if action:IsValid() then\n        action:Do()\n    else\n        action:Fail()\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"action-validation-optimization",children:"Action Validation Optimization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Cache validation results for expensive checks\nfunction OptimizedBufferedAction(doer, target, action, invobject)\n    local buffered_action = BufferedAction(doer, target, action, invobject)\n    \n    -- Cache validation state\n    local last_validation_time = 0\n    local cached_validity = nil\n    \n    local original_isvalid = buffered_action.IsValid\n    buffered_action.IsValid = function(self)\n        local current_time = GetTime()\n        \n        -- Use cached result if recent\n        if current_time - last_validation_time < 0.1 and cached_validity ~= nil then\n            return cached_validity\n        end\n        \n        -- Perform full validation\n        cached_validity = original_isvalid(self)\n        last_validation_time = current_time\n        \n        return cached_validity\n    end\n    \n    return buffered_action\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Proper cleanup for long-lived actions\nfunction CreateManagedAction(doer, target, action, invobject)\n    local buffered_action = BufferedAction(doer, target, action, invobject)\n    \n    -- Track for cleanup\n    local cleanup_callbacks = {}\n    \n    local original_succeed = buffered_action.Succeed\n    buffered_action.Succeed = function(self)\n        original_succeed(self)\n        -- Cleanup managed resources\n        for _, cleanup in ipairs(cleanup_callbacks) do\n            cleanup()\n        end\n    end\n    \n    local original_fail = buffered_action.Fail\n    buffered_action.Fail = function(self)\n        original_fail(self)\n        -- Cleanup managed resources\n        for _, cleanup in ipairs(cleanup_callbacks) do\n            cleanup()\n        end\n    end\n    \n    -- Add cleanup function\n    buffered_action.AddCleanup = function(self, fn)\n        table.insert(cleanup_callbacks, fn)\n    end\n    \n    return buffered_action\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"design-guidelines",children:"Design Guidelines"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate Early"}),": Always check ",(0,a.jsx)(n.code,{children:"IsValid()"})," before executing actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use Callbacks"}),": Leverage success/failure callbacks for robust handling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Preserve Context"}),": Include all necessary information in action creation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle Failures"}),": Always provide meaningful failure handling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clean Up"}),": Ensure callbacks and references are properly cleaned up"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cache validation results for expensive checks"}),"\n",(0,a.jsx)(n.li,{children:"Avoid creating unnecessary buffered actions"}),"\n",(0,a.jsx)(n.li,{children:"Clean up callback functions to prevent memory leaks"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate distance and timing parameters"}),"\n",(0,a.jsx)(n.li,{children:"Consider using action queues for multiple actions"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"integration-guidelines",children:"Integration Guidelines"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Work with component systems for state validation"}),"\n",(0,a.jsx)(n.li,{children:"Integrate with locomotor for movement-based actions"}),"\n",(0,a.jsx)(n.li,{children:"Coordinate with state graphs for animation timing"}),"\n",(0,a.jsx)(n.li,{children:"Use event system for action completion notifications"}),"\n",(0,a.jsx)(n.li,{children:"Respect game state for multiplayer compatibility"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-systems",children:"Related Systems"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/actions",children:"Actions"})," - Action definitions that buffered actions execute"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../components/index.md",children:"Components"})," - Entity components that actions interact with"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./brain.md",children:"Brain System"})," - AI system that uses buffered actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../stategraphs/index.md",children:"State Graphs"})," - Animation system coordinated with actions"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"status--stable",children:"Status: \ud83d\udfe2 Stable"}),"\n",(0,a.jsx)(n.p,{children:"The Buffered Action system is stable and fundamental to DST's action execution architecture. The API is mature with minimal changes focusing on performance optimizations and edge case handling."})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);