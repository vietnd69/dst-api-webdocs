"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5425],{700:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>f,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-vanilla/examples/optimization","title":"Performance Optimization","description":"This guide covers techniques for optimizing your Don\'t Starve Together mods to ensure they run efficiently without causing lag or performance issues.","source":"@site/docs/api-vanilla/examples/optimization.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/optimization","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/optimization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"optimization","title":"Performance Optimization","sidebar_position":10},"sidebar":"docs","previous":{"title":"World Generation","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/worldgen-mod"},"next":{"title":"Networking and Multiplayer","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/networking-mod"}}');var s=i(4848),a=i(8453);const l={id:"optimization",title:"Performance Optimization",sidebar_position:10},r="Performance Optimization Techniques",o={},c=[{value:"Understanding Performance Concerns",id:"understanding-performance-concerns",level:2},{value:"Key Areas for Optimization",id:"key-areas-for-optimization",level:2},{value:"1. Update Functions",id:"1-update-functions",level:3},{value:"2. Entity Searches",id:"2-entity-searches",level:3},{value:"3. Event Handling",id:"3-event-handling",level:3},{value:"4. Memory Management",id:"4-memory-management",level:3},{value:"5. Network Optimization",id:"5-network-optimization",level:3},{value:"Practical Optimization Example: Area Effect System",id:"practical-optimization-example-area-effect-system",level:2},{value:"Unoptimized Version",id:"unoptimized-version",level:3},{value:"Optimized Version",id:"optimized-version",level:3},{value:"Profiling and Debugging",id:"profiling-and-debugging",level:2},{value:"1. In-Game Profiling",id:"1-in-game-profiling",level:3},{value:"2. Frame Time Logging",id:"2-frame-time-logging",level:3},{value:"3. Memory Usage Tracking",id:"3-memory-usage-tracking",level:3},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Case Study: Optimizing a Weather Effect Mod",id:"case-study-optimizing-a-weather-effect-mod",level:2},{value:"Original Implementation",id:"original-implementation",level:3},{value:"Optimized Implementation",id:"optimized-implementation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"performance-optimization-techniques",children:"Performance Optimization Techniques"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers techniques for optimizing your Don't Starve Together mods to ensure they run efficiently without causing lag or performance issues."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-performance-concerns",children:"Understanding Performance Concerns"}),"\n",(0,s.jsx)(n.p,{children:"Performance is critical in Don't Starve Together mods for several reasons:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The game must maintain a steady frame rate across various hardware"}),"\n",(0,s.jsx)(n.li,{children:"In multiplayer, poor optimization can affect all connected players"}),"\n",(0,s.jsx)(n.li,{children:"Complex mods can significantly impact server performance"}),"\n",(0,s.jsx)(n.li,{children:"Performance issues compound when multiple mods are installed"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-areas-for-optimization",children:"Key Areas for Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"1-update-functions",children:"1. Update Functions"}),"\n",(0,s.jsx)(n.p,{children:"One of the most common performance issues comes from inefficient update functions that run frequently:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Running expensive operations every frame\nfunction Component:OnUpdate(dt)\n    -- This runs every frame (potentially 60 times per second)\n    local entities = TheSim:FindEntities(x, y, z, 30, nil, {"INLIMBO"})\n    for _, ent in ipairs(entities) do\n        -- Complex calculations for each entity\n        self:ProcessEntity(ent)\n    end\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Using periodic tasks instead of every-frame updates\nfunction Component:Init()\n    -- Run expensive operations less frequently\n    self.task = self.inst:DoPeriodicTask(0.5, function() \n        local entities = TheSim:FindEntities(x, y, z, 30, nil, {"INLIMBO"})\n        for _, ent in ipairs(entities) do\n            self:ProcessEntity(ent)\n        end\n    end)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-entity-searches",children:"2. Entity Searches"}),"\n",(0,s.jsx)(n.p,{children:"Finding entities is an expensive operation, especially with large search radii:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Large radius, no necessary tags\nlocal entities = TheSim:FindEntities(x, y, z, 50)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Smaller radius, specific tags, excluded tags\nlocal entities = TheSim:FindEntities(x, y, z, 20, {"_combat"}, {"INLIMBO", "player", "wall"})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-event-handling",children:"3. Event Handling"}),"\n",(0,s.jsx)(n.p,{children:"Excessive event listeners can cause performance issues:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Listening to frequent events on many entities\nfor i = 1, 1000 do\n    local inst = SpawnPrefab("prefab")\n    inst:ListenForEvent("entitysleep", OnEntitySleep)\n    inst:ListenForEvent("entitywake", OnEntityWake)\n    inst:ListenForEvent("onremove", OnRemove)\n    -- More event listeners...\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Use component system and targeted events\nfunction MyComponent:OnRemove()\n    -- Clean up event listeners when removed\n    if self.task then\n        self.task:Cancel()\n        self.task = nil\n    end\n    \n    if self.eventhook then\n        self.inst:RemoveEventCallback("entitysleep", self.eventhook)\n        self.eventhook = nil\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-memory-management",children:"4. Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"Poor memory management can lead to leaks and degraded performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Creating new tables constantly\nfunction OnUpdate()\n    local data = {}\n    -- Fill data\n    return data\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Reuse tables\nlocal data_pool = {}\n\nfunction GetDataFromPool()\n    local t = table.remove(data_pool) or {}\n    return t\nend\n\nfunction RecycleData(t)\n    table.clear(t)\n    table.insert(data_pool, t)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-network-optimization",children:"5. Network Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Networking is a critical area for optimization in multiplayer games:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Sending updates too frequently\nfunction Component:OnUpdate()\n    if TheWorld.ismastersim then\n        -- Send full state every frame\n        SendModRPCToClient(GetClientModRPC("MyMod", "SyncData"), player.userid, self.inst.GUID, json.encode(self.data))\n    end\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Throttle updates and only send changes\nfunction Component:Init()\n    self.last_sync_time = 0\n    self.dirty = false\n    \n    self.inst:DoPeriodicTask(0.1, function()\n        if TheWorld.ismastersim and self.dirty and (self.last_sync_time + 0.5) < GetTime() then\n            -- Only send if data changed and not too recently\n            SendModRPCToClient(GetClientModRPC("MyMod", "SyncData"), player.userid, self.inst.GUID, json.encode(self.data))\n            self.last_sync_time = GetTime()\n            self.dirty = false\n        end\n    end)\nend\n\nfunction Component:SetValue(key, value)\n    if self.data[key] ~= value then\n        self.data[key] = value\n        self.dirty = true\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-optimization-example-area-effect-system",children:"Practical Optimization Example: Area Effect System"}),"\n",(0,s.jsx)(n.p,{children:"Let's optimize a system that applies effects to entities in an area:"}),"\n",(0,s.jsx)(n.h3,{id:"unoptimized-version",children:"Unoptimized Version"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"local AreaEffectComponent = Class(function(self, inst)\n    self.inst = inst\n    self.radius = 10\n    self.effect_fn = nil\n    \n    -- Update every frame\n    self.inst:DoTaskInTime(0, function()\n        self.updatetask = self.inst:DoPeriodicTask(0, function() self:ApplyEffect() end)\n    end)\nend)\n\nfunction AreaEffectComponent:ApplyEffect()\n    if not self.effect_fn then return end\n    \n    -- Find all entities every frame\n    local x, y, z = self.inst.Transform:GetWorldPosition()\n    local entities = TheSim:FindEntities(x, y, z, self.radius)\n    \n    -- Process each entity\n    for _, ent in ipairs(entities) do\n        self.effect_fn(ent)\n    end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optimized-version",children:"Optimized Version"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local AreaEffectComponent = Class(function(self, inst)\n    self.inst = inst\n    self.radius = 10\n    self.effect_fn = nil\n    self.affected_entities = {}\n    self.update_frequency = 0.5\n    \n    -- Start with a small delay to ensure all components are initialized\n    self.inst:DoTaskInTime(0.1, function()\n        -- Update less frequently\n        self.updatetask = self.inst:DoPeriodicTask(self.update_frequency, function() self:UpdateNearbyEntities() end)\n    end)\n    \n    -- Listen for removal to clean up\n    self.inst:ListenForEvent("onremove", function() self:OnRemove() end)\nend)\n\nfunction AreaEffectComponent:UpdateNearbyEntities()\n    local x, y, z = self.inst.Transform:GetWorldPosition()\n    \n    -- Use tags to filter entities more efficiently\n    local entities = TheSim:FindEntities(x, y, z, self.radius, nil, {"INLIMBO", "notarget"})\n    \n    -- Track which entities we\'ve seen this update\n    local seen_entities = {}\n    \n    -- Process only entities that need the effect\n    for _, ent in ipairs(entities) do\n        seen_entities[ent] = true\n        \n        -- Only apply effect if not already affected\n        if not self.affected_entities[ent] and self.effect_fn then\n            self.effect_fn(ent)\n            self.affected_entities[ent] = true\n            \n            -- Listen for entity removal to clean up our references\n            self.inst:ListenForEvent("onremove", function() \n                self.affected_entities[ent] = nil \n            end, ent)\n        end\n    end\n    \n    -- Remove effects from entities no longer in range\n    for ent in pairs(self.affected_entities) do\n        if not seen_entities[ent] then\n            -- Entity left radius, remove effect\n            if self.remove_effect_fn then\n                self.remove_effect_fn(ent)\n            end\n            self.affected_entities[ent] = nil\n        end\n    end\nend\n\nfunction AreaEffectComponent:OnRemove()\n    -- Clean up tasks\n    if self.updatetask then\n        self.updatetask:Cancel()\n        self.updatetask = nil\n    end\n    \n    -- Remove effects from all affected entities\n    if self.remove_effect_fn then\n        for ent in pairs(self.affected_entities) do\n            self.remove_effect_fn(ent)\n        end\n    end\n    \n    -- Clear table references\n    self.affected_entities = {}\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"profiling-and-debugging",children:"Profiling and Debugging"}),"\n",(0,s.jsx)(n.p,{children:"To identify performance bottlenecks, use these techniques:"}),"\n",(0,s.jsx)(n.h3,{id:"1-in-game-profiling",children:"1. In-Game Profiling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Add profiling to your mod\nlocal profile_start = os.clock()\n\n-- Code to profile\nlocal result = ExpensiveFunction()\n\nlocal duration = os.clock() - profile_start\nprint("Function took " .. duration .. " seconds")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-frame-time-logging",children:"2. Frame Time Logging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Log frame times to identify spikes\nlocal last_time = GetTime()\n\nAddPriorityPostInit(function()\n    -- Add a periodic task to check frame times\n    TheWorld:DoPeriodicTask(1, function()\n        local current_time = GetTime()\n        local frame_count = TheSim:GetFPS()\n        print("FPS: " .. frame_count .. ", Average frame time: " .. (1000/frame_count) .. "ms")\n        last_time = current_time\n    end)\nend)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-memory-usage-tracking",children:"3. Memory Usage Tracking"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Track memory usage\nlocal function GetMemoryUsage()\n    collectgarbage("collect")\n    return math.floor(collectgarbage("count"))\nend\n\nlocal initial_memory = GetMemoryUsage()\n\n-- After operations\nlocal current_memory = GetMemoryUsage()\nprint("Memory change: " .. (current_memory - initial_memory) .. " KB")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,s.jsx)(n.p,{children:"Use this checklist to ensure your mod is optimized:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Update Frequency"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use appropriate update intervals (not every frame)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Scale update frequency based on importance"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Consider using event-based updates instead of periodic when possible"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Entity Management"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Limit entity searches with appropriate tags and radius"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cache entity references when appropriate"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Clean up references when entities are removed"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Memory Usage"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Reuse tables and objects when possible"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Clear references in OnRemove functions"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Be careful with closures that capture large environments"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Network Optimization"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Only send data when it changes"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Throttle network updates"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Send delta updates instead of full state when possible"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Event Handling"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Remove event listeners when no longer needed"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use targeted events instead of global ones"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Avoid creating multiple listeners for the same event"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"case-study-optimizing-a-weather-effect-mod",children:"Case Study: Optimizing a Weather Effect Mod"}),"\n",(0,s.jsx)(n.p,{children:"Let's examine a real-world optimization of a weather effect mod:"}),"\n",(0,s.jsx)(n.h3,{id:"original-implementation",children:"Original Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Weather effect that spawns particles and affects players\nlocal WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    self.particles = {}\n    self.max_particles = 100\n    self.player_effect_radius = 30\n    \n    -- Update particles every frame\n    self.inst:DoPeriodicTask(0, function() self:UpdateParticles() end)\n    \n    -- Apply player effects every frame\n    self.inst:DoPeriodicTask(0, function() self:ApplyPlayerEffects() end)\nend)\n\nfunction WeatherSystem:UpdateParticles()\n    -- Spawn new particles\n    while #self.particles < self.max_particles do\n        local particle = self:SpawnParticle()\n        table.insert(self.particles, particle)\n    end\n    \n    -- Update all particles\n    for i, particle in ipairs(self.particles) do\n        if not self:UpdateParticle(particle) then\n            particle:Remove()\n            table.remove(self.particles, i)\n        end\n    end\nend\n\nfunction WeatherSystem:ApplyPlayerEffects()\n    -- Find all players\n    for _, player in ipairs(AllPlayers) do\n        -- Apply effects\n        self:ApplyEffectToPlayer(player)\n    end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optimized-implementation",children:"Optimized Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    self.particles = {}\n    self.max_particles = 100\n    self.player_effect_radius = 30\n    self.particle_batch_size = 5\n    self.affected_players = {}\n    \n    -- Update particles in batches and less frequently\n    self.inst:DoPeriodicTask(0.1, function() self:UpdateParticles() end)\n    \n    -- Apply player effects less frequently\n    self.inst:DoPeriodicTask(0.5, function() self:ApplyPlayerEffects() end)\n    \n    -- Clean up on removal\n    self.inst:ListenForEvent("onremove", function() self:OnRemove() end)\nend)\n\nfunction WeatherSystem:UpdateParticles()\n    -- Spawn particles in small batches\n    local particles_to_spawn = math.min(self.particle_batch_size, self.max_particles - #self.particles)\n    for i = 1, particles_to_spawn do\n        local particle = self:SpawnParticle()\n        table.insert(self.particles, particle)\n    end\n    \n    -- Update only a subset of particles each frame\n    local start_index = self.last_updated_index or 1\n    local end_index = math.min(start_index + 20, #self.particles)\n    \n    for i = start_index, end_index do\n        local particle = self.particles[i]\n        if particle and particle:IsValid() then\n            if not self:UpdateParticle(particle) then\n                particle:Remove()\n                table.remove(self.particles, i)\n            end\n        else\n            table.remove(self.particles, i)\n        end\n    end\n    \n    -- Update index for next time\n    self.last_updated_index = end_index >= #self.particles and 1 or end_index + 1\nend\n\nfunction WeatherSystem:ApplyPlayerEffects()\n    -- Only process players that need updates\n    for _, player in ipairs(AllPlayers) do\n        local player_id = player.userid\n        \n        -- Check if player is in the affected area\n        if self:IsPlayerInEffectArea(player) then\n            -- Only apply if not already affected\n            if not self.affected_players[player_id] then\n                self:ApplyEffectToPlayer(player)\n                self.affected_players[player_id] = true\n                \n                -- Listen for player leaving\n                self.inst:ListenForEvent("onremove", function()\n                    self.affected_players[player_id] = nil\n                end, player)\n            end\n        else\n            -- Remove effect if player left the area\n            if self.affected_players[player_id] then\n                self:RemoveEffectFromPlayer(player)\n                self.affected_players[player_id] = nil\n            end\n        end\n    end\nend\n\nfunction WeatherSystem:OnRemove()\n    -- Clean up all particles\n    for _, particle in ipairs(self.particles) do\n        if particle:IsValid() then\n            particle:Remove()\n        end\n    end\n    self.particles = {}\n    \n    -- Remove effects from all players\n    for player_id, _ in pairs(self.affected_players) do\n        local player = UserToPlayer(player_id)\n        if player then\n            self:RemoveEffectFromPlayer(player)\n        end\n    end\n    self.affected_players = {}\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Optimizing your mods is essential for providing a good experience to players. By following these techniques, you can create complex mods that run efficiently even on lower-end hardware and servers."}),"\n",(0,s.jsx)(n.p,{children:"Remember these key principles:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only update what needs updating, when it needs updating"}),"\n",(0,s.jsx)(n.li,{children:"Be mindful of expensive operations like entity searches"}),"\n",(0,s.jsx)(n.li,{children:"Clean up after yourself to prevent memory leaks"}),"\n",(0,s.jsx)(n.li,{children:"Use network bandwidth efficiently"}),"\n",(0,s.jsx)(n.li,{children:"Profile your code to identify bottlenecks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By applying these optimization techniques, you'll create mods that players can enjoy without sacrificing performance."})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);