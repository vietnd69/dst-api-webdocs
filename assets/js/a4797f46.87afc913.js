"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[6461],{2171:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"api-vanilla/core/physics","title":"Physics System","description":"Last Update: 2023-07-12","source":"@site/docs/api-vanilla/core/physics.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/physics","permalink":"/dst-api-webdocs/docs/api-vanilla/core/physics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"physics","title":"Physics System","sidebar_position":6,"last_updated":"2023-07-12T00:00:00.000Z","version":619045}}');var t=n(4848),o=n(8453);const l={id:"physics",title:"Physics System",sidebar_position:6,last_updated:new Date("2023-07-12T00:00:00.000Z"),version:619045},c="Physics System",r={},a=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Core Physics Types",id:"core-physics-types",level:2},{value:"Static Physics",id:"static-physics",level:3},{value:"Dynamic Physics",id:"dynamic-physics",level:3},{value:"Inventory Physics",id:"inventory-physics",level:3},{value:"Collision Management",id:"collision-management",level:2},{value:"Collision Groups and Masks",id:"collision-groups-and-masks",level:3},{value:"Collision Shapes",id:"collision-shapes",level:3},{value:"Movement and Forces",id:"movement-and-forces",level:2},{value:"Position Control",id:"position-control",level:3},{value:"Velocity Control",id:"velocity-control",level:3},{value:"Continuous Forces",id:"continuous-forces",level:3},{value:"Physics Events",id:"physics-events",level:2},{value:"Integration with Other Systems",id:"integration-with-other-systems",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Character Movement",id:"character-movement",level:3},{value:"Projectile Physics",id:"projectile-physics",level:3},{value:"Physics Interactions",id:"physics-interactions",level:3},{value:"Sensor Zones",id:"sensor-zones",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See also",id:"see-also",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.em,{children:"Last Update: 2023-07-12"})}),"\n",(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"physics-system",children:"Physics System"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.em,{children:"API Version: 619045"})}),"\n",(0,t.jsx)(s.p,{children:"The Physics system in Don't Starve Together handles physical interactions between entities, including collision detection, movement constraints, and physical forces. It's essential for realistic entity behavior in the game world."}),"\n",(0,t.jsx)(s.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Add physics to an entity\nentity.entity:AddPhysics()\n\n-- Configure the physics\nentity.Physics:SetMass(10)\nentity.Physics:SetFriction(0.5)\nentity.Physics:SetCollisionGroup(COLLISION.CHARACTERS)\nentity.Physics:SetCollisionMask(COLLISION.WORLD + COLLISION.OBSTACLES)\nentity.Physics:SetCylinder(0.5, 1)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"core-physics-types",children:"Core Physics Types"}),"\n",(0,t.jsx)(s.p,{children:"DST supports several types of physics objects:"}),"\n",(0,t.jsx)(s.h3,{id:"static-physics",children:"Static Physics"}),"\n",(0,t.jsx)(s.p,{children:"Used for immobile objects like structures and terrain features:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Set up static physics\nentity.Physics:SetMass(0) -- Infinite mass (immovable)\nentity.Physics:SetCollisionGroup(COLLISION.OBSTACLES)\nentity.Physics:SetCylinder(1, 2) -- radius, height\n"})}),"\n",(0,t.jsx)(s.h3,{id:"dynamic-physics",children:"Dynamic Physics"}),"\n",(0,t.jsx)(s.p,{children:"Used for objects that should move and be affected by forces:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Set up dynamic physics\nentity.Physics:SetMass(10)\nentity.Physics:SetFriction(0.7)\nentity.Physics:SetDamping(5)\nentity.Physics:SetCollisionGroup(COLLISION.CHARACTERS)\nentity.Physics:SetCollisionMask(COLLISION.WORLD + COLLISION.OBSTACLES)\nentity.Physics:SetCylinder(0.5, 1)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"inventory-physics",children:"Inventory Physics"}),"\n",(0,t.jsx)(s.p,{children:"Special physics for inventory items:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Common helper function\nMakeInventoryPhysics(inst)\n\n-- Manual setup\nentity.Physics:SetMass(1)\nentity.Physics:SetFriction(0)\nentity.Physics:SetDamping(5)\nentity.Physics:SetCollisionGroup(COLLISION.ITEMS)\nentity.Physics:SetCollisionMask(COLLISION.WORLD)\nentity.Physics:SetSphere(0.5)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"collision-management",children:"Collision Management"}),"\n",(0,t.jsx)(s.h3,{id:"collision-groups-and-masks",children:"Collision Groups and Masks"}),"\n",(0,t.jsx)(s.p,{children:"Collision groups and masks control which objects can collide with each other:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Common collision groups\nCOLLISION = {\n    NONE = 0,\n    OBSTACLES = 2^0,  -- Structures, trees, etc.\n    CHARACTERS = 2^1, -- Players and creatures\n    WORLD = 2^2,      -- Ground and immovable world objects\n    ITEMS = 2^3,      -- Pickable items\n    GIANTS = 2^4,     -- Boss monsters\n    FLYERS = 2^5      -- Flying entities\n}\n\n-- Set which group this entity belongs to\nentity.Physics:SetCollisionGroup(COLLISION.CHARACTERS)\n\n-- Set which groups this entity collides with\nentity.Physics:SetCollisionMask(COLLISION.WORLD + COLLISION.OBSTACLES + COLLISION.CHARACTERS)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"collision-shapes",children:"Collision Shapes"}),"\n",(0,t.jsx)(s.p,{children:"Different collision shapes can be used for different entity types:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Cylinder shape (most common for characters)\nentity.Physics:SetCylinder(0.5, 1) -- radius, height\n\n-- Sphere shape (common for items)\nentity.Physics:SetSphere(0.5) -- radius\n\n-- Box shape (for structures)\nentity.Physics:SetBox(1, 2, 1) -- width, height, depth\n\n-- Capsule shape (for some creatures)\nentity.Physics:SetCapsule(0.5, 1) -- radius, height\n"})}),"\n",(0,t.jsx)(s.h2,{id:"movement-and-forces",children:"Movement and Forces"}),"\n",(0,t.jsx)(s.h3,{id:"position-control",children:"Position Control"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Teleport physics object (instantaneous movement)\nentity.Physics:Teleport(x, y, z)\n\n-- Get current position\nlocal x, y, z = entity.Physics:GetPosition()\n\n-- Stop all movement immediately\nentity.Physics:Stop()\n"})}),"\n",(0,t.jsx)(s.h3,{id:"velocity-control",children:"Velocity Control"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Set velocity directly\nentity.Physics:SetVel(x, y, z)\n\n-- Get current velocity\nlocal vx, vy, vz = entity.Physics:GetVelocity()\n\n-- Apply impulse force (immediate velocity change)\nentity.Physics:SetMotorVel(5, 0, 0) -- Move right at 5 units/sec\n"})}),"\n",(0,t.jsx)(s.h3,{id:"continuous-forces",children:"Continuous Forces"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Apply continuous force\nentity.Physics:ApplyForce(10, 0, 0) -- 10 units force to the right\n\n-- Apply continuous torque (rotational force)\nentity.Physics:ApplyTorque(5) -- Rotate with force of 5\n"})}),"\n",(0,t.jsx)(s.h2,{id:"physics-events",children:"Physics Events"}),"\n",(0,t.jsx)(s.p,{children:"Physics can trigger events when certain conditions are met:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:'-- Listen for collision events\nentity:ListenForEvent("physics_collision", function(inst, data)\n    local other = data.other -- The entity we collided with\n    local speed = data.speed -- Speed of collision\n    \n    if speed > 3 then\n        -- Handle high-speed collision\n    end\nend)\n'})}),"\n",(0,t.jsx)(s.h2,{id:"integration-with-other-systems",children:"Integration with Other Systems"}),"\n",(0,t.jsx)(s.p,{children:"The Physics system works closely with:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Transform"}),": For updating visual position based on physics"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"AnimState"}),": For aligning visuals with collision shapes"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Locomotor"}),": For movement with terrain awareness"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Combat"}),": For knockback and collision damage"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,t.jsx)(s.h3,{id:"character-movement",children:"Character Movement"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"local function SetupPlayerPhysics(inst)\n    inst.entity:AddPhysics()\n    inst.Physics:SetMass(75)\n    inst.Physics:SetFriction(0.1)\n    inst.Physics:SetDamping(5)\n    inst.Physics:SetCollisionGroup(COLLISION.CHARACTERS)\n    inst.Physics:SetCollisionMask(COLLISION.WORLD + COLLISION.OBSTACLES + COLLISION.CHARACTERS)\n    inst.Physics:SetCylinder(0.5, 1)\nend\n"})}),"\n",(0,t.jsx)(s.h3,{id:"projectile-physics",children:"Projectile Physics"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"local function LaunchProjectile(inst, angle, speed)\n    -- Set up physics for a projectile\n    inst.entity:AddPhysics()\n    inst.Physics:SetMass(1)\n    inst.Physics:SetFriction(0)\n    inst.Physics:SetDamping(0.5)\n    inst.Physics:SetCollisionGroup(COLLISION.ITEMS)\n    inst.Physics:SetCollisionMask(COLLISION.WORLD + COLLISION.OBSTACLES + COLLISION.CHARACTERS)\n    inst.Physics:SetSphere(0.2)\n    \n    -- Launch in specified direction\n    local vx = speed * math.cos(angle * DEGREES)\n    local vz = -speed * math.sin(angle * DEGREES)\n    inst.Physics:SetVel(vx, 3, vz) -- Add upward velocity for arc\n    \n    -- Apply gravity\n    inst:DoPeriodicTask(FRAMES, function(inst)\n        local vx, vy, vz = inst.Physics:GetVelocity()\n        inst.Physics:SetVel(vx, vy - 0.1, vz) -- Apply gravity\n    end)\nend\n"})}),"\n",(0,t.jsx)(s.h3,{id:"physics-interactions",children:"Physics Interactions"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"-- Knockback effect\nlocal function ApplyKnockback(target, source_pos, force)\n    if target.Physics ~= nil then\n        local target_pos = target:GetPosition()\n        local angle = math.atan2(target_pos.z - source_pos.z, target_pos.x - source_pos.x)\n        local vx = force * math.cos(angle)\n        local vz = force * math.sin(angle)\n        \n        target.Physics:SetVel(vx, 2, vz)\n    end\nend\n"})}),"\n",(0,t.jsx)(s.h3,{id:"sensor-zones",children:"Sensor Zones"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:'local function CreateSensorZone(center_pos, radius)\n    local inst = CreateEntity()\n    \n    inst.entity:AddTransform()\n    inst.entity:AddPhysics()\n    \n    -- Make it invisible but with physics\n    inst.Transform:SetPosition(center_pos.x, 0, center_pos.z)\n    inst.Physics:SetMass(0) -- Immovable\n    inst.Physics:SetCollisionGroup(COLLISION.NONE)\n    inst.Physics:SetCollisionMask(COLLISION.CHARACTERS) -- Only detect characters\n    inst.Physics:SetSphere(radius)\n    inst.Physics:SetSensor(true) -- Will detect but not block\n    \n    -- Set up detection\n    inst:DoPeriodicTask(0.1, function(inst)\n        local x, y, z = inst.Transform:GetWorldPosition()\n        local ents = TheSim:FindEntities(x, y, z, radius, {"player"})\n        \n        for _, player in ipairs(ents) do\n            -- Player is in sensor zone\n            if not inst.detected_players[player] then\n                -- New entry into zone\n                inst.detected_players[player] = true\n                inst:PushEvent("player_enter", {player = player})\n            end\n        end\n        \n        -- Check for players who left\n        for player, _ in pairs(inst.detected_players) do\n            if not table.contains(ents, player) then\n                -- Player left zone\n                inst.detected_players[player] = nil\n                inst:PushEvent("player_exit", {player = player})\n            end\n        end\n    end)\n    \n    inst.detected_players = {}\n    \n    return inst\nend\n'})}),"\n",(0,t.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Minimize Moving Physics Objects"}),": Each moving physics object requires computation"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use Appropriate Collision Groups"}),": Avoid unnecessary collision checks"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Simplify Collision Shapes"}),": Use simple shapes when possible"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Limit Continuous Forces"}),": Apply forces only when necessary"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use Sensors for Detection"}),": Prefer sensors over regular collision for detection zones"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Choose the Right Collision Shape"}),": Match collision shape to visual appearance"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Handle Cleanup"}),": Reset forces and velocities when switching states"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Avoid Physics Overlap"}),": Multiple physics entities inside each other can cause instability"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Balance Realism and Performance"}),": Use simplified physics when appropriate"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Test with Different Clients"}),": Physics can behave slightly differently between clients"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"see-also",children:"See also"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/entity-system",children:"Entity System"})," - For the overall entity framework"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/dst-api-webdocs/docs/api-vanilla/shared-properties/transform",children:"Transform"})," - For positioning physics entities"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/dst-api-webdocs/docs/api-vanilla/components/locomotor",children:"Locomotor"})," - For higher-level movement with physics"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/animstate-system",children:"AnimState"})," - For visual representation of physical entities"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," - For multiplayer physics considerations"]}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>c});var i=n(6540);const t={},o=i.createContext(t);function l(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);