"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[8338],{6859:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"api-vanilla/core/rpc-system","title":"Remote Procedure Call System","description":"Remote Procedure Calls (RPCs) are a core feature of Don\'t Starve Together\'s networking architecture, enabling bidirectional communication between server and clients. Unlike network variables which are unidirectional (server to client), RPCs allow clients to send commands to the server and the server to send commands to specific clients.","source":"@site/docs/api-vanilla/core/rpc-system.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/rpc-system","permalink":"/dst-api-webdocs/docs/api-vanilla/core/rpc-system","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"rpc-system","title":"Remote Procedure Call System","sidebar_position":7},"sidebar":"docs","previous":{"title":"Network System","permalink":"/dst-api-webdocs/docs/api-vanilla/core/network-system"},"next":{"title":"Mod Structure and Server Integration","permalink":"/dst-api-webdocs/docs/api-vanilla/core/mod-structure"}}');var a=t(4848),i=t(8453);const s={id:"rpc-system",title:"Remote Procedure Call System",sidebar_position:7},l="Remote Procedure Call System",d={},o=[{value:"RPC Overview",id:"rpc-overview",level:2},{value:"RPC Directions",id:"rpc-directions",level:2},{value:"Built-in RPC Categories",id:"built-in-rpc-categories",level:2},{value:"Defining Custom RPCs",id:"defining-custom-rpcs",level:2},{value:"Sending RPCs",id:"sending-rpcs",level:2},{value:"Client to Server",id:"client-to-server",level:3},{value:"Server to Specific Client",id:"server-to-specific-client",level:3},{value:"Server to All Clients",id:"server-to-all-clients",level:3},{value:"Handling RPCs",id:"handling-rpcs",level:2},{value:"Client-to-Server Handlers",id:"client-to-server-handlers",level:3},{value:"Server-to-Client Handlers",id:"server-to-client-handlers",level:3},{value:"RPC Parameter Types",id:"rpc-parameter-types",level:2},{value:"Common RPC Patterns",id:"common-rpc-patterns",level:2},{value:"Request-Response Pattern",id:"request-response-pattern",level:3},{value:"Action Confirmation Pattern",id:"action-confirmation-pattern",level:3},{value:"Advanced RPC Techniques",id:"advanced-rpc-techniques",level:2},{value:"RPC Batching",id:"rpc-batching",level:3},{value:"Area-Based RPC Broadcasting",id:"area-based-rpc-broadcasting",level:3},{value:"RPC Rate Limiting",id:"rpc-rate-limiting",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Debugging RPCs",id:"debugging-rpcs",level:2},{value:"Logging RPC Traffic",id:"logging-rpc-traffic",level:3},{value:"Tracing RPC Performance",id:"tracing-rpc-performance",level:3},{value:"RPC Lifecycle",id:"rpc-lifecycle",level:2},{value:"1. Registration Phase",id:"1-registration-phase",level:3},{value:"2. Serialization Phase",id:"2-serialization-phase",level:3},{value:"3. Network Transmission",id:"3-network-transmission",level:3},{value:"4. Deserialization Phase",id:"4-deserialization-phase",level:3},{value:"5. Execution Phase",id:"5-execution-phase",level:3},{value:"6. Response Phase (Optional)",id:"6-response-phase-optional",level:3},{value:"Error Handling and Reliability",id:"error-handling-and-reliability",level:2},{value:"Handling RPC Failures",id:"handling-rpc-failures",level:3},{value:"Handling Disconnections",id:"handling-disconnections",level:3},{value:"Data Serialization Strategies",id:"data-serialization-strategies",level:2},{value:"String Serialization",id:"string-serialization",level:3},{value:"Chunked Data Transfer",id:"chunked-data-transfer",level:3},{value:"Complex Example: Multiplayer Trading System",id:"complex-example-multiplayer-trading-system",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"remote-procedure-call-system",children:"Remote Procedure Call System"})}),"\n",(0,a.jsx)(n.p,{children:"Remote Procedure Calls (RPCs) are a core feature of Don't Starve Together's networking architecture, enabling bidirectional communication between server and clients. Unlike network variables which are unidirectional (server to client), RPCs allow clients to send commands to the server and the server to send commands to specific clients."}),"\n",(0,a.jsx)(n.h2,{id:"rpc-overview",children:"RPC Overview"}),"\n",(0,a.jsx)(n.p,{children:"RPCs serve several key purposes in Don't Starve Together:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Client-to-Server Communication"}),": Allow players to request actions (attacks, crafting, etc.)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Server-to-Client Communication"}),": Enable the server to trigger visual effects, sounds, or UI updates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Command Broadcasting"}),": Send information to all clients simultaneously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Targeted Messages"}),": Deliver information to specific clients"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"rpc-directions",children:"RPC Directions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- RPC direction constants\nRPC = {\n    Broadcast = 0,  -- Server to all clients\n    Target = 1,     -- Server to specific client\n    ToServer = 2    -- Client to server\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"built-in-rpc-categories",children:"Built-in RPC Categories"}),"\n",(0,a.jsx)(n.p,{children:"Don't Starve Together organizes RPCs into several categories:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Main RPC categories\nMAIN_RPC = {\n    PlayerActionPickup = 0,\n    PlayerActionPickupStack = 1,\n    PlayerActionPickupHalf = 2,\n    PlayerActionDropItem = 3,\n    PlayerActionDropItemFromContainer = 4,\n    -- Many more actions...\n}\n\n-- World RPC categories\nWORLD_RPC = {\n    Thunderstrike = 0,\n    Extinguish = 1,\n    PushExplosion = 2,\n    -- More world effects...\n}\n\n-- Character RPC categories\nCHARACTER_RPC = {\n    SetBuffEnabled = 0,\n    SetBuffLevel = 1,\n    -- Character-specific actions...\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"defining-custom-rpcs",children:"Defining Custom RPCs"}),"\n",(0,a.jsx)(n.p,{children:"For mods, you can define your own RPC messages:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- In modmain.lua\nMOD_RPC = {\n    MyMod = {\n        DoSpecialAttack = 0,\n        RequestData = 1,\n        UpdateUI = 2,\n        -- Additional RPCs...\n    }\n}\n\n-- Name conventions are important:\n-- ModName = your mod's folder name\n-- ActionName = descriptive name for the RPC\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sending-rpcs",children:"Sending RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"client-to-server",children:"Client to Server"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Basic client-to-server RPC\nSendModRPCToServer(MOD_RPC.MyMod.DoSpecialAttack, target_entity, damage_multiplier)\n\n-- Client requesting data from server\nSendModRPCToServer(MOD_RPC.MyMod.RequestData, "player_stats")\n\n-- Client informing server of a selection\nSendModRPCToServer(MOD_RPC.MyMod.SelectOption, option_id)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-specific-client",children:"Server to Specific Client"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Send RPC to a specific client (by userid/player entity)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateUI, player, "health", current_health, max_health)\n\n-- Send RPC to client with additional parameters\nSendModRPCToClient(MOD_RPC.MyMod.ShowEffect, player, effect_name, x, y, z, scale)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-all-clients",children:"Server to All Clients"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Broadcast RPC to all clients\nSendModRPCToClients(MOD_RPC.MyMod.WorldEvent, "earthquake", intensity, duration)\n\n-- Broadcast position-based effect\nlocal x, y, z = inst.Transform:GetWorldPosition()\nSendModRPCToClients(MOD_RPC.MyMod.SpawnEffect, "explosion", x, y, z)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"handling-rpcs",children:"Handling RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"client-to-server-handlers",children:"Client-to-Server Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua (server-side handler)\nAddModRPCHandler("MyMod", "DoSpecialAttack", function(player, target, multiplier)\n    -- Validate player can perform this action\n    if player.components.health:IsDead() or player:HasTag("playerghost") then\n        return\n    end\n    \n    -- Find target entity\n    local target_ent = Ents[target]\n    if target_ent == nil then\n        return\n    end\n    \n    -- Execute the action\n    if player.components.combat ~= nil then\n        local damage = player.components.combat.defaultdamage * multiplier\n        player.components.combat:DoAttack(target_ent, nil, nil, nil, damage)\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-client-handlers",children:"Server-to-Client Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua (client-side handler)\nAddClientModRPCHandler("MyMod", "UpdateUI", function(health_name, current, maximum)\n    -- Update UI element with new health value\n    if health_name == "health" then\n        UpdateHealthBar(current, maximum)\n    elseif health_name == "sanity" then\n        UpdateSanityBar(current, maximum)\n    elseif health_name == "hunger" then\n        UpdateHungerBar(current, maximum)\n    end\nend)\n\n-- Handler for visual effects\nAddClientModRPCHandler("MyMod", "ShowEffect", function(effect_name, x, y, z, scale)\n    -- Spawn a client-side visual effect\n    local fx = SpawnPrefab(effect_name)\n    if fx ~= nil then\n        fx.Transform:SetPosition(x, y, z)\n        if scale ~= nil then\n            fx.Transform:SetScale(scale, scale, scale)\n        end\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rpc-parameter-types",children:"RPC Parameter Types"}),"\n",(0,a.jsx)(n.p,{children:"RPCs support several parameter types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Supported RPC parameter types\n-- Number (float/integer)\nSendModRPCToServer(MOD_RPC.MyMod.Example, 42, 3.14)\n\n-- Boolean\nSendModRPCToServer(MOD_RPC.MyMod.Example, true, false)\n\n-- String\nSendModRPCToServer(MOD_RPC.MyMod.Example, "player_name", "action_type")\n\n-- Entity references (as EntityScript or EntityID)\nSendModRPCToServer(MOD_RPC.MyMod.Example, target_entity, target_entity.entity:GetGUID())\n\n-- Vector3 (as three separate parameters)\nlocal x, y, z = inst.Transform:GetWorldPosition()\nSendModRPCToServer(MOD_RPC.MyMod.Example, x, y, z)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"common-rpc-patterns",children:"Common RPC Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"request-response-pattern",children:"Request-Response Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client requesting data\n-- 1. Define RPCs\nMOD_RPC = {\n    MyMod = {\n        RequestPlayerData = 0,\n        ReceivePlayerData = 1,\n    }\n}\n\n-- 2. Client sends request\nSendModRPCToServer(MOD_RPC.MyMod.RequestPlayerData, target_player.userid)\n\n-- 3. Server handles request and responds\nAddModRPCHandler("MyMod", "RequestPlayerData", function(player, target_userid)\n    -- Find target player\n    local target = nil\n    for _, v in ipairs(AllPlayers) do\n        if v.userid == target_userid then\n            target = v\n            break\n        end\n    end\n    \n    if target ~= nil then\n        -- Collect data\n        local data = {\n            health = target.components.health.currenthealth,\n            sanity = target.components.sanity.current,\n            hunger = target.components.hunger.current,\n        }\n        \n        -- Send response back to requesting client\n        SendModRPCToClient(MOD_RPC.MyMod.ReceivePlayerData, player, \n            target.userid, data.health, data.sanity, data.hunger)\n    end\nend)\n\n-- 4. Client handles response\nAddClientModRPCHandler("MyMod", "ReceivePlayerData", function(userid, health, sanity, hunger)\n    -- Update UI with received data\n    UpdatePlayerStatusDisplay(userid, health, sanity, hunger)\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"action-confirmation-pattern",children:"Action Confirmation Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- 1. Define RPCs\nMOD_RPC = {\n    MyMod = {\n        AttemptSpecialAction = 0,\n        ConfirmSpecialAction = 1,\n    }\n}\n\n-- 2. Client requests action\nSendModRPCToServer(MOD_RPC.MyMod.AttemptSpecialAction, target_position.x, target_position.z)\n\n-- 3. Server validates and confirms\nAddModRPCHandler("MyMod", "AttemptSpecialAction", function(player, x, z)\n    -- Check if player can perform action\n    if not CanPerformSpecialAction(player, x, z) then\n        return\n    end\n    \n    -- Perform the action\n    local success = DoSpecialAction(player, x, z)\n    \n    -- Confirm back to client\n    SendModRPCToClient(MOD_RPC.MyMod.ConfirmSpecialAction, player, success, x, z)\nend)\n\n-- 4. Client handles confirmation\nAddClientModRPCHandler("MyMod", "ConfirmSpecialAction", function(success, x, z)\n    if success then\n        -- Play success effects\n        SpawnPrefab("special_action_fx").Transform:SetPosition(x, 0, z)\n    else\n        -- Play failure animation\n        ThePlayer.AnimState:PlayAnimation("special_action_fail")\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-rpc-techniques",children:"Advanced RPC Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"rpc-batching",children:"RPC Batching"}),"\n",(0,a.jsx)(n.p,{children:"For multiple related updates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Instead of multiple RPCs:\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "health", 100)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "sanity", 200)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "hunger", 150)\n\n-- Use a single batched RPC:\nSendModRPCToClient(MOD_RPC.MyMod.UpdateAllStats, player, 100, 200, 150)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"area-based-rpc-broadcasting",children:"Area-Based RPC Broadcasting"}),"\n",(0,a.jsx)(n.p,{children:"Send RPCs only to nearby players:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Find players within range of an effect\nlocal x, y, z = inst.Transform:GetWorldPosition()\nlocal nearby_players = FindPlayersInRange(x, y, z, TUNING.MAX_RPC_RANGE)\n\n-- Send RPC only to nearby players\nfor _, player in ipairs(nearby_players) do\n    SendModRPCToClient(MOD_RPC.MyMod.LocalEffect, player, "earthquake", x, y, z)\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"rpc-rate-limiting",children:"RPC Rate Limiting"}),"\n",(0,a.jsx)(n.p,{children:"Prevent RPC spam:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client-side rate limiting\nlocal last_request_time = 0\n\nlocal function TryRequestAction()\n    local current_time = GetTime()\n    if current_time - last_request_time < MIN_REQUEST_INTERVAL then\n        return false\n    end\n    \n    last_request_time = current_time\n    SendModRPCToServer(MOD_RPC.MyMod.RequestAction)\n    return true\nend\n\n-- Server-side rate limiting\nlocal player_request_times = {}\n\nAddModRPCHandler("MyMod", "RequestAction", function(player)\n    local userid = player.userid\n    local current_time = GetTime()\n    \n    if player_request_times[userid] and \n       current_time - player_request_times[userid] < MIN_REQUEST_INTERVAL then\n        -- Ignore too-frequent requests\n        return\n    end\n    \n    player_request_times[userid] = current_time\n    -- Process the request\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When implementing RPCs, always consider security:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate Permissions"}),": Check if player has permission to perform action"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Verify Input"}),": Validate all RPC parameters before using them"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check Entity Ownership"}),": Ensure player is authorized to control an entity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement Rate Limiting"}),": Prevent RPC spam attacks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't Trust Clients"}),": Always validate actions on the server"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Example of secure RPC handling\nAddModRPCHandler("MyMod", "HarvestCrop", function(player, crop_entity)\n    -- Validate crop exists\n    local crop = Ents[crop_entity]\n    if crop == nil then return end\n    \n    -- Check distance (prevent cheating)\n    local player_x, player_y, player_z = player.Transform:GetWorldPosition()\n    local crop_x, crop_y, crop_z = crop.Transform:GetWorldPosition()\n    local dist_sq = distsq(player_x, player_z, crop_x, crop_z)\n    \n    if dist_sq > TUNING.MAX_HARVEST_DISTANCE * TUNING.MAX_HARVEST_DISTANCE then\n        return -- Too far away\n    end\n    \n    -- Check if crop is ready\n    if not crop.components.crop.mature then\n        return -- Not ready for harvest\n    end\n    \n    -- All checks passed, allow harvest\n    crop.components.crop:Harvest(player)\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-rpcs",children:"Debugging RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"logging-rpc-traffic",children:"Logging RPC Traffic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Add debug logging to RPC handlers\nAddModRPCHandler("MyMod", "ExampleRPC", function(player, ...)\n    local args = {...}\n    print("Received ExampleRPC from " .. player:GetDisplayName())\n    for i, arg in ipairs(args) do\n        print("  Arg " .. i .. ": " .. tostring(arg))\n    end\n    \n    -- Process RPC normally\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tracing-rpc-performance",children:"Tracing RPC Performance"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Measure RPC processing time\nAddModRPCHandler("MyMod", "HeavyProcessing", function(player, ...)\n    local start_time = GetTimeReal()\n    \n    -- Normal processing\n    local result = DoHeavyProcessing(...)\n    \n    local end_time = GetTimeReal()\n    print("HeavyProcessing RPC took " .. (end_time - start_time) * 1000 .. " ms")\n    \n    return result\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rpc-lifecycle",children:"RPC Lifecycle"}),"\n",(0,a.jsx)(n.p,{children:"Understanding the complete lifecycle of an RPC helps in debugging and optimizing network communication:"}),"\n",(0,a.jsx)(n.h3,{id:"1-registration-phase",children:"1. Registration Phase"}),"\n",(0,a.jsx)(n.p,{children:"RPCs must be registered before they can be used:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua (shared by client and server)\nMOD_RPC = {\n    MyMod = {\n        SyncWorldState = 0,\n        RequestEntityInfo = 1,\n        ReceiveEntityInfo = 2\n    }\n}\n\n-- Register server-side handlers\nAddModRPCHandler("MyMod", "SyncWorldState", OnSyncWorldState)\nAddModRPCHandler("MyMod", "RequestEntityInfo", OnRequestEntityInfo)\n\n-- Register client-side handlers\nAddClientModRPCHandler("MyMod", "ReceiveEntityInfo", OnReceiveEntityInfo)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-serialization-phase",children:"2. Serialization Phase"}),"\n",(0,a.jsx)(n.p,{children:"When an RPC is sent, parameters are serialized:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Basic types (numbers, booleans, strings) are directly serialized"}),"\n",(0,a.jsx)(n.li,{children:"Entity references are converted to network IDs"}),"\n",(0,a.jsx)(n.li,{children:"Vector3 values are split into separate x, y, z components"}),"\n",(0,a.jsx)(n.li,{children:"Tables and complex objects cannot be directly serialized"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-network-transmission",children:"3. Network Transmission"}),"\n",(0,a.jsx)(n.p,{children:"The RPC message is transmitted over the network:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Client-to-server: Message is sent to the server"}),"\n",(0,a.jsx)(n.li,{children:"Server-to-client: Message is sent to specific client(s)"}),"\n",(0,a.jsx)(n.li,{children:"Broadcast: Message is sent to all connected clients"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-deserialization-phase",children:"4. Deserialization Phase"}),"\n",(0,a.jsx)(n.p,{children:"When an RPC is received:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The message is deserialized"}),"\n",(0,a.jsx)(n.li,{children:"Parameters are converted back to appropriate types"}),"\n",(0,a.jsx)(n.li,{children:"Entity references are resolved from network IDs"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"5-execution-phase",children:"5. Execution Phase"}),"\n",(0,a.jsx)(n.p,{children:"The registered handler function is called with the deserialized parameters."}),"\n",(0,a.jsx)(n.h3,{id:"6-response-phase-optional",children:"6. Response Phase (Optional)"}),"\n",(0,a.jsx)(n.p,{children:"For request-response patterns, a response RPC may be sent back."}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-and-reliability",children:"Error Handling and Reliability"}),"\n",(0,a.jsx)(n.p,{children:"RPCs in Don't Starve Together are not guaranteed to be reliable. Network issues can cause messages to be lost or delayed."}),"\n",(0,a.jsx)(n.h3,{id:"handling-rpc-failures",children:"Handling RPC Failures"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client-side: Implement timeout and retry mechanism\nlocal function RequestWithRetry(attempt)\n    attempt = attempt or 1\n    \n    -- Send request\n    SendModRPCToServer(MOD_RPC.MyMod.RequestData)\n    \n    -- Set up timeout\n    if attempt < MAX_RETRIES then\n        inst:DoTaskInTime(RETRY_TIMEOUT, function()\n            -- If response flag not set, retry\n            if not response_received then\n                print("RPC request timed out, retrying (attempt " .. attempt + 1 .. ")")\n                RequestWithRetry(attempt + 1)\n            end\n        end)\n    else\n        print("RPC request failed after " .. MAX_RETRIES .. " attempts")\n        -- Handle ultimate failure\n        OnRequestFailed()\n    end\nend\n\n-- When response is received\nAddClientModRPCHandler("MyMod", "ResponseData", function(...)\n    response_received = true\n    -- Handle response\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"handling-disconnections",children:"Handling Disconnections"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Track connection state\nlocal was_connected = false\n\nlocal function OnPlayerConnected(inst)\n    local is_connected = TheNet:IsConnected()\n    \n    -- Detect reconnection\n    if is_connected and not was_connected then\n        print("Reconnected, re-syncing data...")\n        -- Re-sync necessary data\n        SendModRPCToServer(MOD_RPC.MyMod.RequestFullSync)\n    end\n    \n    was_connected = is_connected\nend\n\n-- Listen for connection changes\ninst:ListenForEvent("playeractivated", OnPlayerConnected)\ninst:ListenForEvent("playerdeactivated", OnPlayerConnected)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"data-serialization-strategies",children:"Data Serialization Strategies"}),"\n",(0,a.jsx)(n.p,{children:"Since RPCs can only transmit basic data types, complex data structures must be serialized."}),"\n",(0,a.jsx)(n.h3,{id:"string-serialization",children:"String Serialization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Serialize a table to a string\nlocal function SerializeTable(t)\n    local result = {}\n    for k, v in pairs(t) do\n        if type(v) == "string" then\n            table.insert(result, k .. "=" .. v)\n        elseif type(v) == "number" or type(v) == "boolean" then\n            table.insert(result, k .. "=" .. tostring(v))\n        end\n    end\n    return table.concat(result, "|")\nend\n\n-- Deserialize a string back to a table\nlocal function DeserializeTable(str)\n    local result = {}\n    for pair in string.gmatch(str, "[^|]+") do\n        local k, v = string.match(pair, "(.+)=(.+)")\n        if k and v then\n            -- Try to convert to number if possible\n            local num = tonumber(v)\n            if num then\n                result[k] = num\n            elseif v == "true" then\n                result[k] = true\n            elseif v == "false" then\n                result[k] = false\n            else\n                result[k] = v\n            end\n        end\n    end\n    return result\nend\n\n-- Using serialization with RPCs\nlocal data = {\n    health = 75,\n    hunger = 50,\n    sanity = 100,\n    buffs = "strength|speed",\n    is_leader = true\n}\n\n-- Send serialized data\nSendModRPCToServer(MOD_RPC.MyMod.UpdatePlayerState, SerializeTable(data))\n\n-- Receive and deserialize\nAddModRPCHandler("MyMod", "UpdatePlayerState", function(player, data_str)\n    local data = DeserializeTable(data_str)\n    -- Use data...\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"chunked-data-transfer",children:"Chunked Data Transfer"}),"\n",(0,a.jsx)(n.p,{children:"For large data sets that exceed RPC parameter limits:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client requesting large data\nSendModRPCToServer(MOD_RPC.MyMod.RequestLargeData)\n\n-- Server sending data in chunks\nAddModRPCHandler("MyMod", "RequestLargeData", function(player)\n    local large_data = GenerateLargeData()\n    local chunk_size = 10 -- Items per chunk\n    \n    -- Send total count first\n    SendModRPCToClient(MOD_RPC.MyMod.ReceiveLargeDataStart, player, #large_data)\n    \n    -- Send data in chunks\n    for i = 1, #large_data, chunk_size do\n        local chunk = {}\n        for j = i, math.min(i + chunk_size - 1, #large_data) do\n            table.insert(chunk, SerializeItem(large_data[j]))\n        end\n        \n        -- Send chunk with index\n        local chunk_index = math.floor((i - 1) / chunk_size) + 1\n        SendModRPCToClient(MOD_RPC.MyMod.ReceiveLargeDataChunk, player, \n            chunk_index, table.concat(chunk, ";;"))\n    end\n    \n    -- Signal completion\n    SendModRPCToClient(MOD_RPC.MyMod.ReceiveLargeDataEnd, player)\nend)\n\n-- Client receiving chunked data\nlocal received_chunks = {}\nlocal total_chunks = 0\nlocal total_items = 0\n\nAddClientModRPCHandler("MyMod", "ReceiveLargeDataStart", function(count)\n    total_items = count\n    total_chunks = math.ceil(count / 10)\n    received_chunks = {}\n    print("Starting large data transfer, expecting " .. total_chunks .. " chunks")\nend)\n\nAddClientModRPCHandler("MyMod", "ReceiveLargeDataChunk", function(chunk_index, data)\n    received_chunks[chunk_index] = data\n    print("Received chunk " .. chunk_index .. " of " .. total_chunks)\nend)\n\nAddClientModRPCHandler("MyMod", "ReceiveLargeDataEnd", function()\n    -- Combine all chunks\n    local all_data = {}\n    for i = 1, total_chunks do\n        if received_chunks[i] then\n            local items = string.split(received_chunks[i], ";;")\n            for _, item_str in ipairs(items) do\n                table.insert(all_data, DeserializeItem(item_str))\n            end\n        end\n    end\n    \n    -- Process complete data\n    ProcessCompleteData(all_data)\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complex-example-multiplayer-trading-system",children:"Complex Example: Multiplayer Trading System"}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates a complete trading system between players:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Define RPC messages for trading system\nMOD_RPC = {\n    TradingMod = {\n        -- Client to server\n        RequestTrade = 0,\n        AcceptTrade = 1,\n        DeclineTrade = 2,\n        UpdateTradeOffer = 3,\n        CancelTrade = 4,\n        \n        -- Server to client\n        TradeRequested = 5,\n        TradeAccepted = 6,\n        TradeDeclined = 7,\n        TradeOfferUpdated = 8,\n        TradeCancelled = 9,\n        TradeCompleted = 10\n    }\n}\n\n-- Server-side trade management\nlocal active_trades = {}\n\n-- Client requests trade with another player\nAddModRPCHandler("TradingMod", "RequestTrade", function(player, target_userid)\n    -- Find target player\n    local target = FindPlayerByUserID(target_userid)\n    if not target then return end\n    \n    -- Check if players are close enough\n    if not ArePlayersNearby(player, target) then\n        -- Inform requesting player they\'re too far\n        SendModRPCToClient(MOD_RPC.TradingMod.TradeDeclined, player, target_userid, "TOO_FAR")\n        return\n    end\n    \n    -- Check if either player is already trading\n    if active_trades[player.userid] or active_trades[target_userid] then\n        SendModRPCToClient(MOD_RPC.TradingMod.TradeDeclined, player, target_userid, "ALREADY_TRADING")\n        return\n    end\n    \n    -- Create pending trade\n    active_trades[player.userid] = {\n        status = "pending",\n        partner = target.userid,\n        items = {},\n        timestamp = GetTime()\n    }\n    \n    active_trades[target_userid] = {\n        status = "requested",\n        partner = player.userid,\n        items = {},\n        timestamp = GetTime()\n    }\n    \n    -- Notify target about trade request\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeRequested, target, player.userid)\n    \n    -- Set timeout for trade request\n    player:DoTaskInTime(TRADE_REQUEST_TIMEOUT, function()\n        if active_trades[player.userid] and active_trades[player.userid].status == "pending" then\n            -- Cancel timed-out trade request\n            CancelTrade(player.userid, target_userid, "TIMEOUT")\n        end\n    end)\nend)\n\n-- Player accepts trade request\nAddModRPCHandler("TradingMod", "AcceptTrade", function(player, requester_userid)\n    -- Validate trade request exists\n    if not active_trades[player.userid] or \n       active_trades[player.userid].status ~= "requested" or\n       active_trades[player.userid].partner ~= requester_userid then\n        return\n    end\n    \n    -- Find requester\n    local requester = FindPlayerByUserID(requester_userid)\n    if not requester then\n        CancelTrade(player.userid, requester_userid, "PLAYER_NOT_FOUND")\n        return\n    end\n    \n    -- Update trade status\n    active_trades[player.userid].status = "active"\n    active_trades[requester_userid].status = "active"\n    \n    -- Notify both players\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeAccepted, player, requester_userid)\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeAccepted, requester, player.userid)\nend)\n\n-- Player updates their trade offer\nAddModRPCHandler("TradingMod", "UpdateTradeOffer", function(player, items_json)\n    -- Validate player is in active trade\n    if not active_trades[player.userid] or active_trades[player.userid].status ~= "active" then\n        return\n    end\n    \n    -- Parse items\n    local success, items = pcall(function() return json.decode(items_json) end)\n    if not success then return end\n    \n    -- Validate items exist in player\'s inventory\n    local valid_items = ValidateTradeItems(player, items)\n    \n    -- Update trade offer\n    active_trades[player.userid].items = valid_items\n    active_trades[player.userid].ready = false\n    \n    -- Get partner\n    local partner = FindPlayerByUserID(active_trades[player.userid].partner)\n    if not partner then\n        CancelTrade(player.userid, active_trades[player.userid].partner, "PARTNER_NOT_FOUND")\n        return\n    end\n    \n    -- Notify partner about updated offer\n    local items_str = json.encode(valid_items)\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeOfferUpdated, partner, player.userid, items_str)\nend)\n\n-- Helper function to execute the trade\nlocal function ExecuteTrade(player1_id, player2_id)\n    local player1 = FindPlayerByUserID(player1_id)\n    local player2 = FindPlayerByUserID(player2_id)\n    \n    if not player1 or not player2 then\n        CancelTrade(player1_id, player2_id, "PLAYER_NOT_FOUND")\n        return false\n    end\n    \n    local trade1 = active_trades[player1_id]\n    local trade2 = active_trades[player2_id]\n    \n    -- Transfer items from player1 to player2\n    for _, item_data in ipairs(trade1.items) do\n        local item = FindItemInInventory(player1, item_data.id)\n        if item then\n            TransferItemBetweenPlayers(item, player1, player2)\n        end\n    end\n    \n    -- Transfer items from player2 to player1\n    for _, item_data in ipairs(trade2.items) do\n        local item = FindItemInInventory(player2, item_data.id)\n        if item then\n            TransferItemBetweenPlayers(item, player2, player1)\n        end\n    end\n    \n    -- Notify both players\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeCompleted, player1, player2_id)\n    SendModRPCToClient(MOD_RPC.TradingMod.TradeCompleted, player2, player1_id)\n    \n    -- Clear trade data\n    active_trades[player1_id] = nil\n    active_trades[player2_id] = nil\n    \n    return true\nend\n\n-- Client-side trade UI handling\nlocal trade_ui = nil\nlocal current_trade_partner = nil\n\n-- Handle incoming trade request\nAddClientModRPCHandler("TradingMod", "TradeRequested", function(requester_userid)\n    -- Find requester name\n    local requester_name = GetPlayerNameFromUserID(requester_userid)\n    \n    -- Show trade request UI\n    ShowTradeRequestUI(requester_name, requester_userid)\nend)\n\n-- Handle trade acceptance\nAddClientModRPCHandler("TradingMod", "TradeAccepted", function(partner_userid)\n    -- Open trade UI\n    current_trade_partner = partner_userid\n    trade_ui = ShowTradeUI(partner_userid)\nend)\n\n-- Handle updated trade offer from partner\nAddClientModRPCHandler("TradingMod", "TradeOfferUpdated", function(partner_userid, items_json)\n    if not trade_ui then return end\n    \n    -- Parse items\n    local success, items = pcall(function() return json.decode(items_json) end)\n    if not success then return end\n    \n    -- Update UI with partner\'s offer\n    trade_ui:UpdatePartnerOffer(items)\nend)\n\n-- Handle trade completion\nAddClientModRPCHandler("TradingMod", "TradeCompleted", function(partner_userid)\n    if not trade_ui then return end\n    \n    -- Show completion message\n    trade_ui:ShowTradeCompleted()\n    \n    -- Close UI after delay\n    ThePlayer:DoTaskInTime(2, function()\n        trade_ui:Close()\n        trade_ui = nil\n        current_trade_partner = nil\n    end)\nend)\n\n## Best Practices\n\n1. **Use Appropriate Direction**: Choose the correct RPC direction for your needs\n2. **Minimize RPC Count**: Batch related operations into single RPCs\n3. **Validate All Input**: Never trust client-sent RPC parameters\n4. **Check Permissions**: Verify player can perform the requested action\n5. **Handle Failures Gracefully**: Provide feedback when RPCs can\'t be processed\n6. **Document Your RPCs**: Keep clear documentation of each RPC\'s purpose and parameters\n7. **Consistent Naming**: Use clear, consistent naming for your RPC identifiers \n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);