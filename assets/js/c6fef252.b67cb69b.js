"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[80658],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},46421:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"game-scripts/core-systems/system-core/runtime/runtime-overview","title":"Runtime System Overview","description":"Overview of runtime process management, update loops, and task scheduling infrastructure in DST API","source":"@site/docs/game-scripts/core-systems/system-core/runtime/index.md","sourceDirName":"game-scripts/core-systems/system-core/runtime","slug":"/game-scripts/core-systems/system-core/runtime/","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"runtime-overview","title":"Runtime System Overview","description":"Overview of runtime process management, update loops, and task scheduling infrastructure in DST API","sidebar_position":0,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable","category_type":"infrastructure-system","system_scope":"runtime process management and execution control"},"sidebar":"docs","previous":{"title":"Physics System","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/engine/physics"},"next":{"title":"Runtime System Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/"}}');var s=t(74848),r=t(28453);const a={id:"runtime-overview",title:"Runtime System Overview",description:"Overview of runtime process management, update loops, and task scheduling infrastructure in DST API",sidebar_position:0,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable",category_type:"infrastructure-system",system_scope:"runtime process management and execution control"},l="Runtime System Overview",o={},d=[{value:"Build Information",id:"build-information",level:2},{value:"System Purpose",id:"system-purpose",level:2},{value:"Key Responsibilities",id:"key-responsibilities",level:3},{value:"System Scope",id:"system-scope",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"System Components",id:"system-components",level:3},{value:"Data Flow",id:"data-flow",level:3},{value:"Integration Points",id:"integration-points",level:3},{value:"Recent Changes",id:"recent-changes",level:2},{value:"Core Infrastructure Modules",id:"core-infrastructure-modules",level:2},{value:"Update System",id:"update-system",level:3},{value:"Common Infrastructure Patterns",id:"common-infrastructure-patterns",level:2},{value:"Component Update Registration Pattern",id:"component-update-registration-pattern",level:3},{value:"Wall Time Update Pattern",id:"wall-time-update-pattern",level:3},{value:"Multi-Update Type Management Pattern",id:"multi-update-type-management-pattern",level:3},{value:"Long Update Time Skipping Pattern",id:"long-update-time-skipping-pattern",level:3},{value:"Infrastructure Dependencies",id:"infrastructure-dependencies",level:2},{value:"Required Systems",id:"required-systems",level:3},{value:"Optional Systems",id:"optional-systems",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"System Performance",id:"system-performance",level:3},{value:"Resource Usage",id:"resource-usage",level:3},{value:"Scaling Characteristics",id:"scaling-characteristics",level:3},{value:"Development Guidelines",id:"development-guidelines",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Related Systems",id:"related-systems",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Infrastructure Issues",id:"common-infrastructure-issues",level:3},{value:"Debugging Infrastructure",id:"debugging-infrastructure",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Key Metrics",id:"key-metrics",level:3},{value:"Optimization Strategies",id:"optimization-strategies",level:3},{value:"Migration Notes",id:"migration-notes",level:2},{value:"From Previous Versions",id:"from-previous-versions",level:3},{value:"Deprecated Features",id:"deprecated-features",level:3},{value:"Contributing",id:"contributing",level:2},{value:"Adding New Runtime Features",id:"adding-new-runtime-features",level:3},{value:"Documentation Standards",id:"documentation-standards",level:3},{value:"Code Review Checklist",id:"code-review-checklist",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"runtime-system-overview",children:"Runtime System Overview"})}),"\n",(0,s.jsx)(n.h2,{id:"build-information",children:"Build Information"}),"\n",(0,s.jsxs)(n.p,{children:["Current documentation based on build version: ",(0,s.jsx)(n.strong,{children:"676042"}),"\nLast updated: ",(0,s.jsx)(n.strong,{children:"2025-06-21"})]}),"\n",(0,s.jsx)(n.h2,{id:"system-purpose",children:"System Purpose"}),"\n",(0,s.jsx)(n.p,{children:"The Runtime System provides the core process management infrastructure that controls execution timing, update loops, and task scheduling throughout Don't Starve Together. This system manages the fundamental execution environment that drives all game simulation, ensuring proper timing relationships between different system components and maintaining consistent performance across various execution contexts."}),"\n",(0,s.jsx)(n.h3,{id:"key-responsibilities",children:"Key Responsibilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Game simulation timing and update loop management"}),"\n",(0,s.jsx)(n.li,{children:"Component update registration and lifecycle control"}),"\n",(0,s.jsx)(n.li,{children:"Wall time vs simulation time coordination"}),"\n",(0,s.jsx)(n.li,{children:"Task scheduling and execution priority management"}),"\n",(0,s.jsx)(n.li,{children:"Process timing for game state transitions and long operations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"system-scope",children:"System Scope"}),"\n",(0,s.jsx)(n.p,{children:"This infrastructure category includes runtime execution control, update loop management, and process scheduling, but excludes specific game logic implementations, content-specific timing, and user interface update handling."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.h3,{id:"system-components",children:"System Components"}),"\n",(0,s.jsx)(n.p,{children:"The Runtime System is organized as a multi-layered execution management infrastructure where timing control forms the foundation, update loops provide the execution framework, and component registration enables modular system participation."}),"\n",(0,s.jsx)(n.h3,{id:"data-flow",children:"Data Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Timing Control \u2192 Update Loop Management \u2192 Component Registration \u2192 Execution Dispatch\n       \u2193                    \u2193                        \u2193                     \u2193\n   Time Sources \u2192 Update Type Routing \u2192 Component Callbacks \u2192 System Updates\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-points",children:"Integration Points"}),"\n",(0,s.jsx)(n.p,{children:"The Runtime System serves as the execution foundation for all game systems:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Engine System"}),": Provides timing services for entity management and physics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Character Systems"}),": Manages update cycles for character components and behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Game Mechanics"}),": Controls timing for gameplay systems and rule enforcement"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Interface"}),": Coordinates wall time updates for responsive UI elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"World Systems"}),": Manages simulation time for world state progression"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"recent-changes",children:"Recent Changes"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Build"}),(0,s.jsx)(n.th,{children:"Date"}),(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Change Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"676042"}),(0,s.jsx)(n.td,{children:"2025-06-21"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/update",children:"Update System"})}),(0,s.jsx)(n.td,{children:"stable"}),(0,s.jsx)(n.td,{children:"Core update loop and component timing system"})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"core-infrastructure-modules",children:"Core Infrastructure Modules"}),"\n",(0,s.jsx)(n.h3,{id:"update-system",children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/update",children:"Update System"})}),"\n",(0,s.jsx)(n.p,{children:"Core update loop system that handles game simulation timing and component updates."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Module"}),(0,s.jsx)(n.th,{children:"Status"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Key Features"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/update",children:"Update System"})}),(0,s.jsx)(n.td,{children:"stable"}),(0,s.jsx)(n.td,{children:"Update loop and timing management"}),(0,s.jsx)(n.td,{children:"Wall time updates, simulation updates, component registration"})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"common-infrastructure-patterns",children:"Common Infrastructure Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"component-update-registration-pattern",children:"Component Update Registration Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Standard component update lifecycle\nlocal MyComponent = Class(function(self, inst)\n    self.inst = inst\n    self.update_timer = 0\n    self:StartUpdating()\nend)\n\nfunction MyComponent:OnUpdate(dt)\n    -- Simulation time update\n    self.update_timer = self.update_timer + dt\n    if self.update_timer >= self.update_interval then\n        self:ProcessUpdate()\n        self.update_timer = 0\n    end\nend\n\nfunction MyComponent:StartUpdating()\n    StartUpdatingComponent(self, self.inst)\nend\n\nfunction MyComponent:StopUpdating()\n    StopUpdatingComponent(self, self.inst)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"wall-time-update-pattern",children:"Wall Time Update Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Real-time updates for UI and input\nfunction MyComponent:OnWallUpdate(dt)\n    -- Always runs, even when game is paused\n    self.wall_timer = self.wall_timer + dt\n    \n    -- Update UI elements that need real-time responsiveness\n    if self.needs_ui_update then\n        self:UpdateUserInterface()\n    end\n    \n    -- Process input even during pause\n    self:ProcessUserInput()\nend\n\nfunction MyComponent:StartWallUpdating()\n    StartWallUpdatingComponent(self, self.inst)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multi-update-type-management-pattern",children:"Multi-Update Type Management Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Component using multiple update types\nlocal AdvancedComponent = Class(function(self, inst)\n    self.inst = inst\n    self.simulation_timer = 0\n    self.wall_timer = 0\n    self.is_paused = false\n    \n    -- Register for different update types\n    self:StartUpdating()        -- Simulation updates\n    self:StartWallUpdating()    -- Wall time updates\n    self:StartStaticUpdating()  -- Paused updates\nend)\n\nfunction AdvancedComponent:OnUpdate(dt)\n    -- Game simulation logic\n    self.simulation_timer = self.simulation_timer + dt\n    self:ProcessGameLogic()\nend\n\nfunction AdvancedComponent:OnWallUpdate(dt)\n    -- Real-time processing\n    self.wall_timer = self.wall_timer + dt\n    self:ProcessRealTimeOperations()\nend\n\nfunction AdvancedComponent:OnStaticUpdate(dt)\n    -- Operations during pause (dt is always 0)\n    if self.should_continue_when_paused then\n        self:ProcessPausedOperations()\n    end\nend\n\nfunction AdvancedComponent:OnLongUpdate(dt)\n    -- Handle time skipping operations\n    local skip_amount = dt\n    self:AdvanceSimulationState(skip_amount)\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"long-update-time-skipping-pattern",children:"Long Update Time Skipping Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Time skipping for cave transitions or night skip\nlocal function SkipTime(world, skip_duration, ignore_players)\n    -- Skip forward in simulation time\n    world:LongUpdate(skip_duration, ignore_players)\n    \n    -- Update all systems that need to catch up\n    for _, component in pairs(world.components) do\n        if component.OnLongUpdate then\n            component:OnLongUpdate(skip_duration)\n        end\n    end\nend\n\n-- Advanced time skip with validation\nlocal function SafeTimeSkip(duration, validation_callback)\n    local original_time = GetTime()\n    \n    TheWorld:LongUpdate(duration, true)\n    \n    if validation_callback then\n        local success = validation_callback()\n        if not success then\n            -- Rollback mechanism if needed\n            print("Time skip validation failed")\n        end\n    end\n    \n    print("Skipped", duration, "seconds of game time")\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"infrastructure-dependencies",children:"Infrastructure Dependencies"}),"\n",(0,s.jsx)(n.h3,{id:"required-systems",children:"Required Systems"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Engine Core"}),": Low-level timing and execution framework"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lua Runtime"}),": Script execution environment and memory management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platform Threading"}),": OS-level timing and process management"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"optional-systems",children:"Optional Systems"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profiling System"}),": Performance measurement and optimization integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debug Systems"}),": Development timing analysis and debugging support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metrics Collection"}),": Runtime performance data gathering"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"system-performance",children:"System Performance"}),"\n",(0,s.jsx)(n.p,{children:"Runtime infrastructure is optimized for consistent execution timing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Update loops use efficient component iteration with minimal overhead"}),"\n",(0,s.jsx)(n.li,{children:"Component registration uses fast lookup tables for update dispatch"}),"\n",(0,s.jsx)(n.li,{children:"Time management maintains stable frame rates across varying system loads"}),"\n",(0,s.jsx)(n.li,{children:"Priority-based update scheduling ensures critical systems get execution preference"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"resource-usage",children:"Resource Usage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU Optimization"}),": Update loops batch operations to minimize context switching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),": Component registration tables use weak references for automatic cleanup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timing Precision"}),": High-resolution timers ensure accurate simulation stepping"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scaling-characteristics",children:"Scaling Characteristics"}),"\n",(0,s.jsx)(n.p,{children:"Runtime infrastructure scales efficiently with system complexity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Component update system handles thousands of registered components"}),"\n",(0,s.jsx)(n.li,{children:"Update type routing supports multiple concurrent timing domains"}),"\n",(0,s.jsx)(n.li,{children:"Long update operations can process large time skips without performance degradation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"development-guidelines",children:"Development Guidelines"}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always pair StartUpdatingComponent calls with corresponding StopUpdatingComponent calls"}),"\n",(0,s.jsx)(n.li,{children:"Use appropriate update type for each operation (wall time for UI, simulation time for game logic)"}),"\n",(0,s.jsx)(n.li,{children:"Implement OnLongUpdate for components that need time-skip handling"}),"\n",(0,s.jsx)(n.li,{children:"Keep update functions lightweight to maintain consistent frame rates"}),"\n",(0,s.jsx)(n.li,{children:"Use update timers to control execution frequency within components"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Registering for updates without proper cleanup leading to orphaned update callbacks"}),"\n",(0,s.jsx)(n.li,{children:"Mixing wall time and simulation time logic in the same update function"}),"\n",(0,s.jsx)(n.li,{children:"Performing expensive operations directly in update callbacks without timing control"}),"\n",(0,s.jsx)(n.li,{children:"Not implementing OnLongUpdate for components that track time-dependent state"}),"\n",(0,s.jsx)(n.li,{children:"Forgetting to handle pause state appropriately in wall time updates"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test component update registration and cleanup under various lifecycle scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Verify timing accuracy across different update types and execution loads"}),"\n",(0,s.jsx)(n.li,{children:"Test long update operations with various skip durations and entity states"}),"\n",(0,s.jsx)(n.li,{children:"Validate pause/resume behavior for components using multiple update types"}),"\n",(0,s.jsx)(n.li,{children:"Performance test update loops with high component counts"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-systems",children:"Related Systems"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"System"}),(0,s.jsx)(n.th,{children:"Relationship"}),(0,s.jsx)(n.th,{children:"Integration Points"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/engine/",children:"Engine System"})}),(0,s.jsx)(n.td,{children:"Foundation dependency"}),(0,s.jsx)(n.td,{children:"Entity lifecycle, physics timing, save/load coordination"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/",children:"Fundamentals"})}),(0,s.jsx)(n.td,{children:"Built upon runtime infrastructure"}),(0,s.jsx)(n.td,{children:"Component system, entity updates, action processing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/development-tools/",children:"Development Tools"})}),(0,s.jsx)(n.td,{children:"Uses runtime profiling"}),(0,s.jsx)(n.td,{children:"Performance analysis, timing measurement, debug updates"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/user-interface/",children:"User Interface"})}),(0,s.jsx)(n.td,{children:"Leverages wall time updates"}),(0,s.jsx)(n.td,{children:"UI responsiveness, input processing, animation timing"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"common-infrastructure-issues",children:"Common Infrastructure Issues"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Issue"}),(0,s.jsx)(n.th,{children:"Symptoms"}),(0,s.jsx)(n.th,{children:"Solution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Update callbacks not firing"}),(0,s.jsx)(n.td,{children:"Component logic not executing"}),(0,s.jsx)(n.td,{children:"Verify StartUpdatingComponent registration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Performance drops during updates"}),(0,s.jsx)(n.td,{children:"Frame rate stuttering"}),(0,s.jsx)(n.td,{children:"Profile update functions, batch expensive operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Timing desynchronization"}),(0,s.jsx)(n.td,{children:"Inconsistent game state"}),(0,s.jsx)(n.td,{children:"Check mixing of wall time and simulation time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Memory leaks in update system"}),(0,s.jsx)(n.td,{children:"Growing memory usage"}),(0,s.jsx)(n.td,{children:"Ensure StopUpdatingComponent calls on cleanup"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Long update failures"}),(0,s.jsx)(n.td,{children:"Incorrect state after time skip"}),(0,s.jsx)(n.td,{children:"Implement proper OnLongUpdate handlers"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"debugging-infrastructure",children:"Debugging Infrastructure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use profiler integration within update loops to identify performance bottlenecks"}),"\n",(0,s.jsx)(n.li,{children:"Enable timing debug output to verify update frequency and execution order"}),"\n",(0,s.jsx)(n.li,{children:"Monitor component registration tables for proper cleanup and lifecycle management"}),"\n",(0,s.jsx)(n.li,{children:"Validate timing consistency across different update types during development"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"key-metrics",children:"Key Metrics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Update loop execution time per frame"}),"\n",(0,s.jsx)(n.li,{children:"Component registration count and cleanup efficiency"}),"\n",(0,s.jsx)(n.li,{children:"Wall time vs simulation time synchronization accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Long update processing duration and success rate"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Batch component updates by type to improve cache locality"}),"\n",(0,s.jsx)(n.li,{children:"Use update timers to reduce unnecessary computation frequency"}),"\n",(0,s.jsx)(n.li,{children:"Implement priority-based update scheduling for critical components"}),"\n",(0,s.jsx)(n.li,{children:"Profile and optimize expensive update operations with targeted improvements"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"migration-notes",children:"Migration Notes"}),"\n",(0,s.jsx)(n.h3,{id:"from-previous-versions",children:"From Previous Versions"}),"\n",(0,s.jsx)(n.p,{children:"Runtime infrastructure maintains compatibility with existing component update patterns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Legacy update registration functions continue to work with current system"}),"\n",(0,s.jsx)(n.li,{children:"Timing constants remain stable across build versions"}),"\n",(0,s.jsx)(n.li,{children:"Component lifecycle patterns preserve existing behavior"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"deprecated-features",children:"Deprecated Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Direct manipulation of update lists should migrate to provided registration functions"}),"\n",(0,s.jsx)(n.li,{children:"Manual timing calculations should use provided time query functions"}),"\n",(0,s.jsx)(n.li,{children:"Custom update loop implementations should integrate with standard update types"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"contributing",children:"Contributing"}),"\n",(0,s.jsx)(n.h3,{id:"adding-new-runtime-features",children:"Adding New Runtime Features"}),"\n",(0,s.jsx)(n.p,{children:"When extending runtime infrastructure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Follow established update registration patterns for new component types"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper cleanup procedures for any new timing or scheduling features"}),"\n",(0,s.jsx)(n.li,{children:"Ensure thread safety for operations that might affect update loop execution"}),"\n",(0,s.jsx)(n.li,{children:"Document performance characteristics and resource usage for new runtime features"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"documentation-standards",children:"Documentation Standards"}),"\n",(0,s.jsx)(n.p,{children:"Runtime infrastructure documentation should:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Include timing behavior and performance impact for all functions"}),"\n",(0,s.jsx)(n.li,{children:"Provide complete lifecycle examples showing proper registration and cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Document interaction patterns between different update types"}),"\n",(0,s.jsx)(n.li,{children:"Cross-reference integration points with dependent systems"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"code-review-checklist",children:"Code Review Checklist"}),"\n",(0,s.jsx)(n.p,{children:"Before contributing runtime infrastructure changes:"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify update registration and cleanup procedures work correctly"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test timing accuracy and performance impact under load"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Validate compatibility with existing component update patterns"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Ensure proper handling of pause/resume states"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Document integration requirements for dependent systems"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test long update and time skip functionality thoroughly"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);