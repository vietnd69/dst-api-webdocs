"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[7110],{2965:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api-vanilla/examples/resource-usage","title":"Reducing Resource Usage","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/examples/resource-usage.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/resource-usage","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/resource-usage","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"id":"resource-usage","title":"Reducing Resource Usage","sidebar_position":11,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Networking and Multiplayer","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/networking-mod"},"next":{"title":"Optimizing Network Traffic","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/network-optimization"}}');var a=t(4848),s=t(8453);const l={id:"resource-usage",title:"Reducing Resource Usage",sidebar_position:11,last_updated:new Date("2023-07-06T00:00:00.000Z")},r="Reducing Resource Usage in Mods",o={},c=[{value:"Understanding Resource Constraints",id:"understanding-resource-constraints",level:2},{value:"Memory Optimization Techniques",id:"memory-optimization-techniques",level:2},{value:"1. Avoid Table Bloat",id:"1-avoid-table-bloat",level:3},{value:"2. Implement Object Pooling",id:"2-implement-object-pooling",level:3},{value:"3. Use Sparse Data Structures",id:"3-use-sparse-data-structures",level:3},{value:"4. Minimize Closure Creation",id:"4-minimize-closure-creation",level:3},{value:"CPU Optimization Techniques",id:"cpu-optimization-techniques",level:2},{value:"1. Defer Expensive Calculations",id:"1-defer-expensive-calculations",level:3},{value:"2. Use Lookup Tables for Expensive Calculations",id:"2-use-lookup-tables-for-expensive-calculations",level:3},{value:"3. Throttle Update Frequency Based on Importance",id:"3-throttle-update-frequency-based-on-importance",level:3},{value:"4. Implement Dirty Flags",id:"4-implement-dirty-flags",level:3},{value:"Network Bandwidth Optimization",id:"network-bandwidth-optimization",level:2},{value:"1. Prioritize Network Updates",id:"1-prioritize-network-updates",level:3},{value:"2. Implement Delta Compression",id:"2-implement-delta-compression",level:3},{value:"3. Batch Network Updates",id:"3-batch-network-updates",level:3},{value:"File Size Optimization",id:"file-size-optimization",level:2},{value:"1. Optimize Assets",id:"1-optimize-assets",level:3},{value:"2. Split Mods into Modules",id:"2-split-mods-into-modules",level:3},{value:"3. Use Runtime Generation",id:"3-use-runtime-generation",level:3},{value:"Practical Example: Optimizing a Weather Mod",id:"practical-example-optimizing-a-weather-mod",level:2},{value:"Original Implementation (Resource-Heavy)",id:"original-implementation-resource-heavy",level:3},{value:"Optimized Implementation",id:"optimized-implementation",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"reducing-resource-usage-in-mods",children:"Reducing Resource Usage in Mods"})}),"\n",(0,a.jsx)(n.p,{children:"This guide focuses on strategies to minimize resource consumption in Don't Starve Together mods, ensuring they run efficiently on a variety of hardware configurations and server environments."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-resource-constraints",children:"Understanding Resource Constraints"}),"\n",(0,a.jsx)(n.p,{children:"When developing mods for Don't Starve Together, it's important to consider various resource constraints:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Usage"}),": Excessive memory consumption can lead to game crashes or degraded performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CPU Utilization"}),": High CPU usage causes frame rate drops and gameplay lag"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Network Bandwidth"}),": In multiplayer, network traffic can become a bottleneck"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"File Size"}),": Large mods take longer to download and may deter players from installing"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"memory-optimization-techniques",children:"Memory Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"1-avoid-table-bloat",children:"1. Avoid Table Bloat"}),"\n",(0,a.jsx)(n.p,{children:"Tables in Lua are the primary data structure, but they can consume significant memory if not managed properly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Creating new tables constantly\nfunction OnUpdate()\n    -- This creates a new table every update\n    local nearby_entities = {}\n    \n    -- Fill with data\n    for i = 1, 100 do\n        nearby_entities[i] = {\n            id = i,\n            position = {x = i, y = 0, z = i},\n            data = "Entity " .. i\n        }\n    end\n    \n    -- Process data\n    ProcessEntities(nearby_entities)\n    \n    -- Table becomes garbage after function ends\nend\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Reuse tables\nlocal nearby_entities = {} -- Defined once outside the function\n\nfunction OnUpdate()\n    -- Clear the table instead of creating a new one\n    for k in pairs(nearby_entities) do\n        nearby_entities[k] = nil\n    end\n    \n    -- Fill with data\n    for i = 1, 100 do\n        nearby_entities[i] = nearby_entities[i] or {} -- Reuse existing subtable if available\n        local entity = nearby_entities[i]\n        entity.id = i\n        entity.position = entity.position or {} -- Reuse position table\n        entity.position.x = i\n        entity.position.y = 0\n        entity.position.z = i\n        entity.data = "Entity " .. i\n    end\n    \n    -- Process data\n    ProcessEntities(nearby_entities)\n    \n    -- Table is reused in next update\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-implement-object-pooling",children:"2. Implement Object Pooling"}),"\n",(0,a.jsx)(n.p,{children:"For frequently created and destroyed objects, use object pooling to reduce memory churn:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Object pool implementation\nlocal ProjectilePool = {\n    active = {},\n    inactive = {},\n}\n\nfunction ProjectilePool:Get()\n    local projectile\n    \n    if #self.inactive > 0 then\n        -- Reuse an inactive projectile\n        projectile = table.remove(self.inactive)\n    else\n        -- Create a new projectile if none available\n        projectile = {\n            position = {x = 0, y = 0, z = 0},\n            velocity = {x = 0, y = 0, z = 0},\n            active_time = 0\n        }\n    end\n    \n    table.insert(self.active, projectile)\n    return projectile\nend\n\nfunction ProjectilePool:Release(projectile)\n    for i, p in ipairs(self.active) do\n        if p == projectile then\n            table.remove(self.active, i)\n            table.insert(self.inactive, projectile)\n            return\n        end\n    end\nend\n\n-- Usage example\nfunction FireProjectile(start_pos, direction)\n    local projectile = ProjectilePool:Get()\n    \n    -- Reset properties\n    projectile.position.x = start_pos.x\n    projectile.position.y = start_pos.y\n    projectile.position.z = start_pos.z\n    \n    projectile.velocity.x = direction.x * 10\n    projectile.velocity.y = direction.y * 10\n    projectile.velocity.z = direction.z * 10\n    \n    projectile.active_time = 0\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-use-sparse-data-structures",children:"3. Use Sparse Data Structures"}),"\n",(0,a.jsx)(n.p,{children:"For large data sets where most entries are empty, use sparse data structures:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Dense grid representation\nlocal world_grid = {}\nfor x = -1000, 1000 do\n    world_grid[x] = {}\n    for z = -1000, 1000 do\n        world_grid[x][z] = 0 -- Default value\n    end\nend\n\n-- Set a few values\nworld_grid[10][20] = 1\nworld_grid[50][60] = 2\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Sparse grid representation\nlocal world_grid = {}\n\n-- Helper functions\nfunction SetGridValue(grid, x, z, value)\n    grid[x] = grid[x] or {}\n    grid[x][z] = value\nend\n\nfunction GetGridValue(grid, x, z)\n    return (grid[x] and grid[x][z]) or 0 -- Default value\nend\n\n-- Set values only where needed\nSetGridValue(world_grid, 10, 20, 1)\nSetGridValue(world_grid, 50, 60, 2)\n\n-- Get a value\nlocal value = GetGridValue(world_grid, 10, 20) -- Returns 1\nlocal default_value = GetGridValue(world_grid, 5, 5) -- Returns 0\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-minimize-closure-creation",children:"4. Minimize Closure Creation"}),"\n",(0,a.jsx)(n.p,{children:"Closures that capture large environments can consume significant memory:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Creating many closures that capture the environment\nfunction CreateEntityProcessors(entities)\n    local processors = {}\n    \n    for i, entity in ipairs(entities) do\n        -- This creates a new closure for each entity, capturing 'entity'\n        processors[i] = function()\n            ProcessEntity(entity)\n        end\n    end\n    \n    return processors\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Use a single function with parameters\nfunction ProcessEntityById(entity_id)\n    local entity = entities[entity_id]\n    ProcessEntity(entity)\nend\n\nfunction CreateEntityProcessors(entities)\n    local processor_ids = {}\n    \n    for i, entity in ipairs(entities) do\n        processor_ids[i] = entity.id\n    end\n    \n    return processor_ids\nend\n\n-- Usage\nlocal ids = CreateEntityProcessors(entities)\nfor _, id in ipairs(ids) do\n    ProcessEntityById(id)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cpu-optimization-techniques",children:"CPU Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"1-defer-expensive-calculations",children:"1. Defer Expensive Calculations"}),"\n",(0,a.jsx)(n.p,{children:"Instead of calculating everything immediately, defer calculations until they're needed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Calculating everything upfront\nfunction UpdateCreature(creature)\n    -- Calculate all possible paths\n    local paths = CalculateAllPaths(creature)\n    \n    -- Calculate visibility for all entities\n    local visible_entities = CalculateAllVisibleEntities(creature)\n    \n    -- Calculate all possible interactions\n    local possible_interactions = CalculateAllInteractions(creature, visible_entities)\n    \n    -- Actually decide what to do\n    local chosen_action = ChooseBestAction(creature, paths, visible_entities, possible_interactions)\n    \n    -- Execute just one action\n    ExecuteAction(creature, chosen_action)\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Calculate only what\'s needed\nfunction UpdateCreature(creature)\n    -- First determine what type of action is needed\n    local action_type = DetermineActionType(creature)\n    \n    if action_type == "MOVE" then\n        -- Only calculate paths if moving\n        local path = CalculateBestPath(creature)\n        ExecuteMovement(creature, path)\n    elseif action_type == "INTERACT" then\n        -- Only calculate visible entities if interacting\n        local visible_entities = CalculateVisibleEntities(creature)\n        local target = ChooseInteractionTarget(creature, visible_entities)\n        ExecuteInteraction(creature, target)\n    elseif action_type == "IDLE" then\n        -- Do minimal work for idle creatures\n        ExecuteIdleBehavior(creature)\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-lookup-tables-for-expensive-calculations",children:"2. Use Lookup Tables for Expensive Calculations"}),"\n",(0,a.jsx)(n.p,{children:"For calculations that are used repeatedly with the same inputs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Recalculating values repeatedly\nfunction GetDamageMultiplier(weapon_type, target_type)\n    -- Complex calculation based on weapon and target types\n    return CalculateDamageMultiplier(weapon_type, target_type)\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Use lookup tables\nlocal damage_multipliers = {\n    sword = {\n        spider = 1.5,\n        skeleton = 1.0,\n        ghost = 0.5,\n        -- other target types...\n    },\n    spear = {\n        spider = 1.2,\n        skeleton = 1.3,\n        ghost = 0.3,\n        -- other target types...\n    },\n    -- other weapon types...\n}\n\nfunction GetDamageMultiplier(weapon_type, target_type)\n    -- Fast table lookup instead of calculation\n    return (damage_multipliers[weapon_type] and damage_multipliers[weapon_type][target_type]) or 1.0\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-throttle-update-frequency-based-on-importance",children:"3. Throttle Update Frequency Based on Importance"}),"\n",(0,a.jsx)(n.p,{children:"Not all systems need to update at the same frequency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Different update frequencies for different systems\nfunction InitializeUpdateSystem()\n    -- Critical systems update frequently\n    TheWorld:DoPeriodicTask(0.1, UpdateCriticalSystems)\n    \n    -- Important but not critical systems\n    TheWorld:DoPeriodicTask(0.5, UpdateImportantSystems)\n    \n    -- Background systems can update slowly\n    TheWorld:DoPeriodicTask(1.0, UpdateBackgroundSystems)\n    \n    -- Very infrequent updates for non-critical systems\n    TheWorld:DoPeriodicTask(5.0, UpdateNonCriticalSystems)\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-implement-dirty-flags",children:"4. Implement Dirty Flags"}),"\n",(0,a.jsx)(n.p,{children:"Only update what has changed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local StatusComponent = Class(function(self, inst)\n    self.inst = inst\n    self.values = {\n        health = 100,\n        hunger = 100,\n        sanity = 100\n    }\n    self.dirty = {\n        health = true,\n        hunger = true,\n        sanity = true\n    }\n    \n    self.inst:DoPeriodicTask(0.5, function() self:Update() end)\nend)\n\nfunction StatusComponent:SetValue(key, value)\n    if self.values[key] ~= value then\n        self.values[key] = value\n        self.dirty[key] = true\n    end\nend\n\nfunction StatusComponent:Update()\n    -- Only update what has changed\n    if self.dirty.health then\n        self:UpdateHealthDisplay()\n        self.dirty.health = false\n    end\n    \n    if self.dirty.hunger then\n        self:UpdateHungerDisplay()\n        self.dirty.hunger = false\n    end\n    \n    if self.dirty.sanity then\n        self:UpdateSanityDisplay()\n        self.dirty.sanity = false\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"network-bandwidth-optimization",children:"Network Bandwidth Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"1-prioritize-network-updates",children:"1. Prioritize Network Updates"}),"\n",(0,a.jsx)(n.p,{children:"Not all data needs to be synchronized at the same frequency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local SyncComponent = Class(function(self, inst)\n    self.inst = inst\n    self.last_sync = {\n        position = 0,\n        animation = 0,\n        status = 0\n    }\n    self.sync_frequency = {\n        position = 0.1,  -- Position updates frequently\n        animation = 0.5, -- Animation state less frequently\n        status = 1.0     -- Status updates infrequently\n    }\n    \n    self.inst:DoPeriodicTask(0.1, function() self:TrySyncData() end)\nend)\n\nfunction SyncComponent:TrySyncData()\n    local current_time = GetTime()\n    \n    -- Check if it's time to sync each data type\n    if current_time - self.last_sync.position >= self.sync_frequency.position then\n        self:SyncPosition()\n        self.last_sync.position = current_time\n    end\n    \n    if current_time - self.last_sync.animation >= self.sync_frequency.animation then\n        self:SyncAnimation()\n        self.last_sync.animation = current_time\n    end\n    \n    if current_time - self.last_sync.status >= self.sync_frequency.status then\n        self:SyncStatus()\n        self.last_sync.status = current_time\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-implement-delta-compression",children:"2. Implement Delta Compression"}),"\n",(0,a.jsx)(n.p,{children:"Send only what has changed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local NetworkSync = Class(function(self, inst)\n    self.inst = inst\n    self.last_sent_state = {\n        position = {x=0, y=0, z=0},\n        health = 100,\n        inventory = {}\n    }\n    \n    self.inst:DoPeriodicTask(0.5, function() self:SyncState() end)\nend)\n\nfunction NetworkSync:SyncState()\n    local current_state = self:GetCurrentState()\n    local delta = self:CalculateDelta(self.last_sent_state, current_state)\n    \n    -- Only send if there are changes\n    if next(delta) ~= nil then\n        self:SendStateDelta(delta)\n        self.last_sent_state = current_state\n    end\nend\n\nfunction NetworkSync:CalculateDelta(old_state, new_state)\n    local delta = {}\n    \n    -- Check position change\n    if math.abs(old_state.position.x - new_state.position.x) > 0.1 or\n       math.abs(old_state.position.z - new_state.position.z) > 0.1 then\n        delta.position = new_state.position\n    end\n    \n    -- Check health change\n    if old_state.health ~= new_state.health then\n        delta.health = new_state.health\n    end\n    \n    -- Check inventory changes\n    for item, count in pairs(new_state.inventory) do\n        if old_state.inventory[item] ~= count then\n            delta.inventory = delta.inventory or {}\n            delta.inventory[item] = count\n        end\n    end\n    \n    return delta\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-batch-network-updates",children:"3. Batch Network Updates"}),"\n",(0,a.jsx)(n.p,{children:"Group multiple updates into a single network message:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local NetworkBatcher = Class(function(self, inst)\n    self.inst = inst\n    self.pending_updates = {}\n    self.last_send_time = 0\n    self.send_interval = 0.5\n    \n    self.inst:DoPeriodicTask(0.1, function() self:TrySendBatch() end)\nend)\n\nfunction NetworkBatcher:QueueUpdate(entity_id, data)\n    self.pending_updates[entity_id] = self.pending_updates[entity_id] or {}\n    \n    -- Merge the new data with any existing queued data\n    for k, v in pairs(data) do\n        self.pending_updates[entity_id][k] = v\n    end\nend\n\nfunction NetworkBatcher:TrySendBatch()\n    local current_time = GetTime()\n    \n    -- Send batch if it's time or if we have too many updates\n    if current_time - self.last_send_time >= self.send_interval or #self.pending_updates > 10 then\n        if next(self.pending_updates) ~= nil then\n            self:SendBatch(self.pending_updates)\n            self.pending_updates = {}\n            self.last_send_time = current_time\n        end\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"file-size-optimization",children:"File Size Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"1-optimize-assets",children:"1. Optimize Assets"}),"\n",(0,a.jsx)(n.p,{children:"Reduce the size of included assets:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Compress textures appropriately"}),"\n",(0,a.jsx)(n.li,{children:"Use audio formats with good compression"}),"\n",(0,a.jsx)(n.li,{children:"Consider using texture atlases instead of individual images"}),"\n",(0,a.jsx)(n.li,{children:"Use lower resolution textures for less important elements"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-split-mods-into-modules",children:"2. Split Mods into Modules"}),"\n",(0,a.jsx)(n.p,{children:"For large mods, consider splitting into core and optional modules:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\nlocal function LoadOptionalModule(name)\n    local success, module = pcall(require, "modules/" .. name)\n    if success then\n        print("Loaded optional module: " .. name)\n        return module\n    else\n        print("Optional module not available: " .. name)\n        return nil\n    end\nend\n\n-- Core functionality always loaded\nlocal core = require("modules/core")\n\n-- Optional high-resolution textures\nlocal high_res = LoadOptionalModule("highres")\n\n-- Optional additional content\nlocal expansion = LoadOptionalModule("expansion")\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-use-runtime-generation",children:"3. Use Runtime Generation"}),"\n",(0,a.jsx)(n.p,{children:"Generate content procedurally instead of storing it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Storing many pre-made variations\nlocal tree_variations = {\n    {branches = {{x=0, y=1}, {x=1, y=2}, {x=-1, y=2}, {x=0.5, y=3}, {x=-0.5, y=3}}},\n    {branches = {{x=0, y=1}, {x=2, y=1.5}, {x=-1, y=2}, {x=0, y=3}}},\n    {branches = {{x=0, y=1}, {x=1, y=1}, {x=-1, y=1}, {x=0, y=2}, {x=0, y=3}}},\n    -- Many more variations...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Generate variations procedurally\nfunction GenerateTreeVariation(seed)\n    math.randomseed(seed)\n    \n    local branches = {{x=0, y=1}} -- Start with trunk\n    local branch_count = math.random(3, 6)\n    \n    for i = 1, branch_count do\n        table.insert(branches, {\n            x = math.random(-10, 10) / 10,\n            y = 1 + math.random(0, 20) / 10\n        })\n    end\n    \n    return {branches = branches}\nend\n\n-- Generate only when needed\nfunction GetTreeVariation(tree_id)\n    return GenerateTreeVariation(tree_id)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"practical-example-optimizing-a-weather-mod",children:"Practical Example: Optimizing a Weather Mod"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at a practical example of optimizing a weather mod that was consuming too many resources:"}),"\n",(0,a.jsx)(n.h3,{id:"original-implementation-resource-heavy",children:"Original Implementation (Resource-Heavy)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Weather effect system with high resource usage\nlocal WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Track all entities in the world\n    self.affected_entities = {}\n    \n    -- Create many particle effects\n    self.particles = {}\n    for i = 1, 1000 do\n        local particle = SpawnPrefab("weather_particle")\n        table.insert(self.particles, particle)\n    end\n    \n    -- Update every entity every frame\n    self.inst:DoPeriodicTask(0, function()\n        self:UpdateAllEntities()\n        self:UpdateAllParticles()\n    end)\n    \n    -- Network sync every frame\n    if TheWorld.ismastersim then\n        self.inst:DoPeriodicTask(0, function()\n            self:SyncToClients()\n        end)\n    end\nend)\n\nfunction WeatherSystem:UpdateAllEntities()\n    -- Find all entities in the world\n    local x, y, z = Vector3(ThePlayer.Transform:GetWorldPosition())\n    local entities = TheSim:FindEntities(x, y, z, 100)\n    \n    -- Process every entity\n    for _, entity in ipairs(entities) do\n        self:ApplyWeatherEffect(entity)\n    end\nend\n\nfunction WeatherSystem:UpdateAllParticles()\n    -- Update every particle every frame\n    for _, particle in ipairs(self.particles) do\n        self:UpdateParticle(particle)\n    end\nend\n\nfunction WeatherSystem:SyncToClients()\n    -- Send full state to all clients\n    SendModRPCToClients(GetClientModRPC("WeatherMod", "SyncWeather"), \n                        json.encode(self:GetFullState()))\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optimized-implementation",children:"Optimized Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Optimized weather system\nlocal WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Track entities by distance from player\n    self.affected_entities = {\n        near = {},   -- Updated frequently\n        medium = {}, -- Updated less frequently\n        far = {}     -- Updated rarely\n    }\n    \n    -- Particle pool\n    self.particle_pool = {\n        active = {},\n        inactive = {},\n        max_active = 200 -- Limit active particles\n    }\n    \n    -- Create a smaller initial pool\n    for i = 1, 50 do\n        local particle = SpawnPrefab("weather_particle")\n        particle:Hide()\n        table.insert(self.particle_pool.inactive, particle)\n    end\n    \n    -- Update entities at different rates\n    self.inst:DoPeriodicTask(0.1, function() self:UpdateNearEntities() end)\n    self.inst:DoPeriodicTask(0.5, function() self:UpdateMediumEntities() end)\n    self.inst:DoPeriodicTask(2.0, function() self:UpdateFarEntities() end)\n    \n    -- Update particles in batches\n    self.inst:DoPeriodicTask(0.1, function() self:UpdateParticleBatch() end)\n    \n    -- Network sync with throttling\n    if TheWorld.ismastersim then\n        self.last_sync = 0\n        self.sync_interval = 0.5\n        self.dirty = false\n        \n        self.inst:DoPeriodicTask(0.1, function() self:TrySyncToClients() end)\n    end\nend)\n\nfunction WeatherSystem:CategorizeEntity(entity)\n    local player = ThePlayer\n    if not player then return "far" end\n    \n    local dist = entity:GetDistanceSqToPoint(player.Transform:GetWorldPosition())\n    \n    if dist < 20*20 then\n        return "near"\n    elseif dist < 50*50 then\n        return "medium"\n    else\n        return "far"\n    end\nend\n\nfunction WeatherSystem:UpdateEntityCategories()\n    local player = ThePlayer\n    if not player then return end\n    \n    -- Only recategorize periodically\n    local x, y, z = player.Transform:GetWorldPosition()\n    local entities = TheSim:FindEntities(x, y, z, 100, nil, {"INLIMBO"})\n    \n    -- Clear categories\n    self.affected_entities.near = {}\n    self.affected_entities.medium = {}\n    self.affected_entities.far = {}\n    \n    -- Categorize entities by distance\n    for _, entity in ipairs(entities) do\n        local category = self:CategorizeEntity(entity)\n        table.insert(self.affected_entities[category], entity)\n    end\nend\n\nfunction WeatherSystem:UpdateNearEntities()\n    for _, entity in ipairs(self.affected_entities.near) do\n        if entity:IsValid() then\n            self:ApplyWeatherEffect(entity, 1.0) -- Full effect\n        end\n    end\nend\n\nfunction WeatherSystem:UpdateMediumEntities()\n    for _, entity in ipairs(self.affected_entities.medium) do\n        if entity:IsValid() then\n            self:ApplyWeatherEffect(entity, 0.7) -- Reduced effect\n        end\n    end\n    \n    -- Recategorize entities periodically\n    self:UpdateEntityCategories()\nend\n\nfunction WeatherSystem:UpdateFarEntities()\n    for _, entity in ipairs(self.affected_entities.far) do\n        if entity:IsValid() then\n            self:ApplyWeatherEffect(entity, 0.3) -- Minimal effect\n        end\n    end\nend\n\nfunction WeatherSystem:GetParticle()\n    -- Reuse an inactive particle if available\n    if #self.particle_pool.inactive > 0 then\n        local particle = table.remove(self.particle_pool.inactive)\n        particle:Show()\n        table.insert(self.particle_pool.active, particle)\n        return particle\n    end\n    \n    -- Only create new particles if under the limit\n    if #self.particle_pool.active < self.particle_pool.max_active then\n        local particle = SpawnPrefab("weather_particle")\n        table.insert(self.particle_pool.active, particle)\n        return particle\n    end\n    \n    -- Return nil if at the limit\n    return nil\nend\n\nfunction WeatherSystem:ReleaseParticle(particle)\n    for i, p in ipairs(self.particle_pool.active) do\n        if p == particle then\n            table.remove(self.particle_pool.active, i)\n            particle:Hide()\n            table.insert(self.particle_pool.inactive, particle)\n            return\n        end\n    end\nend\n\nfunction WeatherSystem:UpdateParticleBatch()\n    -- Process particles in batches\n    local batch_size = 20\n    local count = 0\n    \n    for i = 1, math.min(batch_size, #self.particle_pool.active) do\n        local particle = self.particle_pool.active[i]\n        if particle:IsValid() then\n            if not self:UpdateParticle(particle) then\n                self:ReleaseParticle(particle)\n            end\n        else\n            self:ReleaseParticle(particle)\n        end\n        count = count + 1\n    end\n    \n    -- Spawn new particles if needed\n    local player = ThePlayer\n    if player and count < batch_size then\n        local x, y, z = player.Transform:GetWorldPosition()\n        for i = 1, math.random(1, 3) do\n            local particle = self:GetParticle()\n            if particle then\n                self:InitializeParticle(particle, x, y, z)\n            end\n        end\n    end\nend\n\nfunction WeatherSystem:TrySyncToClients()\n    if not TheWorld.ismastersim then return end\n    \n    local current_time = GetTime()\n    \n    -- Only sync if dirty and not too recent\n    if self.dirty and current_time - self.last_sync >= self.sync_interval then\n        -- Send only changed data\n        SendModRPCToClients(GetClientModRPC("WeatherMod", "SyncWeather"), \n                           json.encode(self:GetDeltaState()))\n        self.last_sync = current_time\n        self.dirty = false\n    end\nend\n\nfunction WeatherSystem:MarkDirty()\n    self.dirty = true\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"By implementing these resource optimization techniques, your mods will run more efficiently, use less memory, and provide a better experience for players. Remember to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Measure First"}),": Profile your mod to identify the biggest resource consumers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize Strategically"}),": Focus on the areas that will give the biggest improvements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test Thoroughly"}),": Ensure optimizations don't introduce new bugs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Balance Performance and Features"}),": Sometimes it's better to scale back features than to include poorly performing ones"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With these approaches, you can create complex, feature-rich mods that still run smoothly on a variety of hardware configurations."}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/optimization",children:"Performance Optimization"})," - General performance optimization techniques"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," - More details on networking in DST"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/event-system",children:"Event System"})," - Using events efficiently"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/entity-system",children:"Entity System"})," - Working with entities efficiently"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var i=t(6540);const a={},s=i.createContext(a);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);