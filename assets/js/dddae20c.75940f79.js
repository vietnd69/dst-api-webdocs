"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[7664],{8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var a=t(6540);const o={},i=a.createContext(o);function s(n){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),a.createElement(i.Provider,{value:e},n.children)}},9361:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api-vanilla/core/component-interactions","title":"Component Interactions and Data Flow","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/core/component-interactions.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/component-interactions","permalink":"/dst-api-webdocs/docs/api-vanilla/core/component-interactions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"component-interactions","title":"Component Interactions and Data Flow","sidebar_position":3,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Component System","permalink":"/dst-api-webdocs/docs/api-vanilla/core/component-system"},"next":{"title":"EntityScript","permalink":"/dst-api-webdocs/docs/api-vanilla/core/entityscript"}}');var o=t(4848),i=t(8453);const s={id:"component-interactions",title:"Component Interactions and Data Flow",sidebar_position:3,last_updated:new Date("2023-07-06T00:00:00.000Z")},r="Component Interactions and Data Flow",l={},c=[{value:"Core Component Data Flow",id:"core-component-data-flow",level:2},{value:"Key Interaction Patterns",id:"key-interaction-patterns",level:2},{value:"Combat and Health System",id:"combat-and-health-system",level:3},{value:"Inventory and Item System",id:"inventory-and-item-system",level:3},{value:"Survival System",id:"survival-system",level:3},{value:"Resource and Crafting System",id:"resource-and-crafting-system",level:3},{value:"Event-Based Communication",id:"event-based-communication",level:2},{value:"Event-Based Component Communication Examples",id:"event-based-component-communication-examples",level:2},{value:"Example 1: Health and State Graph Communication",id:"example-1-health-and-state-graph-communication",level:3},{value:"Example 2: Hunger and Sanity Interaction via Events",id:"example-2-hunger-and-sanity-interaction-via-events",level:3},{value:"Example 3: Inventory Changes Affecting Equipment Stats",id:"example-3-inventory-changes-affecting-equipment-stats",level:3},{value:"Example 4: Weather Events Affecting Multiple Components",id:"example-4-weather-events-affecting-multiple-components",level:3},{value:"Example 5: Component Communication via Custom Events",id:"example-5-component-communication-via-custom-events",level:3},{value:"Best Practices for Event-Based Communication",id:"best-practices-for-event-based-communication",level:3},{value:"Replication System",id:"replication-system",level:2},{value:"Understanding Component Dependencies",id:"understanding-component-dependencies",level:2},{value:"Health, Combat, and Inventory Interaction Examples",id:"health-combat-and-inventory-interaction-examples",level:2},{value:"Example 1: Equipping a Weapon and Attacking",id:"example-1-equipping-a-weapon-and-attacking",level:3},{value:"Example 2: Using Armor to Reduce Damage",id:"example-2-using-armor-to-reduce-damage",level:3},{value:"Example 3: Healing Items in Inventory",id:"example-3-healing-items-in-inventory",level:3},{value:"Common Design Patterns When Working with Multiple Components",id:"common-design-patterns-when-working-with-multiple-components",level:2},{value:"1. Component Composition Pattern",id:"1-component-composition-pattern",level:3},{value:"2. Component Dependency Injection",id:"2-component-dependency-injection",level:3},{value:"3. Component Observer Pattern",id:"3-component-observer-pattern",level:3},{value:"4. Component Decorator Pattern",id:"4-component-decorator-pattern",level:3},{value:"5. Component Facade Pattern",id:"5-component-facade-pattern",level:3},{value:"6. Component State Machine Pattern",id:"6-component-state-machine-pattern",level:3},{value:"7. Component Proxy Pattern",id:"7-component-proxy-pattern",level:3}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:(0,o.jsx)(e.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"component-interactions-and-data-flow",children:"Component Interactions and Data Flow"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.em,{children:"API Version: 619045"})}),"\n",(0,o.jsx)(e.p,{children:"This document provides a comprehensive overview of how components interact with each other in Don't Starve Together's API. Understanding these interactions is crucial for effective modding and creating complex entity behaviors."}),"\n",(0,o.jsx)(e.h2,{id:"core-component-data-flow",children:"Core Component Data Flow"}),"\n",(0,o.jsx)(e.p,{children:"The diagram below illustrates the primary data flow between core components in Don't Starve Together:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    %% Core Component Nodes\n    Health[Health Component]\n    Combat[Combat Component]\n    Inventory[Inventory Component]\n    Hunger[Hunger Component]\n    Sanity[Sanity Component]\n    Temperature[Temperature Component]\n    Locomotor[Locomotor Component]\n    Equippable[Equippable Component]\n    Weapon[Weapon Component]\n    Armor[Armor Component]\n    Edible[Edible Component]\n    Eater[Eater Component]\n    Stackable[Stackable Component]\n    Container[Container Component]\n    LootDropper[LootDropper Component]\n    Workable[Workable Component]\n    Builder[Builder Component]\n    \n    %% Component Interactions - Combat System\n    Combat --\x3e|Deals damage| Health\n    Weapon --\x3e|Modifies damage| Combat\n    Armor --\x3e|Reduces damage| Health\n    Health --\x3e|Death event| LootDropper\n    Health --\x3e|Death event| Combat\n    \n    %% Component Interactions - Inventory System\n    Inventory --\x3e|Equips items| Equippable\n    Equippable --\x3e|Provides buffs| Combat\n    Equippable --\x3e|Provides buffs| Armor\n    Equippable --\x3e|Provides buffs| Temperature\n    Inventory --\x3e|Stores items| Stackable\n    Inventory --\x3e|Uses| Container\n    Container --\x3e|Transfers items| Inventory\n    \n    %% Component Interactions - Survival System\n    Hunger --\x3e|Affects| Health\n    Sanity --\x3e|Affects behavior| Combat\n    Temperature --\x3e|Extreme temps damage| Health\n    Eater --\x3e|Consumes| Edible\n    Edible --\x3e|Restores| Hunger\n    Edible --\x3e|Restores| Health\n    Edible --\x3e|Restores| Sanity\n    \n    %% Component Interactions - Movement System\n    Locomotor --\x3e|Controls movement for| Combat\n    Temperature --\x3e|Slows| Locomotor\n    Hunger --\x3e|Low hunger slows| Locomotor\n    \n    %% Component Interactions - Resource System\n    Workable --\x3e|When worked| LootDropper\n    Builder --\x3e|Creates| Workable\n    Builder --\x3e|Uses items from| Inventory\n"})}),"\n",(0,o.jsx)(e.h2,{id:"key-interaction-patterns",children:"Key Interaction Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"combat-and-health-system",children:"Combat and Health System"}),"\n",(0,o.jsx)(e.p,{children:"The combat system involves several components working together:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Combat \u2192 Health"}),": The Combat component calculates damage and applies it to the target's Health component"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Weapon \u2192 Combat"}),": Weapons modify the damage output of the Combat component"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Armor \u2192 Health"}),": Armor reduces damage received by the Health component"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Health \u2192 LootDropper"}),": When health reaches zero, the death event triggers the LootDropper"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"-- Example: Combat dealing damage to Health\nfunction Combat:DoAttack(target)\n    if target.components.health ~= nil then\n        local damage = self:CalcDamage(target)\n        target.components.health:DoDelta(-damage)\n        \n        if target.components.health:IsDead() then\n            self:OnKill(target)\n        end\n    end\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"inventory-and-item-system",children:"Inventory and Item System"}),"\n",(0,o.jsx)(e.p,{children:"The inventory system manages items and their effects:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Inventory \u2192 Equippable"}),": The Inventory component equips items with the Equippable component"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Equippable \u2192 Various"}),": Equipped items provide buffs to various components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Container \u2194 Inventory"}),": Containers store items and transfer them to/from inventory"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stackable \u2192 Inventory"}),": Stackable items optimize inventory space"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Inventory equipping an item\nfunction Inventory:Equip(item)\n    if item.components.equippable ~= nil then\n        local eslot = item.components.equippable.equipslot\n        local old_item = self:GetEquippedItem(eslot)\n        \n        if old_item ~= nil then\n            self:Unequip(eslot)\n        end\n        \n        item.components.equippable:OnEquip(self.inst)\n        self.equipslots[eslot] = item\n        self.inst:PushEvent("equipped", {item = item, eslot = eslot})\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"survival-system",children:"Survival System"}),"\n",(0,o.jsx)(e.p,{children:"The survival system manages the character's vital stats:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Hunger \u2192 Health"}),": Hunger affects health regeneration and can cause damage when empty"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Temperature \u2192 Health"}),": Extreme temperatures cause damage via the Health component"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Edible \u2192 Various"}),": Food items affect Hunger, Health, and Sanity components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Eater \u2192 Edible"}),": The Eater component consumes items with the Edible component"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Temperature causing damage to Health\nfunction Temperature:DoHurtRateUpdate(dt)\n    if self.inst.components.health ~= nil then\n        if self:IsFreezing() then\n            self.inst.components.health:DoDelta(-self.hurtrate * dt, false, "cold")\n        elseif self:IsOverheating() then\n            self.inst.components.health:DoDelta(-self.overheathurtrate * dt, false, "heat")\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"resource-and-crafting-system",children:"Resource and Crafting System"}),"\n",(0,o.jsx)(e.p,{children:"The resource system handles gathering and crafting:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Workable \u2192 LootDropper"}),": Working on objects (chopping, mining) triggers the LootDropper"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Builder \u2192 Inventory"}),": The Builder component uses items from the Inventory for crafting"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Builder \u2192 Prefabs"}),": The Builder creates new entities based on recipes"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Builder crafting an item\nfunction Builder:DoBuild(recname, pt, rotation, skin)\n    local recipe = GetRecipe(recname)\n    if recipe then\n        if recipe.placer == nil or self:IsBuildBuffered(recname) or self:CanBuild(recname) then\n            self:RemoveIngredients(recipe)\n            local prod = SpawnPrefab(recipe.product, recipe.productdata, skin)\n            if prod then\n                -- Position and configure the crafted item\n                prod.Transform:SetPosition(pt:Get())\n                self.inst:PushEvent("builditem", {item=prod, recipe=recipe})\n                return prod\n            end\n        end\n    end\n    return nil\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"event-based-communication",children:"Event-Based Communication"}),"\n",(0,o.jsx)(e.p,{children:"Many component interactions are event-driven rather than direct function calls. This decouples components and allows for more flexible behavior:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Component A triggers an event\nself.inst:PushEvent("attacked", {attacker = attacker, damage = damage})\n\n-- Component B listens for the event\nself.inst:ListenForEvent("attacked", function(inst, data)\n    -- React to the event\n    print("Attacked by " .. data.attacker.name .. " for " .. data.damage .. " damage")\nend)\n'})}),"\n",(0,o.jsx)(e.p,{children:"Common events that facilitate component communication include:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"death"}),": Triggered when an entity dies"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"attacked"}),": Triggered when an entity is attacked"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"healthdelta"}),": Triggered when health changes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"equip"}),"/",(0,o.jsx)(e.code,{children:"unequip"}),": Triggered when items are equipped/unequipped"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"itemget"}),"/",(0,o.jsx)(e.code,{children:"itemlose"}),": Triggered when items are added/removed from inventory"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"event-based-component-communication-examples",children:"Event-Based Component Communication Examples"}),"\n",(0,o.jsx)(e.p,{children:"Events are the primary way components communicate with each other without creating tight coupling. This section provides detailed examples of how different components use events to interact."}),"\n",(0,o.jsx)(e.h3,{id:"example-1-health-and-state-graph-communication",children:"Example 1: Health and State Graph Communication"}),"\n",(0,o.jsx)(e.p,{children:"When an entity takes damage, the Health component broadcasts events that the State Graph can react to for animations and sound effects:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In the Health component\nfunction Health:DoDelta(amount, overtime, cause, ignore_invincible, afflicter, ignore_absorb)\n    -- Calculate actual damage/healing\n    local old_percent = self:GetPercent()\n    \n    -- Apply health change\n    self.currenthealth = math.clamp(self.currenthealth + amount, 0, self.maxhealth)\n    \n    -- Broadcast the health change event\n    self.inst:PushEvent("healthdelta", {\n        oldpercent = old_percent,\n        newpercent = self:GetPercent(),\n        amount = amount,\n        overtime = overtime,\n        cause = cause,\n        afflicter = afflicter,\n    })\n    \n    -- Check for death\n    if self.currenthealth <= 0 then\n        self.inst:PushEvent("death", {\n            cause = cause,\n            afflicter = afflicter,\n        })\n    end\nend\n\n-- In a State Graph\nlocal states = {\n    State{\n        name = "idle",\n        onenter = function(inst)\n            inst.AnimState:PlayAnimation("idle_loop", true)\n        end,\n    },\n    \n    State{\n        name = "hit",\n        onenter = function(inst)\n            inst.AnimState:PlayAnimation("hit")\n            inst.SoundEmitter:PlaySound("dontstarve/creatures/generic_hit")\n        end,\n        \n        events = {\n            EventHandler("animover", function(inst)\n                inst.sg:GoToState("idle")\n            end),\n        },\n    }\n}\n\n-- Connect the health event to the state graph\nlocal function SetupStateGraph(inst)\n    inst:ListenForEvent("healthdelta", function(inst, data)\n        if data.amount < 0 and not data.overtime then\n            -- Only react to direct damage, not damage over time\n            inst.sg:GoToState("hit")\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-hunger-and-sanity-interaction-via-events",children:"Example 2: Hunger and Sanity Interaction via Events"}),"\n",(0,o.jsx)(e.p,{children:"Hunger can affect sanity through events, creating interconnected survival mechanics:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In the Hunger component\nfunction Hunger:DoDelta(delta, overtime)\n    local old = self.current\n    self.current = math.clamp(self.current + delta, 0, self.max)\n    \n    -- Broadcast hunger change event\n    self.inst:PushEvent("hungerdelta", {\n        oldpercent = old / self.max,\n        newpercent = self.current / self.max,\n        delta = self.current - old,\n        overtime = overtime,\n    })\n    \n    -- Check for extreme hunger\n    if old > 0 and self.current <= 0 then\n        self.inst:PushEvent("startstarving")\n        self.inst:StartUpdatingComponent(self)\n    elseif old <= 0 and self.current > 0 then\n        self.inst:PushEvent("stopstarving")\n    end\nend\n\n-- In the Sanity component, listen for hunger events\nlocal function ConnectHungerToSanity(inst)\n    -- Lose sanity when starving\n    inst:ListenForEvent("startstarving", function(inst)\n        if inst.components.sanity ~= nil then\n            -- Start losing sanity due to starvation\n            inst.components.sanity.external_penalties.hunger = TUNING.SANITY_STARVE_PENALTY\n            inst.components.sanity:RecalculatePenalty()\n        end\n    end)\n    \n    -- Stop losing sanity when no longer starving\n    inst:ListenForEvent("stopstarving", function(inst)\n        if inst.components.sanity ~= nil then\n            -- Remove starvation sanity penalty\n            inst.components.sanity.external_penalties.hunger = 0\n            inst.components.sanity:RecalculatePenalty()\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-3-inventory-changes-affecting-equipment-stats",children:"Example 3: Inventory Changes Affecting Equipment Stats"}),"\n",(0,o.jsx)(e.p,{children:"When items are added or removed from inventory, events can trigger updates to player stats:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In a mod that adds a backpack with speed bonus\nlocal function MakeSpeedBackpack()\n    local inst = CreateEntity()\n    \n    -- Add basic components\n    inst:AddComponent("inventoryitem")\n    inst:AddComponent("equippable")\n    inst.components.equippable.equipslot = EQUIPSLOTS.BODY\n    \n    -- Configure speed bonus\n    inst.components.equippable.walkspeedmult = 1.25 -- 25% speed bonus\n    \n    return inst\nend\n\n-- Set up player to listen for equipment changes\nlocal function SetupPlayerEquipmentListeners(inst)\n    -- Track speed modifiers from equipment\n    inst.equipment_speed_modifiers = {}\n    \n    -- Listen for equip events\n    inst:ListenForEvent("equip", function(inst, data)\n        local item = data.item\n        local slot = data.eslot\n        \n        -- Check for speed modifiers\n        if item.components.equippable ~= nil and item.components.equippable.walkspeedmult ~= nil then\n            -- Store the speed modifier by slot\n            inst.equipment_speed_modifiers[slot] = item.components.equippable.walkspeedmult\n            \n            -- Update locomotor speed if present\n            if inst.components.locomotor ~= nil then\n                inst.components.locomotor:SetExternalSpeedMultiplier(\n                    item, "equipment_speed_" .. slot, item.components.equippable.walkspeedmult\n                )\n            end\n        end\n    end)\n    \n    -- Listen for unequip events\n    inst:ListenForEvent("unequip", function(inst, data)\n        local slot = data.eslot\n        \n        -- Remove speed modifier for this slot\n        if inst.equipment_speed_modifiers[slot] ~= nil then\n            inst.equipment_speed_modifiers[slot] = nil\n            \n            -- Update locomotor speed if present\n            if inst.components.locomotor ~= nil then\n                inst.components.locomotor:RemoveExternalSpeedMultiplier(\n                    data.item, "equipment_speed_" .. slot\n                )\n            end\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-4-weather-events-affecting-multiple-components",children:"Example 4: Weather Events Affecting Multiple Components"}),"\n",(0,o.jsx)(e.p,{children:"Weather changes can trigger events that affect multiple components simultaneously:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In the Weather component\nfunction Weather:StartSnowing()\n    if not self.snow then\n        self.snow = true\n        TheWorld:PushEvent("snowstart")\n    end\nend\n\nfunction Weather:StopSnowing()\n    if self.snow then\n        self.snow = false\n        TheWorld:PushEvent("snowstop")\n    end\nend\n\n-- Different components can react to the same weather events\nlocal function SetupWeatherReactions(inst)\n    -- Temperature component reacts to snow\n    inst:ListenForEvent("snowstart", function(world)\n        if inst.components.temperature ~= nil then\n            -- Snow makes the environment colder\n            inst.components.temperature.current_temp_modifier = -5\n        end\n    end, TheWorld)\n    \n    inst:ListenForEvent("snowstop", function(world)\n        if inst.components.temperature ~= nil then\n            -- Remove cold modifier when snow stops\n            inst.components.temperature.current_temp_modifier = 0\n        end\n    end, TheWorld)\n    \n    -- Locomotor component reacts to snow\n    inst:ListenForEvent("snowstart", function(world)\n        if inst.components.locomotor ~= nil then\n            -- Snow slows movement\n            inst.components.locomotor:SetExternalSpeedMultiplier(inst, "snow", 0.8)\n        end\n    end, TheWorld)\n    \n    inst:ListenForEvent("snowstop", function(world)\n        if inst.components.locomotor ~= nil then\n            -- Remove speed penalty when snow stops\n            inst.components.locomotor:RemoveExternalSpeedMultiplier(inst, "snow")\n        end\n    end, TheWorld)\n    \n    -- Crop component reacts to snow\n    inst:ListenForEvent("snowstart", function(world)\n        if inst.components.crop ~= nil then\n            -- Snow pauses crop growth\n            inst.components.crop:Pause()\n        end\n    end, TheWorld)\n    \n    inst:ListenForEvent("snowstop", function(world)\n        if inst.components.crop ~= nil then\n            -- Resume crop growth when snow stops\n            inst.components.crop:Resume()\n        end\n    end, TheWorld)\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-5-component-communication-via-custom-events",children:"Example 5: Component Communication via Custom Events"}),"\n",(0,o.jsx)(e.p,{children:"Components can define and use custom events for specialized communication:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In a custom sanity aura component\nlocal SanityAura = Class(function(self, inst)\n    self.inst = inst\n    self.aura = 0\n    self.range = 10\n    \n    -- Start broadcasting the aura\n    self.task = self.inst:DoPeriodicTask(1, function() self:PulseAura() end)\nend)\n\nfunction SanityAura:PulseAura()\n    -- Find players in range\n    local x, y, z = self.inst.Transform:GetWorldPosition()\n    local players = TheSim:FindEntities(x, y, z, self.range, {"player"})\n    \n    -- Broadcast custom aura event to nearby players\n    for _, player in ipairs(players) do\n        -- Calculate distance-based intensity\n        local px, py, pz = player.Transform:GetWorldPosition()\n        local dist = math.sqrt((x - px)^2 + (z - pz)^2)\n        local intensity = math.max(0, 1 - (dist / self.range)) * self.aura\n        \n        -- Send the custom event to the player\n        player:PushEvent("sanityadjustment", {\n            amount = intensity,\n            source = self.inst,\n            sanityaura = true\n        })\n    end\nend\n\n-- In the sanity component, listen for the custom event\nfunction Sanity:OnUpdate(dt)\n    -- Process any sanity aura events received\n    self.inst:ListenForEvent("sanityadjustment", function(inst, data)\n        if data.sanityaura and data.amount ~= 0 then\n            -- Apply the sanity change from the aura\n            self:DoDelta(data.amount * dt)\n            \n            -- Optionally track the source\n            if data.amount < 0 and data.source ~= nil then\n                self.inst:PushEvent("goninsane", {source = data.source})\n            elseif data.amount > 0 and data.source ~= nil then\n                self.inst:PushEvent("gosane", {source = data.source})\n            end\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"best-practices-for-event-based-communication",children:"Best Practices for Event-Based Communication"}),"\n",(0,o.jsx)(e.p,{children:"When using events for component communication, follow these guidelines:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use Descriptive Event Names"}),": Choose clear, specific names that indicate what happened"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Include Relevant Data"}),": Pass all necessary information in the event data table"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Avoid Circular Events"}),": Be careful not to create infinite loops of events triggering each other"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Clean Up Event Listeners"}),": Remove event listeners when components are removed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use Local vs. Global Events"}),": Choose the appropriate scope for your events"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example of proper event listener cleanup\nfunction MyComponent:OnRemoveFromEntity()\n    if self.eventtask ~= nil then\n        self.eventtask:Cancel()\n        self.eventtask = nil\n    end\n    \n    -- Remove all event listeners this component created\n    self.inst:RemoveEventCallback("attacked", self.onattacked)\n    self.inst:RemoveEventCallback("death", self.ondeath)\nend\n\n-- Example of setting up event listeners with proper references\nfunction MyComponent:OnLoad()\n    -- Store references to bound callbacks for later cleanup\n    self.onattacked = function(inst, data) self:OnAttacked(data) end\n    self.ondeath = function(inst) self:OnDeath() end\n    \n    -- Add the event listeners\n    self.inst:ListenForEvent("attacked", self.onattacked)\n    self.inst:ListenForEvent("death", self.ondeath)\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"replication-system",children:"Replication System"}),"\n",(0,o.jsx)(e.p,{children:"For multiplayer synchronization, components use a replication system:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Server Components"}),": Full components with all logic run on the server"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Replica Components"}),": Lightweight versions that exist on clients"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"NetVars"}),": Network variables that synchronize specific values"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"-- Server-side component\nfunction Health:SetCurrentHealth(amount)\n    self.currenthealth = amount\n    self.inst.replica.health:SetCurrentHealth(amount) -- Update replica\nend\n\n-- Client-side replica\nfunction HealthReplica:SetCurrentHealth(amount)\n    self._currenthealth:set(amount) -- NetVar synchronization\nend\n"})}),"\n",(0,o.jsx)(e.h2,{id:"understanding-component-dependencies",children:"Understanding Component Dependencies"}),"\n",(0,o.jsx)(e.p,{children:"When creating mods, it's important to understand component dependencies:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Required Components"}),": Some components require others to function correctly"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Combat often requires Health"}),"\n",(0,o.jsx)(e.li,{children:"Eater often requires Hunger"}),"\n",(0,o.jsx)(e.li,{children:"Equippable often requires Inventoryitem"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Optional Interactions"}),": Some components enhance others but aren't required"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Armor enhances Health but isn't required"}),"\n",(0,o.jsx)(e.li,{children:"Stackable enhances Inventoryitem but isn't required"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Understanding these dependencies helps create more robust mods that integrate well with the existing system."}),"\n",(0,o.jsx)(e.h2,{id:"health-combat-and-inventory-interaction-examples",children:"Health, Combat, and Inventory Interaction Examples"}),"\n",(0,o.jsx)(e.p,{children:"The following examples demonstrate how Health, Combat, and Inventory components interact in common gameplay scenarios."}),"\n",(0,o.jsx)(e.h3,{id:"example-1-equipping-a-weapon-and-attacking",children:"Example 1: Equipping a Weapon and Attacking"}),"\n",(0,o.jsx)(e.p,{children:"This example shows how a player equips a weapon from inventory and uses it to attack a target:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Create a basic weapon\nlocal function CreateWeapon(damage)\n    local weapon = CreateEntity()\n    \n    -- Add required components\n    weapon:AddComponent("inventoryitem")\n    weapon:AddComponent("equippable")\n    weapon:AddComponent("weapon")\n    \n    -- Configure components\n    weapon.components.equippable.equipslot = EQUIPSLOTS.HANDS\n    weapon.components.weapon:SetDamage(damage)\n    \n    return weapon\nend\n\n-- Create a player with inventory and combat\nlocal function CreatePlayer()\n    local player = CreateEntity()\n    \n    -- Add required components\n    player:AddComponent("inventory")\n    player:AddComponent("health")\n    player:AddComponent("combat")\n    \n    -- Configure components\n    player.components.health:SetMaxHealth(150)\n    player.components.combat:SetDefaultDamage(10) -- Base damage without weapon\n    \n    -- Add event listeners\n    player:ListenForEvent("equip", function(inst, data)\n        if data.item.components.weapon ~= nil and data.eslot == EQUIPSLOTS.HANDS then\n            -- Update combat damage when equipping a weapon\n            inst.components.combat.damage = data.item.components.weapon.damage\n            print("Equipped weapon with " .. data.item.components.weapon.damage .. " damage")\n        end\n    end)\n    \n    player:ListenForEvent("unequip", function(inst, data)\n        if data.eslot == EQUIPSLOTS.HANDS then\n            -- Reset to default damage when unequipping a weapon\n            inst.components.combat.damage = inst.components.combat.defaultdamage\n            print("Unequipped weapon, reverting to " .. inst.components.combat.defaultdamage .. " damage")\n        end\n    end)\n    \n    return player\nend\n\n-- Create a target with health\nlocal function CreateTarget()\n    local target = CreateEntity()\n    \n    -- Add required components\n    target:AddComponent("health")\n    \n    -- Configure components\n    target.components.health:SetMaxHealth(100)\n    \n    -- Add event listeners\n    target:ListenForEvent("healthdelta", function(inst, data)\n        print("Target health changed by " .. data.amount .. " (now at " .. \n              inst.components.health:GetPercent() * 100 .. "%)")\n    end)\n    \n    target:ListenForEvent("death", function(inst)\n        print("Target has died!")\n    end)\n    \n    return target\nend\n\n-- Usage example\nlocal function CombatExample()\n    local player = CreatePlayer()\n    local target = CreateTarget()\n    local sword = CreateWeapon(40)\n    \n    -- Give weapon to player and equip it\n    player.components.inventory:GiveItem(sword)\n    player.components.inventory:Equip(sword)\n    \n    -- Player attacks target\n    player.components.combat:SetTarget(target)\n    player.components.combat:DoAttack()\n    \n    -- Unequip weapon and attack again with bare hands\n    player.components.inventory:Unequip(EQUIPSLOTS.HANDS)\n    player.components.combat:DoAttack()\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-using-armor-to-reduce-damage",children:"Example 2: Using Armor to Reduce Damage"}),"\n",(0,o.jsx)(e.p,{children:"This example shows how armor in the inventory protects a player from damage:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Create a basic armor\nlocal function CreateArmor(absorption)\n    local armor = CreateEntity()\n    \n    -- Add required components\n    armor:AddComponent("inventoryitem")\n    armor:AddComponent("equippable")\n    armor:AddComponent("armor")\n    \n    -- Configure components\n    armor.components.equippable.equipslot = EQUIPSLOTS.BODY\n    armor.components.armor:SetAbsorption(absorption) -- 0-1 value, percentage of damage absorbed\n    armor.components.armor:SetMaxCondition(100) -- Durability\n    \n    return armor\nend\n\n-- Create a player with inventory, health, and armor\nlocal function CreateArmoredPlayer()\n    local player = CreateEntity()\n    \n    -- Add required components\n    player:AddComponent("inventory")\n    player:AddComponent("health")\n    \n    -- Configure components\n    player.components.health:SetMaxHealth(150)\n    \n    -- Add event listeners for damage\n    player:ListenForEvent("attacked", function(inst, data)\n        print("Player was attacked for " .. data.damage .. " damage")\n        \n        -- Check for armor\n        local armor = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.BODY)\n        if armor ~= nil and armor.components.armor ~= nil then\n            local absorbed_damage = data.damage * armor.components.armor.absorb_percent\n            local actual_damage = data.damage - absorbed_damage\n            \n            print("Armor absorbed " .. absorbed_damage .. " damage")\n            print("Player took " .. actual_damage .. " actual damage")\n            \n            -- Damage the armor\n            armor.components.armor:TakeDamage(data.damage)\n            print("Armor condition: " .. armor.components.armor.condition)\n            \n            if armor.components.armor.condition <= 0 then\n                print("Armor has broken!")\n            end\n        else\n            print("No armor equipped, took full damage")\n        end\n    end)\n    \n    return player\nend\n\n-- Usage example\nlocal function ArmorExample()\n    local player = CreateArmoredPlayer()\n    local armor = CreateArmor(0.8) -- 80% damage absorption\n    \n    -- Give armor to player and equip it\n    player.components.inventory:GiveItem(armor)\n    player.components.inventory:Equip(armor)\n    \n    -- Simulate player taking damage with armor\n    player.components.health:DoDelta(-50, false, "attack")\n    \n    -- Unequip armor and take damage again\n    player.components.inventory:Unequip(EQUIPSLOTS.BODY)\n    player.components.health:DoDelta(-50, false, "attack")\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-3-healing-items-in-inventory",children:"Example 3: Healing Items in Inventory"}),"\n",(0,o.jsx)(e.p,{children:"This example demonstrates using healing items from inventory to restore health:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Create a healing item\nlocal function CreateHealingItem(health_value)\n    local item = CreateEntity()\n    \n    -- Add required components\n    item:AddComponent("inventoryitem")\n    item:AddComponent("healer")\n    \n    -- Configure healing value\n    item.components.healer:SetHealthAmount(health_value)\n    \n    return item\nend\n\n-- Create a player with inventory and health\nlocal function CreateInjuredPlayer()\n    local player = CreateEntity()\n    \n    -- Add required components\n    player:AddComponent("inventory")\n    player:AddComponent("health")\n    \n    -- Configure health\n    player.components.health:SetMaxHealth(100)\n    player.components.health:SetPercent(0.3) -- Start at 30% health\n    \n    -- Add event listener for health changes\n    player:ListenForEvent("healthdelta", function(inst, data)\n        print("Player health changed by " .. data.amount .. " (now at " .. \n              inst.components.health:GetPercent() * 100 .. "%)")\n    end)\n    \n    return player\nend\n\n-- Function to use a healing item\nlocal function UseHealingItem(player, item)\n    if item.components.healer ~= nil then\n        -- Apply healing effect\n        item.components.healer:Heal(player)\n        \n        -- Remove the item after use\n        item:Remove()\n        return true\n    end\n    return false\nend\n\n-- Usage example\nlocal function HealingExample()\n    local player = CreateInjuredPlayer()\n    local healingItem = CreateHealingItem(50) -- Heals 50 health\n    \n    -- Give healing item to player\n    player.components.inventory:GiveItem(healingItem)\n    \n    -- Use the healing item\n    local item = player.components.inventory:FindItem(function(item) \n        return item.components.healer ~= nil \n    end)\n    \n    if item ~= nil then\n        print("Using healing item...")\n        UseHealingItem(player, item)\n        player.components.inventory:RemoveItem(item)\n    end\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:"These examples demonstrate the core interactions between Health, Combat, and Inventory components, showing how they work together to create the combat and survival mechanics in Don't Starve Together."}),"\n",(0,o.jsx)(e.h2,{id:"common-design-patterns-when-working-with-multiple-components",children:"Common Design Patterns When Working with Multiple Components"}),"\n",(0,o.jsx)(e.p,{children:"When developing mods that involve multiple components, several design patterns can help you create more maintainable and effective code. This section covers the most common patterns used in Don't Starve Together modding."}),"\n",(0,o.jsx)(e.h3,{id:"1-component-composition-pattern",children:"1. Component Composition Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The component composition pattern is the foundation of Don't Starve Together's entity system. Instead of creating complex inheritance hierarchies, entities are composed of reusable components."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Creating an entity with multiple components\nlocal function CreateComplexEntity()\n    local inst = CreateEntity()\n    \n    -- Add basic components\n    inst:AddComponent("health")\n    inst:AddComponent("combat")\n    inst:AddComponent("inventory")\n    inst:AddComponent("hunger")\n    inst:AddComponent("sanity")\n    inst:AddComponent("temperature")\n    \n    -- Configure components\n    inst.components.health:SetMaxHealth(150)\n    inst.components.combat:SetDefaultDamage(10)\n    inst.components.hunger:SetMax(150)\n    \n    return inst\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Entities can be constructed from mix-and-match components"}),"\n",(0,o.jsx)(e.li,{children:"Components can be added or removed dynamically"}),"\n",(0,o.jsx)(e.li,{children:"Behavior can be modified by changing component configuration"}),"\n",(0,o.jsx)(e.li,{children:"Easier to reuse functionality across different entity types"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-component-dependency-injection",children:"2. Component Dependency Injection"}),"\n",(0,o.jsx)(e.p,{children:"This pattern involves passing component references to other components that depend on them, rather than having components directly access each other."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Dependency injection pattern\nlocal MyCustomComponent = Class(function(self, inst)\n    self.inst = inst\n    self.damage_multiplier = 1.0\n    \n    -- Store references to required components\n    self.health = inst.components.health\n    self.combat = inst.components.combat\n    \n    -- Set up the component with dependencies\n    if self.combat ~= nil and self.health ~= nil then\n        self:Initialize()\n    else\n        -- Handle missing dependencies\n        print("Warning: MyCustomComponent requires health and combat components")\n    end\nend)\n\nfunction MyCustomComponent:Initialize()\n    -- Use the injected component references\n    self.base_damage = self.combat:GetDefaultDamage()\n    self.max_health = self.health:GetMaxHealth()\n    \n    -- Set up event listeners\n    self.inst:ListenForEvent("healthdelta", function(inst, data)\n        self:OnHealthChanged(data)\n    end)\nend\n\nfunction MyCustomComponent:OnHealthChanged(data)\n    -- Adjust damage based on health percentage\n    local health_percent = self.health:GetPercent()\n    self.damage_multiplier = 1.0 + (1.0 - health_percent)\n    self.combat:SetDefaultDamage(self.base_damage * self.damage_multiplier)\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Clear dependencies between components"}),"\n",(0,o.jsx)(e.li,{children:"Easier to test components in isolation"}),"\n",(0,o.jsx)(e.li,{children:"More robust when components are added or removed"}),"\n",(0,o.jsx)(e.li,{children:"Prevents tight coupling between components"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-component-observer-pattern",children:"3. Component Observer Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The observer pattern allows components to react to changes in other components without direct coupling, primarily through the event system."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Observer pattern using events\nlocal function SetupComponentObservers(inst)\n    -- Health observes hunger\n    inst:ListenForEvent("hungerdelta", function(inst, data)\n        if inst.components.health ~= nil and data.newpercent <= 0 then\n            -- Start taking starvation damage\n            inst.components.health:StartRegen(-1, 1)\n        elseif inst.components.health ~= nil and data.oldpercent <= 0 and data.newpercent > 0 then\n            -- Stop starvation damage\n            inst.components.health:StopRegen()\n        end\n    end)\n    \n    -- Sanity observes temperature\n    inst:ListenForEvent("temperaturedelta", function(inst, data)\n        if inst.components.sanity ~= nil then\n            if data.new < 0 and data.old >= 0 then\n                -- Start freezing, lose sanity\n                inst.components.sanity:AddSanityPenalty("freezing", -0.1)\n            elseif data.new >= 0 and data.old < 0 then\n                -- Stop freezing, remove penalty\n                inst.components.sanity:RemoveSanityPenalty("freezing")\n            end\n        end\n    end)\n    \n    -- Combat observes sanity\n    inst:ListenForEvent("sanitydelta", function(inst, data)\n        if inst.components.combat ~= nil then\n            if data.newpercent < 0.1 and data.oldpercent >= 0.1 then\n                -- Very low sanity, increase damage\n                inst.components.combat:AddDamageModifier("insanity", 1.5)\n            elseif data.newpercent >= 0.1 and data.oldpercent < 0.1 then\n                -- Sanity recovered, remove damage bonus\n                inst.components.combat:RemoveDamageModifier("insanity")\n            end\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Components remain decoupled but can still react to each other"}),"\n",(0,o.jsx)(e.li,{children:"Multiple components can respond to the same event"}),"\n",(0,o.jsx)(e.li,{children:"Easy to add new observers without modifying existing code"}),"\n",(0,o.jsx)(e.li,{children:"Events provide a standardized communication mechanism"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-component-decorator-pattern",children:"4. Component Decorator Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The decorator pattern extends component functionality without modifying the original component. This is often implemented by wrapping or post-initializing components."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Decorator pattern for components\nlocal function EnhanceHealthComponent(inst)\n    if inst.components.health ~= nil then\n        -- Store original functions\n        local original_DoDelta = inst.components.health.DoDelta\n        local original_SetMaxHealth = inst.components.health.SetMaxHealth\n        \n        -- Override with enhanced functionality\n        inst.components.health.DoDelta = function(self, amount, overtime, cause, ...)\n            -- Add custom behavior before\n            if amount < 0 then\n                -- Chance to avoid damage\n                if math.random() < 0.2 then\n                    print("Damage avoided!")\n                    return 0\n                end\n            end\n            \n            -- Call original function\n            return original_DoDelta(self, amount, overtime, cause, ...)\n        end\n        \n        inst.components.health.SetMaxHealth = function(self, amount)\n            -- Add custom behavior\n            local bonus = math.floor(amount * 0.1)\n            print("Adding health bonus: " .. bonus)\n            \n            -- Call original with bonus\n            return original_SetMaxHealth(self, amount + bonus)\n        end\n        \n        -- Add new functionality\n        inst.components.health.GetHealthRegenRate = function(self)\n            return self.regen_rate or 0\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Extends component functionality without modifying the original code"}),"\n",(0,o.jsx)(e.li,{children:"Can be applied conditionally or to specific entities"}),"\n",(0,o.jsx)(e.li,{children:"Allows for stacking multiple decorators"}),"\n",(0,o.jsx)(e.li,{children:"Useful for mod compatibility and overriding behavior"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"5-component-facade-pattern",children:"5. Component Facade Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The facade pattern creates a simplified interface for a group of components that commonly work together, making it easier to use them as a unified system."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"-- Example: Facade pattern for survival components\nlocal function CreateSurvivalFacade(inst)\n    -- Create a facade that simplifies working with survival components\n    inst.survival = {}\n    \n    -- Add simplified methods that coordinate multiple components\n    inst.survival.GetStatus = function()\n        local status = {}\n        \n        if inst.components.health ~= nil then\n            status.health = inst.components.health:GetPercent()\n        end\n        \n        if inst.components.hunger ~= nil then\n            status.hunger = inst.components.hunger:GetPercent()\n        end\n        \n        if inst.components.sanity ~= nil then\n            status.sanity = inst.components.sanity:GetPercent()\n        end\n        \n        if inst.components.temperature ~= nil then\n            status.temperature = inst.components.temperature:GetCurrent()\n        end\n        \n        return status\n    end\n    \n    -- Method to restore all stats at once\n    inst.survival.RestoreAll = function(amount)\n        if inst.components.health ~= nil then\n            inst.components.health:DoDelta(amount)\n        end\n        \n        if inst.components.hunger ~= nil then\n            inst.components.hunger:DoDelta(amount)\n        end\n        \n        if inst.components.sanity ~= nil then\n            inst.components.sanity:DoDelta(amount)\n        end\n    end\n    \n    -- Method to check if in critical condition\n    inst.survival.IsCritical = function()\n        local critical = false\n        \n        if inst.components.health ~= nil and inst.components.health:GetPercent() < 0.2 then\n            critical = true\n        end\n        \n        if inst.components.hunger ~= nil and inst.components.hunger:GetPercent() < 0.1 then\n            critical = true\n        end\n        \n        if inst.components.sanity ~= nil and inst.components.sanity:GetPercent() < 0.1 then\n            critical = true\n        end\n        \n        return critical\n    end\n    \n    return inst.survival\nend\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Simplifies complex component interactions"}),"\n",(0,o.jsx)(e.li,{children:"Provides a higher-level interface for common operations"}),"\n",(0,o.jsx)(e.li,{children:"Reduces code duplication when working with multiple components"}),"\n",(0,o.jsx)(e.li,{children:"Makes code more readable and maintainable"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"6-component-state-machine-pattern",children:"6. Component State Machine Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The state machine pattern manages complex state transitions across multiple components, often using the stategraph system in combination with components."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: State machine pattern with components\nlocal states = {\n    idle = {\n        onenter = function(inst)\n            -- Configure components for idle state\n            if inst.components.locomotor ~= nil then\n                inst.components.locomotor:Stop()\n            end\n            \n            -- Play idle animation\n            inst.AnimState:PlayAnimation("idle_loop", true)\n        end\n    },\n    \n    attack = {\n        onenter = function(inst)\n            -- Configure components for attack state\n            if inst.components.combat ~= nil then\n                inst.components.combat:StartAttack()\n            end\n            \n            -- Play attack animation\n            inst.AnimState:PlayAnimation("attack")\n        end,\n        \n        onexit = function(inst)\n            -- Clean up attack state\n            if inst.components.combat ~= nil then\n                inst.components.combat:StopAttack()\n            end\n        end,\n        \n        events = {\n            EventHandler("animover", function(inst)\n                -- Transition back to idle when animation finishes\n                inst.sg:GoToState("idle")\n            end)\n        }\n    },\n    \n    hurt = {\n        onenter = function(inst)\n            -- Configure components for hurt state\n            if inst.components.locomotor ~= nil then\n                inst.components.locomotor:Stop()\n            end\n            \n            -- Play hurt animation\n            inst.AnimState:PlayAnimation("hit")\n        end,\n        \n        events = {\n            EventHandler("animover", function(inst)\n                -- Transition back to idle when animation finishes\n                inst.sg:GoToState("idle")\n            end)\n        }\n    }\n}\n\nlocal function SetupStateMachine(inst)\n    -- Create state graph\n    inst:SetStateGraph("SGmyentity")\n    \n    -- Connect component events to state transitions\n    inst:ListenForEvent("attacked", function(inst)\n        if not inst.sg:HasStateTag("busy") then\n            inst.sg:GoToState("hurt")\n        end\n    end)\n    \n    inst:ListenForEvent("doattack", function(inst)\n        if not inst.sg:HasStateTag("busy") then\n            inst.sg:GoToState("attack")\n        end\n    end)\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Manages complex state transitions across multiple components"}),"\n",(0,o.jsx)(e.li,{children:"Centralizes animation and component state management"}),"\n",(0,o.jsx)(e.li,{children:"Prevents conflicts between competing component behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Creates predictable entity behavior"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"7-component-proxy-pattern",children:"7. Component Proxy Pattern"}),"\n",(0,o.jsx)(e.p,{children:"The proxy pattern provides a controlled interface to component functionality, often used to add validation, logging, or conditional access."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Example: Proxy pattern for component access\nlocal function CreateHealthProxy(inst)\n    local health = inst.components.health\n    local health_proxy = {}\n    \n    -- Create proxy methods with additional functionality\n    health_proxy.DoDelta = function(amount, overtime, cause)\n        -- Add validation\n        if amount == nil then\n            print("Warning: Tried to change health with nil amount")\n            return\n        end\n        \n        -- Add logging\n        print("Health changing by " .. amount .. " due to " .. (cause or "unknown"))\n        \n        -- Add conditional logic\n        if amount < 0 and inst:HasTag("invulnerable") then\n            print("Blocked damage due to invulnerability")\n            return 0\n        end\n        \n        -- Call the actual component method\n        return health:DoDelta(amount, overtime, cause)\n    end\n    \n    health_proxy.GetCurrent = function()\n        return health.currenthealth\n    end\n    \n    health_proxy.GetMax = function()\n        return health.maxhealth\n    end\n    \n    health_proxy.GetPercent = function()\n        return health:GetPercent()\n    end\n    \n    health_proxy.IsInvincible = function()\n        return health:IsInvincible()\n    end\n    \n    return health_proxy\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adds validation, logging, or conditional logic to component access"}),"\n",(0,o.jsx)(e.li,{children:"Can restrict or modify component functionality"}),"\n",(0,o.jsx)(e.li,{children:"Useful for debugging and monitoring component usage"}),"\n",(0,o.jsx)(e.li,{children:"Can implement caching or lazy initialization"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"By understanding and applying these design patterns, you can create more robust and maintainable mods that effectively leverage Don't Starve Together's component-based architecture."})]})}function m(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);