"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[1125],{3797:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"api-vanilla/node-types/sequence-nodes","title":"Sequence Nodes","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/node-types/sequence-nodes.md","sourceDirName":"api-vanilla/node-types","slug":"/api-vanilla/node-types/sequence-nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"sequence-nodes","title":"Sequence Nodes","sidebar_position":6,"last_updated":"2023-07-06T00:00:00.000Z","version":619045},"sidebar":"docs","previous":{"title":"Priority Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes"},"next":{"title":"Brain","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/brain"}}');var t=i(4848),l=i(8453);const r={id:"sequence-nodes",title:"Sequence Nodes",sidebar_position:6,last_updated:new Date("2023-07-06T00:00:00.000Z"),version:619045},d="Sequence Nodes",c={},o=[{value:"Sequence Node properties and methods",id:"sequence-node-properties-and-methods",level:2},{value:"Properties",id:"properties",level:2},{value:"inst: Entity <code>[readonly]</code>",id:"inst-entity-readonly",level:3},{value:"children: <code>Array&lt;BehaviorNode&gt;</code> <code>[readonly]</code>",id:"children-arraybehaviornode-readonly",level:3},{value:"current_child: number <code>[readonly]</code>",id:"current_child-number-readonly",level:3},{value:"status: &#39;READY&#39; | &#39;RUNNING&#39; | &#39;SUCCESS&#39; | &#39;FAILURE&#39; <code>[readonly]</code>",id:"status-ready--running--success--failure-readonly",level:3},{value:"Methods",id:"methods",level:2},{value:"Visit(): &#39;READY&#39; | &#39;RUNNING&#39; | &#39;SUCCESS&#39; | &#39;FAILURE&#39;",id:"visit-ready--running--success--failure",level:3},{value:"Stop(): void",id:"stop-void",level:3},{value:"Reset(): void",id:"reset-void",level:3},{value:"States",id:"states",level:2},{value:"&#39;READY&#39; | &#39;RUNNING&#39; | &#39;SUCCESS&#39; | &#39;FAILURE&#39;",id:"ready--running--success--failure",level:3},{value:"Built-in Sequence Nodes",id:"built-in-sequence-nodes",level:2},{value:"SequenceNode(inst: Entity, children: <code>Array&lt;BehaviorNode&gt;</code>): SequenceNode",id:"sequencenodeinst-entity-children-arraybehaviornode-sequencenode",level:3},{value:"DoWhileNode(inst: Entity, condition_fn: Function, children: <code>Array&lt;BehaviorNode&gt;</code>): SequenceNode",id:"dowhilenodeinst-entity-condition_fn-function-children-arraybehaviornode-sequencenode",level:3},{value:"ParallelNodeAny(inst: Entity, children: <code>Array&lt;BehaviorNode&gt;</code>): SequenceNode",id:"parallelnodeanyinst-entity-children-arraybehaviornode-sequencenode",level:3},{value:"ParallelNodeAll(inst: Entity, children: <code>Array&lt;BehaviorNode&gt;</code>): SequenceNode",id:"parallelnodeallinst-entity-children-arraybehaviornode-sequencenode",level:3},{value:"Common Sequence Patterns",id:"common-sequence-patterns",level:2},{value:"Multi-step Actions",id:"multi-step-actions",level:3},{value:"Validation Chains",id:"validation-chains",level:3},{value:"Creating Custom Sequence Nodes",id:"creating-custom-sequence-nodes",level:2},{value:"1. Derive from BehaviorNode",id:"1-derive-from-behaviornode",level:3},{value:"2. Implement Visit function",id:"2-implement-visit-function",level:3},{value:"3. Implement Stop function",id:"3-implement-stop-function",level:3},{value:"Example: Interruptible Sequence",id:"example-interruptible-sequence",level:2},{value:"Example: Retry Sequence",id:"example-retry-sequence",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"sequence-nodes",children:"Sequence Nodes"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"API Version: 619045"})}),"\n",(0,t.jsx)(n.p,{children:"Sequence Nodes are essential components in Don't Starve Together's behavior tree system that execute child nodes in order until one fails or all succeed. They act as a logical \"AND\" operation, executing each child node sequentially and only succeeding if all children succeed."}),"\n",(0,t.jsx)(n.h2,{id:"sequence-node-properties-and-methods",children:"Sequence Node properties and methods"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Nodes provide the following key properties and methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Properties"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," - Reference to the entity this node controls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"children"})," - Array of child nodes to execute in sequence"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"current_child"})," - Index of the currently executing child node"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"status"})," - Current execution status of the node"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Methods"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Visit()"})," - Evaluates the sequence node and its children"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Stop()"})," - Stops execution of this node and all children"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Reset()"})," - Resets this node and all children to READY state"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,t.jsxs)(n.h3,{id:"inst-entity-readonly",children:["inst: Entity ",(0,t.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,t.jsx)(n.p,{children:"A reference to the entity that this sequence node is controlling."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"-- Access the sequence node's entity\nlocal health = sequence_node.inst.components.health\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"children-arraybehaviornode-readonly",children:["children: ",(0,t.jsx)(n.code,{children:"Array<BehaviorNode>"})," ",(0,t.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,t.jsx)(n.p,{children:"List of child nodes to execute in sequence. Children are executed in the order they appear in this array."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"-- Create sequence node with ordered steps\nlocal sequence_node = SequenceNode(inst, {\n    FindFood(inst),         -- First find food\n    GoToFood(inst),         -- Then go to it\n    EatFood(inst)           -- Finally eat it\n})\n\n-- Access a specific child\nlocal first_child = sequence_node.children[1]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"current_child-number-readonly",children:["current_child: number ",(0,t.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,t.jsx)(n.p,{children:"Index of the currently executing child node in the children array. This value starts at 1 and increments as each child succeeds."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check which step we\'re on\nprint("Currently executing step " .. sequence_node.current_child .. " of " .. #sequence_node.children)\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"status-ready--running--success--failure-readonly",children:["status: 'READY' | 'RUNNING' | 'SUCCESS' | 'FAILURE' ",(0,t.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,t.jsx)(n.p,{children:"The current execution status of the sequence node:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"READY"}),": Node is ready to begin executing children"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RUNNING"}),": Node is currently executing one of its children"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SUCCESS"}),": All child nodes have executed successfully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FAILURE"}),": One of the child nodes has failed"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check the current status\nif sequence_node.status == SUCCESS then\n    print("All sequence steps completed successfully")\nelseif sequence_node.status == FAILURE then\n    print("Sequence failed at step " .. sequence_node.current_child)\nend\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"visit-ready--running--success--failure",children:"Visit(): 'READY' | 'RUNNING' | 'SUCCESS' | 'FAILURE'"}),"\n",(0,t.jsx)(n.p,{children:"Evaluates the sequence node by executing children in order until one fails or all succeed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function MySequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n\n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- As soon as one child fails, the whole sequence fails\n            self.status = FAILURE\n        end\n    end\n    \n    return self.status\nend\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"stop-void",children:"Stop(): void"}),"\n",(0,t.jsx)(n.p,{children:"Stops execution of this sequence node and all its children."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function MySequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\n    self.current_child = 1\nend\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"reset-void",children:"Reset(): void"}),"\n",(0,t.jsx)(n.p,{children:"Resets the sequence node and all its children to READY state."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function MySequence:Reset()\n    for i = 1, #self.children do\n        self.children[i]:Reset()\n    end\n    self.status = READY\n    self.current_child = 1\nend\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"states",children:"States"}),"\n",(0,t.jsx)(n.p,{children:"SequenceNode can be in one of four states:"}),"\n",(0,t.jsx)(n.h3,{id:"ready--running--success--failure",children:"'READY' | 'RUNNING' | 'SUCCESS' | 'FAILURE'"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"READY"}),": Node is ready to begin execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RUNNING"}),": Node is currently executing a child node"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SUCCESS"}),": All child nodes have executed successfully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FAILURE"}),": A child node has failed, stopping execution"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check current sequence status\nif sequence_node.status == SUCCESS then\n    print("Entire sequence completed successfully")\nelseif sequence_node.status == FAILURE then\n    print("Sequence failed during execution")\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"built-in-sequence-nodes",children:"Built-in Sequence Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Don't Starve Together includes several pre-defined sequence nodes:"}),"\n",(0,t.jsxs)(n.h3,{id:"sequencenodeinst-entity-children-arraybehaviornode-sequencenode",children:["SequenceNode(inst: Entity, children: ",(0,t.jsx)(n.code,{children:"Array<BehaviorNode>"}),"): SequenceNode"]}),"\n",(0,t.jsx)(n.p,{children:"The basic sequence node that executes children in order until one fails or all succeed."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"inst"}),": Entity the node controls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"children"}),": Array of child nodes to execute in sequence"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Find, go to, and eat food\nlocal node = SequenceNode(inst, {\n    FindFood(inst, {"fruit", "veggie"}, 20),\n    GoToEntity(inst, function() return inst.components.eater.foodtarget end, 1),\n    DoAction(inst, function(inst) \n        return inst.components.eater:Eat(inst.components.eater.foodtarget)\n    end)\n})\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"dowhilenodeinst-entity-condition_fn-function-children-arraybehaviornode-sequencenode",children:["DoWhileNode(inst: Entity, condition_fn: Function, children: ",(0,t.jsx)(n.code,{children:"Array<BehaviorNode>"}),"): SequenceNode"]}),"\n",(0,t.jsx)(n.p,{children:"Executes a sequence of nodes while a condition remains true."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"inst"}),": Entity the node controls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"condition_fn"}),": Function that returns true or false"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"children"}),": Array of child nodes to execute in sequence"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Keep gathering resources while inventory has space\nlocal node = DoWhileNode(inst, \n    function() \n        -- Continue while inventory has space\n        return not inst.components.inventory:IsFull() \n    end, \n    {\n        FindItem(inst, function(item) return item.prefab == "log" end, 10),\n        DoAction(inst, function(inst) \n            if inst.finditem then\n                return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n            end\n        end)\n    }\n)\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"parallelnodeanyinst-entity-children-arraybehaviornode-sequencenode",children:["ParallelNodeAny(inst: Entity, children: ",(0,t.jsx)(n.code,{children:"Array<BehaviorNode>"}),"): SequenceNode"]}),"\n",(0,t.jsx)(n.p,{children:"Executes multiple nodes in parallel and succeeds if any child succeeds."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"inst"}),": Entity the node controls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"children"}),": Array of child nodes to execute in parallel"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Try multiple ways to get food in parallel\nlocal node = ParallelNodeAny(inst, {\n    -- Try to find dropped food\n    SequenceNode(inst, {\n        FindItem(inst, function(item) \n            return item.components.edible ~= nil \n        end, 15),\n        DoAction(inst, function(inst) \n            if inst.finditem then\n                return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n            end\n        end)\n    }),\n    -- Or try to harvest berry bushes\n    SequenceNode(inst, {\n        FindEntity(inst, 15, function(ent)\n            return ent.prefab == "berrybush" and \n                   ent.components.pickable and \n                   ent.components.pickable:CanBePicked()\n        end),\n        DoAction(inst, function(inst) \n            if inst.findentity then\n                return BufferedAction(inst, inst.findentity, ACTIONS.PICK)\n            end\n        end)\n    })\n})\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"parallelnodeallinst-entity-children-arraybehaviornode-sequencenode",children:["ParallelNodeAll(inst: Entity, children: ",(0,t.jsx)(n.code,{children:"Array<BehaviorNode>"}),"): SequenceNode"]}),"\n",(0,t.jsx)(n.p,{children:"Executes multiple nodes in parallel and only succeeds if all children succeed."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"inst"}),": Entity the node controls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"children"}),": Array of child nodes to execute in parallel"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"-- Track multiple conditions simultaneously\nlocal node = ParallelNodeAll(inst, {\n    -- Monitor health\n    DoAction(inst, function() \n        return inst.components.health:GetPercent() > 0.25 \n    end),\n    -- Monitor sanity\n    DoAction(inst, function() \n        return inst.components.sanity:GetPercent() > 0.25\n    end),\n    -- Monitor hunger\n    DoAction(inst, function() \n        return inst.components.hunger:GetPercent() > 0.15\n    end)\n})\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-sequence-patterns",children:"Common Sequence Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Sequence nodes are often used for these common patterns:"}),"\n",(0,t.jsx)(n.h3,{id:"multi-step-actions",children:"Multi-step Actions"}),"\n",(0,t.jsx)(n.p,{children:"Breaking a complex task into sequential steps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Break a task into sequential steps\nSequenceNode(inst, {\n    -- First find a tree\n    FindEntity(inst, 20, function(ent) \n        return ent.prefab == "evergreen" and \n               ent.components.workable and \n               ent.components.workable:CanBeWorked() \n    end),\n    \n    -- Go to the tree\n    GoToEntity(inst, function() return inst.findentity end, 1),\n    \n    -- Chop the tree\n    DoAction(inst, function(inst) \n        if inst.findentity then\n            return BufferedAction(inst, inst.findentity, ACTIONS.CHOP)\n        end\n    end),\n    \n    -- Wait for the tree to fall\n    WaitNode(inst, 1),\n    \n    -- Pick up the logs\n    FindItem(inst, function(item) return item.prefab == "log" end, 10),\n    DoAction(inst, function(inst) \n        if inst.finditem then\n            return BufferedAction(inst, inst.finditem, ACTIONS.PICKUP)\n        end\n    end)\n})\n'})}),"\n",(0,t.jsx)(n.h3,{id:"validation-chains",children:"Validation Chains"}),"\n",(0,t.jsx)(n.p,{children:"Checking multiple conditions before taking action:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Check multiple conditions before taking action\nSequenceNode(inst, {\n    -- Check if it\'s safe (no monsters nearby)\n    DoAction(inst, function()\n        local x, y, z = inst.Transform:GetWorldPosition()\n        local ents = TheSim:FindEntities(x, y, z, 10, {"monster"})\n        return #ents == 0\n    end),\n    \n    -- Check if we have the right tool\n    DoAction(inst, function()\n        return inst.components.inventory:Has("axe", 1)\n    end),\n    \n    -- Check if our health is high enough\n    DoAction(inst, function()\n        return inst.components.health:GetPercent() > 0.5\n    end),\n    \n    -- If all checks pass, perform the main action\n    DoAction(inst, function() \n        -- Do the actual task\n        return true\n    end)\n})\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-sequence-nodes",children:"Creating Custom Sequence Nodes"}),"\n",(0,t.jsx)(n.p,{children:"To create a custom sequence node:"}),"\n",(0,t.jsx)(n.h3,{id:"1-derive-from-behaviornode",children:"1. Derive from BehaviorNode"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local CustomSequence = Class(BehaviorNode, function(self, inst, children, ...)\n    BehaviorNode._ctor(self, "CustomSequence")\n    self.inst = inst\n    self.children = children\n    self.current_child = 1\n    -- Store other parameters\nend)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-implement-visit-function",children:"2. Implement Visit function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CustomSequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        -- Implement custom sequence logic here\n        -- Decide how to handle SUCCESS and FAILURE of children\n        -- Update self.current_child as needed\n    end\n    \n    return self.status\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-implement-stop-function",children:"3. Implement Stop function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"function CustomSequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\n    self.current_child = 1\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"example-interruptible-sequence",children:"Example: Interruptible Sequence"}),"\n",(0,t.jsx)(n.p,{children:"A sequence node that can be interrupted by a condition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local InterruptibleSequence = Class(BehaviorNode, function(self, inst, children, interrupt_fn)\n    BehaviorNode._ctor(self, "InterruptibleSequence")\n    self.inst = inst\n    self.children = children\n    self.interrupt_fn = interrupt_fn\n    self.current_child = 1\nend)\n\nfunction InterruptibleSequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        -- Check interrupt condition first\n        if self.interrupt_fn and self.interrupt_fn(self.inst) then\n            -- Interrupt the sequence\n            self.status = FAILURE\n            return self.status\n        end\n        \n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- As soon as one child fails, the whole sequence fails\n            self.status = FAILURE\n        end\n    end\n    \n    return self.status\nend\n\nfunction InterruptibleSequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\nend\n\n-- Usage\nlocal behavior = InterruptibleSequence(inst,\n    {\n        FindFood(inst),\n        GoToFood(inst),\n        EatFood(inst)\n    },\n    function(inst)\n        -- Interrupt if health gets too low or a monster appears\n        return inst.components.health:GetPercent() < 0.2 or\n               FindEntity(inst, 10, {"monster"}) ~= nil\n    end\n)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"example-retry-sequence",children:"Example: Retry Sequence"}),"\n",(0,t.jsx)(n.p,{children:"A sequence node that retries failed children a certain number of times:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local RetrySequence = Class(BehaviorNode, function(self, inst, children, max_retries)\n    BehaviorNode._ctor(self, "RetrySequence")\n    self.inst = inst\n    self.children = children\n    self.max_retries = max_retries or 3\n    self.current_child = 1\n    self.retry_count = 0\nend)\n\nfunction RetrySequence:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.current_child = 1\n        self.retry_count = 0\n        self.children[self.current_child]:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.children[self.current_child]:Visit()\n        \n        if status == SUCCESS then\n            -- This child succeeded, move to next one\n            self.current_child = self.current_child + 1\n            self.retry_count = 0\n            \n            if self.current_child <= #self.children then\n                -- Start the next child\n                self.children[self.current_child]:Start()\n            else\n                -- All children succeeded\n                self.status = SUCCESS\n            end\n        elseif status == FAILURE then\n            -- Child failed, try to retry\n            self.retry_count = self.retry_count + 1\n            \n            if self.retry_count <= self.max_retries then\n                -- Retry the current child\n                self.children[self.current_child]:Stop()\n                self.children[self.current_child]:Start()\n            else\n                -- Max retries exceeded, the sequence fails\n                self.status = FAILURE\n            end\n        end\n    end\n    \n    return self.status\nend\n\nfunction RetrySequence:Stop()\n    for i = 1, #self.children do\n        self.children[i]:Stop()\n    end\n    self.status = READY\n    self.retry_count = 0\nend\n\n-- Usage\nlocal behavior = RetrySequence(inst,\n    {\n        FindFood(inst),\n        GoToFood(inst),\n        EatFood(inst)\n    },\n    2 -- Try each step up to 2 additional times if it fails\n)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Child Order"}),": Arrange children so that the ones most likely to fail come first, to minimize wasted processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Count"}),": Keep the number of children in a sequence manageable; consider breaking complex sequences into sub-sequences"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Management"}),": Be careful with managing state across sequence steps to prevent side effects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Consider using custom sequence nodes with retry capabilities for critical operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime Costs"}),": Be aware that deeply nested sequences can have significant runtime costs"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/brain",children:"Brain"})," - For brain implementation using behavior trees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/action-nodes",children:"Action Nodes"})," - For nodes that perform actions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes",children:"Priority Nodes"})," - For selecting between different actions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes",children:"Condition Nodes"})," - For conditional execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes",children:"Decorator Nodes"})," - For modifying the behavior of other nodes"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>d});var s=i(6540);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);