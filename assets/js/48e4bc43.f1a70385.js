"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[3258],{4933:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"api-vanilla/examples/snippets/networking-snippets","title":"Networking Snippets","description":"This page provides reusable code snippets for implementing networking functionality in Don\'t Starve Together mods.","source":"@site/docs/api-vanilla/examples/snippets/networking-snippets.md","sourceDirName":"api-vanilla/examples/snippets","slug":"/api-vanilla/examples/snippets/networking-snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/networking-snippets","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"networking-snippets","title":"Networking Snippets","sidebar_position":5,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"UI Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/ui-snippets"},"next":{"title":"Component Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/component-snippets"}}');var a=t(4848),s=t(8453);const o={id:"networking-snippets",title:"Networking Snippets",sidebar_position:5,last_updated:new Date("2023-07-06T00:00:00.000Z")},l="Networking Snippets",d={},r=[{value:"Basic Networking",id:"basic-networking",level:2},{value:"Client-Server Communication",id:"client-server-communication",level:3},{value:"Networked Variables",id:"networked-variables",level:3},{value:"Advanced Networking",id:"advanced-networking",level:2},{value:"Server to Client Communication",id:"server-to-client-communication",level:3},{value:"Syncing Player State",id:"syncing-player-state",level:3},{value:"Syncing World State",id:"syncing-world-state",level:3},{value:"Networking Best Practices",id:"networking-best-practices",level:2},{value:"Optimizing Network Traffic",id:"optimizing-network-traffic",level:3},{value:"Common Networking Patterns",id:"common-networking-patterns",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"networking-snippets",children:"Networking Snippets"})}),"\n",(0,a.jsx)(e.p,{children:"This page provides reusable code snippets for implementing networking functionality in Don't Starve Together mods."}),"\n",(0,a.jsx)(e.h2,{id:"basic-networking",children:"Basic Networking"}),"\n",(0,a.jsx)(e.h3,{id:"client-server-communication",children:"Client-Server Communication"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define RPC names in a modmain\nlocal RPC_NAMESPACE = "MyModRPC"\n\n-- Register RPCs\nAddModRPCHandler(modname, "ExampleRPC", function(player, value1, value2)\n    -- This function runs on the server when the RPC is received\n    print("Received RPC from " .. player.name .. " with values: " .. tostring(value1) .. ", " .. tostring(value2))\n    \n    -- Do something with the values\n    if player.components.health then\n        player.components.health:DoDelta(value1)\n    end\nend)\n\n-- Send RPC from client to server\nlocal function SendExampleRPC(value1, value2)\n    SendModRPCToServer(MOD_RPC[modname]["ExampleRPC"], value1, value2)\nend\n\n-- Example usage:\n-- SendExampleRPC(10, "hello")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"networked-variables",children:"Networked Variables"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- In a prefab file, define networked variables\nlocal function fn()\n    local inst = CreateEntity()\n    \n    -- Add standard components\n    inst.entity:AddTransform()\n    inst.entity:AddAnimState()\n    inst.entity:AddNetwork()\n    \n    -- Add networked variables\n    inst.network_data = {\n        value = net_float(inst.GUID, "mymod.value", "valuedirty"),\n        state = net_string(inst.GUID, "mymod.state", "statedirty"),\n        counter = net_byte(inst.GUID, "mymod.counter", "counterdirty")\n    }\n    \n    -- Set initial values\n    inst.network_data.value:set(0)\n    inst.network_data.state:set("idle")\n    inst.network_data.counter:set(0)\n    \n    -- Mark entity as networked\n    inst:AddTag("networked_entity")\n    \n    -- Server-only components and logic\n    if not TheWorld.ismastersim then\n        -- Client-side event handlers for network variable changes\n        inst:ListenForEvent("valuedirty", function()\n            local value = inst.network_data.value:value()\n            -- Do something with the updated value on the client\n            print("Value updated to: " .. tostring(value))\n        end)\n        \n        inst:ListenForEvent("statedirty", function()\n            local state = inst.network_data.state:value()\n            -- Do something with the updated state on the client\n            print("State updated to: " .. state)\n            \n            -- Update animation based on state\n            if state == "active" then\n                inst.AnimState:PlayAnimation("active")\n            else\n                inst.AnimState:PlayAnimation("idle")\n            end\n        end)\n        \n        inst:ListenForEvent("counterdirty", function()\n            local counter = inst.network_data.counter:value()\n            -- Do something with the updated counter on the client\n            print("Counter updated to: " .. tostring(counter))\n        end)\n        \n        return inst\n    end\n    \n    -- Server-only components\n    inst:AddComponent("inspectable")\n    \n    -- Functions to modify networked values (server-side)\n    inst.SetValue = function(inst, value)\n        inst.network_data.value:set(value)\n    end\n    \n    inst.SetState = function(inst, state)\n        inst.network_data.state:set(state)\n    end\n    \n    inst.IncrementCounter = function(inst)\n        local current = inst.network_data.counter:value()\n        inst.network_data.counter:set(math.min(current + 1, 255)) -- Max byte value\n    end\n    \n    return inst\nend\n\n-- Usage:\n-- local entity = SpawnPrefab("my_networked_entity")\n-- entity.SetValue(entity, 42)\n-- entity.SetState(entity, "active")\n-- entity.IncrementCounter(entity)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-networking",children:"Advanced Networking"}),"\n",(0,a.jsx)(e.h3,{id:"server-to-client-communication",children:"Server to Client Communication"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define RPC for server to client communication\nAddModRPCHandler(modname, "ServerToClientRPC", function(player, entity_id, action, data)\n    -- This function runs on the client when the RPC is received from the server\n    local entity = Ents[entity_id]\n    if entity then\n        if action == "effect" then\n            -- Spawn a client-side effect\n            SpawnPrefab("lightning").Transform:SetPosition(entity:GetPosition():Get())\n        elseif action == "message" then\n            -- Display a message\n            if data and player == ThePlayer then\n                local notification = SpawnPrefab("notification")\n                notification.text:SetString(data)\n                notification.Transform:SetPosition(player.Transform:GetWorldPosition())\n            end\n        end\n    end\nend)\n\n-- Send RPC from server to client\nlocal function SendServerToClientRPC(player, entity, action, data)\n    if player.userid then\n        SendModRPCToClient(MOD_RPC[modname]["ServerToClientRPC"], player.userid, entity.GUID, action, data)\n    end\nend\n\n-- Example usage (server-side):\n-- SendServerToClientRPC(player, entity, "effect", nil)\n-- SendServerToClientRPC(player, player, "message", "You found a treasure!")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"syncing-player-state",children:"Syncing Player State"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component for syncing player state\nlocal PlayerSync = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Networked variables\n    self.level = net_byte(inst.GUID, "playersync.level", "leveldirty")\n    self.experience = net_ushortint(inst.GUID, "playersync.experience", "experiencedirty")\n    self.skill_points = net_byte(inst.GUID, "playersync.skillpoints", "skillpointsdirty")\n    self.abilities = net_string(inst.GUID, "playersync.abilities", "abilitiesdirty")\n    \n    -- Initialize values\n    self.level:set(1)\n    self.experience:set(0)\n    self.skill_points:set(0)\n    self.abilities:set("[]") -- JSON encoded array\n    \n    -- Listen for changes on client\n    if not TheWorld.ismastersim then\n        inst:ListenForEvent("leveldirty", function() self:OnLevelChanged() end)\n        inst:ListenForEvent("experiencedirty", function() self:OnExperienceChanged() end)\n        inst:ListenForEvent("skillpointsdirty", function() self:OnSkillPointsChanged() end)\n        inst:ListenForEvent("abilitiesdirty", function() self:OnAbilitiesChanged() end)\n    end\nend)\n\n-- Server-side methods\nfunction PlayerSync:SetLevel(level)\n    if TheWorld.ismastersim then\n        self.level:set(level)\n        self.inst:PushEvent("levelup", {level = level})\n    end\nend\n\nfunction PlayerSync:AddExperience(amount)\n    if TheWorld.ismastersim then\n        local current = self.experience:value()\n        local new_exp = math.min(current + amount, 65535) -- Max ushortint value\n        self.experience:set(new_exp)\n        \n        -- Check for level up\n        local level = self.level:value()\n        local exp_for_next_level = level * 1000 -- Example formula\n        \n        if new_exp >= exp_for_next_level and level < 255 then\n            self:SetLevel(level + 1)\n            self:AddSkillPoints(1)\n        end\n    end\nend\n\nfunction PlayerSync:AddSkillPoints(amount)\n    if TheWorld.ismastersim then\n        local current = self.skill_points:value()\n        self.skill_points:set(math.min(current + amount, 255))\n    end\nend\n\nfunction PlayerSync:UnlockAbility(ability_id)\n    if TheWorld.ismastersim then\n        local abilities = self:GetAbilities()\n        \n        -- Check if ability is already unlocked\n        for _, id in ipairs(abilities) do\n            if id == ability_id then\n                return false\n            end\n        end\n        \n        -- Add new ability\n        table.insert(abilities, ability_id)\n        self.abilities:set(json.encode(abilities))\n        return true\n    end\n    return false\nend\n\nfunction PlayerSync:GetAbilities()\n    local abilities_json = self.abilities:value()\n    local success, abilities = pcall(function() return json.decode(abilities_json) end)\n    return success and abilities or {}\nend\n\n-- Client-side event handlers\nfunction PlayerSync:OnLevelChanged()\n    if not TheWorld.ismastersim then\n        local level = self.level:value()\n        -- Update client-side UI or effects\n        self.inst:PushEvent("levelup_client", {level = level})\n    end\nend\n\nfunction PlayerSync:OnExperienceChanged()\n    if not TheWorld.ismastersim then\n        local experience = self.experience:value()\n        -- Update client-side UI\n        self.inst:PushEvent("experience_client", {experience = experience})\n    end\nend\n\nfunction PlayerSync:OnSkillPointsChanged()\n    if not TheWorld.ismastersim then\n        local points = self.skill_points:value()\n        -- Update client-side UI\n        self.inst:PushEvent("skillpoints_client", {points = points})\n    end\nend\n\nfunction PlayerSync:OnAbilitiesChanged()\n    if not TheWorld.ismastersim then\n        local abilities = self:GetAbilities()\n        -- Update client-side UI\n        self.inst:PushEvent("abilities_client", {abilities = abilities})\n    end\nend\n\n-- Usage:\n-- Add this component to player in player_common_extensions:\n-- inst:AddComponent("playersync")\n--\n-- Server-side:\n-- player.components.playersync:AddExperience(100)\n-- player.components.playersync:UnlockAbility("fireball")\n--\n-- Client-side (listen for events):\n-- player:ListenForEvent("levelup_client", function(inst, data) \n--     print("Level up to " .. data.level) \n-- end)\n'})}),"\n",(0,a.jsx)(e.h3,{id:"syncing-world-state",children:"Syncing World State"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component for syncing world state\nlocal WorldSync = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Networked variables\n    self.day_cycle = net_string(inst.GUID, "worldsync.daycycle", "daycycledirty")\n    self.weather_state = net_string(inst.GUID, "worldsync.weather", "weatherdirty")\n    self.event_active = net_bool(inst.GUID, "worldsync.event", "eventdirty")\n    self.event_data = net_string(inst.GUID, "worldsync.eventdata", "eventdatadirty")\n    \n    -- Initialize values\n    self.day_cycle:set("day")\n    self.weather_state:set("clear")\n    self.event_active:set(false)\n    self.event_data:set("{}")\n    \n    -- Listen for changes on client\n    if not TheWorld.ismastersim then\n        inst:ListenForEvent("daycycledirty", function() self:OnDayCycleChanged() end)\n        inst:ListenForEvent("weatherdirty", function() self:OnWeatherChanged() end)\n        inst:ListenForEvent("eventdirty", function() self:OnEventActiveChanged() end)\n        inst:ListenForEvent("eventdatadirty", function() self:OnEventDataChanged() end)\n    end\nend)\n\n-- Server-side methods\nfunction WorldSync:SetDayCycle(cycle)\n    if TheWorld.ismastersim then\n        self.day_cycle:set(cycle)\n    end\nend\n\nfunction WorldSync:SetWeather(weather)\n    if TheWorld.ismastersim then\n        self.weather_state:set(weather)\n    end\nend\n\nfunction WorldSync:StartEvent(event_type, data)\n    if TheWorld.ismastersim then\n        self.event_active:set(true)\n        \n        local event_data = {\n            type = event_type,\n            start_time = GetTime(),\n            duration = data.duration or 60,\n            intensity = data.intensity or 1,\n            position = data.position and {x = data.position.x, y = data.position.y, z = data.position.z} or nil\n        }\n        \n        self.event_data:set(json.encode(event_data))\n    end\nend\n\nfunction WorldSync:StopEvent()\n    if TheWorld.ismastersim then\n        self.event_active:set(false)\n        self.event_data:set("{}")\n    end\nend\n\n-- Client-side event handlers\nfunction WorldSync:OnDayCycleChanged()\n    if not TheWorld.ismastersim then\n        local cycle = self.day_cycle:value()\n        -- Update client-side effects\n        self.inst:PushEvent("daycycle_client", {cycle = cycle})\n    end\nend\n\nfunction WorldSync:OnWeatherChanged()\n    if not TheWorld.ismastersim then\n        local weather = self.weather_state:value()\n        -- Update client-side effects\n        self.inst:PushEvent("weather_client", {weather = weather})\n    end\nend\n\nfunction WorldSync:OnEventActiveChanged()\n    if not TheWorld.ismastersim then\n        local active = self.event_active:value()\n        -- Update client-side effects\n        self.inst:PushEvent("event_active_client", {active = active})\n    end\nend\n\nfunction WorldSync:OnEventDataChanged()\n    if not TheWorld.ismastersim then\n        local data_json = self.event_data:value()\n        local success, data = pcall(function() return json.decode(data_json) end)\n        \n        if success and data then\n            -- Update client-side effects\n            self.inst:PushEvent("event_data_client", {data = data})\n        end\n    end\nend\n\nfunction WorldSync:GetEventData()\n    local data_json = self.event_data:value()\n    local success, data = pcall(function() return json.decode(data_json) end)\n    return success and data or {}\nend\n\n-- Usage:\n-- Add this component to TheWorld in modmain:\n-- AddPrefabPostInit("world", function(inst)\n--     inst:AddComponent("worldsync")\n-- end)\n--\n-- Server-side:\n-- TheWorld.components.worldsync:SetWeather("rain")\n-- TheWorld.components.worldsync:StartEvent("meteor_shower", {duration = 120, intensity = 2})\n--\n-- Client-side (listen for events):\n-- TheWorld:ListenForEvent("weather_client", function(inst, data) \n--     print("Weather changed to " .. data.weather) \n-- end)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"networking-best-practices",children:"Networking Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"optimizing-network-traffic",children:"Optimizing Network Traffic"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Tips for optimizing network traffic\n\n-- 1. Use appropriate network variable types\n-- Choose the smallest data type that can hold your data:\nlocal small_number = net_byte(inst.GUID, "mymod.smallnumber") -- 0-255\nlocal medium_number = net_ushortint(inst.GUID, "mymod.mediumnumber") -- 0-65535\nlocal large_number = net_uint(inst.GUID, "mymod.largenumber") -- 0-4294967295\nlocal decimal = net_float(inst.GUID, "mymod.decimal") -- Floating point number\n\n-- 2. Batch updates when possible\n-- Bad: Sending many small updates\nfunction BadUpdate(inst)\n    inst.net_var1:set(1)\n    inst.net_var2:set(2)\n    inst.net_var3:set(3)\n    inst.net_var4:set(4)\nend\n\n-- Good: Batch updates into a single network message\nfunction GoodUpdate(inst)\n    local data = {\n        var1 = 1,\n        var2 = 2,\n        var3 = 3,\n        var4 = 4\n    }\n    inst.net_data:set(json.encode(data))\nend\n\n-- 3. Throttle updates for fast-changing values\nfunction ThrottledUpdate(inst)\n    if inst.last_sync_time == nil or GetTime() - inst.last_sync_time > 0.5 then\n        inst.net_position:set(inst.Transform:GetWorldPosition())\n        inst.last_sync_time = GetTime()\n    end\nend\n\n-- 4. Use dirty flags to trigger updates only when needed\nfunction UpdateOnlyWhenNeeded(inst, value)\n    if inst.current_value ~= value then\n        inst.current_value = value\n        inst.net_value:set(value)\n    end\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"common-networking-patterns",children:"Common Networking Patterns"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Pattern 1: Syncing inventory items between server and client\nlocal function SyncInventoryItem(item, container, slot)\n    -- This would be part of a custom inventory component\n    if not item or not container then return end\n    \n    -- Create a data structure with just the essential information\n    local item_data = {\n        prefab = item.prefab,\n        slot = slot,\n        stack_size = item.components.stackable and item.components.stackable:StackSize() or 1,\n        percent = item.components.finiteuses and item.components.finiteuses:GetPercent() or \n                 item.components.perishable and item.components.perishable:GetPercent() or 1,\n        is_equipped = item.components.equippable and item.components.equippable.isequipped or false\n    }\n    \n    -- Encode and send via network variable\n    container.net_inventory_slot_data:set(json.encode(item_data))\n    container.net_inventory_update_slot:set(slot)\nend\n\n-- Pattern 2: Implementing a cooldown system with network sync\nlocal CooldownManager = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Server-side cooldown tracking\n    self.cooldowns = {}\n    \n    -- Network variables for client display\n    self.net_cooldown_id = net_string(inst.GUID, "cooldown.id", "cooldowndirty")\n    self.net_cooldown_time = net_float(inst.GUID, "cooldown.time", "cooldowndirty")\n    self.net_cooldown_duration = net_float(inst.GUID, "cooldown.duration", "cooldowndirty")\n    \n    -- Client-side event handler\n    if not TheWorld.ismastersim then\n        inst:ListenForEvent("cooldowndirty", function() self:OnCooldownDirty() end)\n    end\nend)\n\n-- Server-side methods\nfunction CooldownManager:StartCooldown(id, duration)\n    if not TheWorld.ismastersim then return end\n    \n    self.cooldowns[id] = {\n        start_time = GetTime(),\n        duration = duration\n    }\n    \n    -- Sync to client\n    self.net_cooldown_id:set(id)\n    self.net_cooldown_time:set(GetTime())\n    self.net_cooldown_duration:set(duration)\n    \n    -- Schedule end of cooldown\n    self.inst:DoTaskInTime(duration, function()\n        self:EndCooldown(id)\n    end)\nend\n\nfunction CooldownManager:EndCooldown(id)\n    if not TheWorld.ismastersim then return end\n    \n    self.cooldowns[id] = nil\n    \n    -- Notify that cooldown ended\n    self.inst:PushEvent("cooldown_ended", {id = id})\nend\n\nfunction CooldownManager:IsOnCooldown(id)\n    if not TheWorld.ismastersim then return false end\n    \n    local cooldown = self.cooldowns[id]\n    if not cooldown then return false end\n    \n    return (GetTime() - cooldown.start_time) < cooldown.duration\nend\n\nfunction CooldownManager:GetRemainingTime(id)\n    if not TheWorld.ismastersim then return 0 end\n    \n    local cooldown = self.cooldowns[id]\n    if not cooldown then return 0 end\n    \n    local elapsed = GetTime() - cooldown.start_time\n    return math.max(0, cooldown.duration - elapsed)\nend\n\n-- Client-side methods\nfunction CooldownManager:OnCooldownDirty()\n    if TheWorld.ismastersim then return end\n    \n    local id = self.net_cooldown_id:value()\n    local start_time = self.net_cooldown_time:value()\n    local duration = self.net_cooldown_duration:value()\n    \n    -- Notify client-side systems\n    self.inst:PushEvent("cooldown_updated_client", {\n        id = id,\n        start_time = start_time,\n        duration = duration,\n        remaining = math.max(0, duration - (GetTime() - start_time))\n    })\nend\n\n-- Pattern 3: Broadcasting world events to all players\nfunction BroadcastWorldEvent(event_name, data)\n    if not TheWorld.ismastersim then return end\n    \n    -- Encode event data\n    local event_data_json = json.encode({\n        name = event_name,\n        time = GetTime(),\n        data = data\n    })\n    \n    -- Set on world network variable\n    TheWorld.net_event:set(event_data_json)\n    \n    -- Also trigger server-side event\n    TheWorld:PushEvent(event_name, data)\nend\n\n-- Client-side handler for world events\nlocal function OnWorldEventReceived(world)\n    if TheWorld.ismastersim then return end\n    \n    local event_data_json = world.net_event:value()\n    local success, event_data = pcall(function() return json.decode(event_data_json) end)\n    \n    if success and event_data and event_data.name then\n        -- Trigger client-side event\n        TheWorld:PushEvent(event_data.name .. "_client", event_data.data)\n    end\nend\n\n-- Usage:\n-- BroadcastWorldEvent("boss_spawned", {boss_type = "deerclops", position = {x=10, y=0, z=20}})\n--\n-- Client-side:\n-- TheWorld:ListenForEvent("boss_spawned_client", function(world, data)\n--     print("Boss spawned: " .. data.boss_type)\n-- end)\n'})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>l});var i=t(6540);const a={},s=i.createContext(a);function o(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);