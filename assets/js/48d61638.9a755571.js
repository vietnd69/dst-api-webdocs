"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[4033],{8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>r});var t=a(6540);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}},9887:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-vanilla/updates/backwards-compatibility","title":"Backwards Compatibility","description":"Last Update: 2024-08-22","source":"@site/docs/api-vanilla/updates/backwards-compatibility.md","sourceDirName":"api-vanilla/updates","slug":"/api-vanilla/updates/backwards-compatibility","permalink":"/dst-api-webdocs/docs/api-vanilla/updates/backwards-compatibility","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"id":"backwards-compatibility","title":"Backwards Compatibility","sidebar_position":9,"last_updated":"2024-08-22T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Deprecated Features and Alternatives","permalink":"/dst-api-webdocs/docs/api-vanilla/updates/deprecated-features"},"next":{"title":"Migration Guides","permalink":"/dst-api-webdocs/docs/api-vanilla/updates/migration-guides"}}');var i=a(4848),s=a(8453);const l={id:"backwards-compatibility",title:"Backwards Compatibility",sidebar_position:9,last_updated:new Date("2024-08-22T00:00:00.000Z")},r="Backwards Compatibility",o={},c=[{value:"Why Backwards Compatibility Matters",id:"why-backwards-compatibility-matters",level:2},{value:"Compatibility Challenges",id:"compatibility-challenges",level:2},{value:"API Changes",id:"api-changes",level:3},{value:"Game Behavior Changes",id:"game-behavior-changes",level:3},{value:"Compatibility Strategies",id:"compatibility-strategies",level:2},{value:"Version Detection",id:"version-detection",level:3},{value:"Release ID Detection",id:"release-id-detection",level:3},{value:"Feature Detection",id:"feature-detection",level:3},{value:"Abstraction Layers",id:"abstraction-layers",level:3},{value:"Fallback Implementations",id:"fallback-implementations",level:3},{value:"Conditional Features",id:"conditional-features",level:3},{value:"Common Compatibility Issues",id:"common-compatibility-issues",level:2},{value:"Global Objects",id:"global-objects",level:3},{value:"Component Access",id:"component-access",level:3},{value:"Network Synchronization",id:"network-synchronization",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last Update: 2024-08-22"})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"backwards-compatibility",children:"Backwards Compatibility"})}),"\n",(0,i.jsx)(n.p,{children:"This guide focuses on maintaining backwards compatibility in your Don't Starve Together mods, allowing them to work across multiple game versions. Creating mods that function correctly on both older and newer versions of the game improves user experience and reduces maintenance overhead."}),"\n",(0,i.jsx)(n.h2,{id:"why-backwards-compatibility-matters",children:"Why Backwards Compatibility Matters"}),"\n",(0,i.jsx)(n.p,{children:"Maintaining backwards compatibility is important for several reasons:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Base"}),": Not all players update to the latest version immediately"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Server Compatibility"}),": Servers may run older versions of the game"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mod Collections"}),": Users may have collections of mods that work together"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced Maintenance"}),": Fewer version-specific branches to maintain"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"compatibility-challenges",children:"Compatibility Challenges"}),"\n",(0,i.jsx)(n.p,{children:"Several factors can affect backwards compatibility:"}),"\n",(0,i.jsx)(n.h3,{id:"api-changes",children:"API Changes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Added Features"}),": New components, functions, or properties"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modified Features"}),": Changes to existing functionality"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Removed Features"}),": Functionality that no longer exists"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Renamed Features"}),": Same functionality with different names"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To track all API changes between versions, refer to the ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/updates/api-changelog",children:"API Changelog"}),". This comprehensive document lists all significant changes, additions, and removals in each API version, which is essential for planning your compatibility strategy."]}),"\n",(0,i.jsx)(n.h3,{id:"game-behavior-changes",children:"Game Behavior Changes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physics Changes"}),": Modifications to collision or movement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance Changes"}),": Adjustments to game mechanics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"World Generation"}),": Changes to how worlds are created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Optimizations"}),": Changes that affect timing or execution order"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"compatibility-strategies",children:"Compatibility Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"version-detection",children:"Version Detection"}),"\n",(0,i.jsx)(n.p,{children:"Detect the game version to adapt your mod's behavior:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local function GetGameVersion()\n    if TheSim and TheSim.GetGameVersion then\n        return TheSim:GetGameVersion()\n    end\n    return "0.0.0" -- Default for very old versions\nend\n\nlocal game_version = GetGameVersion()\n\n-- Use version to determine behavior\nlocal function IsVersionAtLeast(major, minor, revision)\n    -- Implementation depends on version format\n    -- This is a simplified example\n    local current = game_version:match("(%d+)")\n    return current ~= nil and tonumber(current) >= major\nend\n\nif IsVersionAtLeast(400000) then\n    -- Use newer API\nelse\n    -- Use older API\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"release-id-detection",children:"Release ID Detection"}),"\n",(0,i.jsx)(n.p,{children:"Don't Starve Together provides mod release IDs that make version detection more semantic. This is often preferable to checking raw version numbers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Check if a specific release ID exists\nlocal function IsReleaseAvailable(release_id)\n    return ReleaseID ~= nil and ReleaseID[release_id] ~= nil\nend\n\n-- Using release IDs for feature checks\nif IsReleaseAvailable("R35_SANITYTROUBLES") then\n    -- Use features from the Sanity Troubles update\n    -- This is safer than checking raw version numbers\nelseif IsReleaseAvailable("R34_OCEANQOL_WINONAWURT") then\n    -- Use features from the Winona and Wurt update\nelse\n    -- Use pre-R34 features and implementations\nend\n\n-- Check which is the current release ID\nlocal current_release = ReleaseID and ReleaseID.Current or nil\nif current_release == "R35_SANITYTROUBLES" then\n    -- Specific behavior for the current release\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For a complete list of release IDs, see the ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/updates/mod-release-ids",children:"Mod Release IDs"})," document."]}),"\n",(0,i.jsx)(n.h3,{id:"feature-detection",children:"Feature Detection"}),"\n",(0,i.jsx)(n.p,{children:"Instead of version checking, detect if specific features exist:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Check if a function exists\nif TheWorld.state ~= nil then\n    -- Use new state system\n    local is_day = TheWorld.state.isday\nelse\n    -- Use old clock system\n    local is_day = GetClock() ~= nil and GetClock():IsDay()\nend\n\n-- Check if a component method exists\nif inst.components.health ~= nil then\n    if inst.components.health.SetMaxHealth ~= nil then\n        -- Use new method\n        inst.components.health:SetMaxHealth(100)\n    else\n        -- Use old property\n        inst.components.health.maxhealth = 100\n    end\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"abstraction-layers",children:"Abstraction Layers"}),"\n",(0,i.jsx)(n.p,{children:"Create wrapper functions that hide API differences:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Wrapper for getting the current player\nlocal function GetCurrentPlayer()\n    return ThePlayer or (GetPlayer ~= nil and GetPlayer()) or nil\nend\n\n-- Wrapper for getting the current phase\nlocal function GetCurrentPhase()\n    if TheWorld.state ~= nil then\n        return TheWorld.state.phase\n    elseif GetClock() ~= nil then\n        if GetClock():IsDay() then\n            return "day"\n        elseif GetClock():IsDusk() then\n            return "dusk"\n        else\n            return "night"\n        end\n    end\n    return "day" -- Default fallback\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"fallback-implementations",children:"Fallback Implementations"}),"\n",(0,i.jsx)(n.p,{children:"Provide alternative implementations when features are missing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Example: Implementing a missing function\nif not TheWorld.HasTag then\n    TheWorld.HasTag = function(self, tag)\n        return self.Network ~= nil and \n               self.Network.components ~= nil and \n               self.Network.components.tags ~= nil and \n               self.Network.components.tags:HasTag(tag)\n    end\nend\n\n-- Safe function calling with fallback\nlocal function SafeCall(obj, fn_name, ...)\n    if obj ~= nil and type(obj[fn_name]) == "function" then\n        return obj[fn_name](obj, ...)\n    end\n    return nil\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"conditional-features",children:"Conditional Features"}),"\n",(0,i.jsx)(n.p,{children:"Enable or disable features based on compatibility:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local CONFIG = {\n    -- Feature flags\n    use_new_network_api = true,\n    use_legacy_combat = false,\n    enable_advanced_features = true\n}\n\n-- Check if advanced features can be used\nlocal can_use_advanced = CONFIG.enable_advanced_features and \n                         TheWorld.state ~= nil and \n                         TheNet.GetClientTable ~= nil\n\nif can_use_advanced then\n    -- Implement advanced features\nelse\n    -- Implement basic features only\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-compatibility-issues",children:"Common Compatibility Issues"}),"\n",(0,i.jsx)(n.h3,{id:"global-objects",children:"Global Objects"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Safe access to global objects\nlocal world = TheWorld or GetWorld()\nlocal player = ThePlayer or (GetPlayer ~= nil and GetPlayer())\n"})}),"\n",(0,i.jsx)(n.h3,{id:"component-access",children:"Component Access"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Safe component access\nlocal function GetHealth(inst)\n    if inst == nil then return 0 end\n    \n    -- Server-side with component\n    if inst.components ~= nil and inst.components.health ~= nil then\n        return inst.components.health.currenthealth\n    end\n    \n    -- Client-side with replica\n    if inst.replica ~= nil and inst.replica.health ~= nil then\n        return inst.replica.health:GetCurrent()\n    end\n    \n    return 0\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"network-synchronization",children:"Network Synchronization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Compatible network variable setup\nlocal function SetupNetworking(inst)\n    -- Create network variable\n    local net_var = net_string(inst.GUID, "net_var", "net_var_dirty")\n    \n    -- Set initial value safely\n    if net_var.Set ~= nil then\n        net_var:Set("initial_value")\n    else\n        net_var.value = "initial_value"\n    end\n    \n    -- Get value safely\n    local function GetNetValue()\n        if net_var.Get ~= nil then\n            return net_var:Get()\n        else\n            return net_var.value\n        end\n    end\n    \n    inst.GetNetValue = GetNetValue\nend\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);