"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5252],{793:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api-vanilla/shared-properties/transformation-properties","title":"Transformation Properties","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/shared-properties/transformation-properties.md","sourceDirName":"api-vanilla/shared-properties","slug":"/api-vanilla/shared-properties/transformation-properties","permalink":"/dst-api-webdocs/docs/api-vanilla/shared-properties/transformation-properties","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"transformation-properties","title":"Transformation Properties","sidebar_position":5,"last_updated":"2023-07-06T00:00:00.000Z","version":619045},"sidebar":"docs","previous":{"title":"Network Properties","permalink":"/dst-api-webdocs/docs/api-vanilla/shared-properties/network-properties"},"next":{"title":"Node Types","permalink":"/dst-api-webdocs/docs/category/node-types"}}');var r=t(4848),a=t(8453);const s={id:"transformation-properties",title:"Transformation Properties",sidebar_position:5,last_updated:new Date("2023-07-06T00:00:00.000Z"),version:619045},o="Transformation Properties",l={},c=[{value:"Core Transformation Properties",id:"core-transformation-properties",level:2},{value:"Coordinate System",id:"coordinate-system",level:2},{value:"Position Management",id:"position-management",level:2},{value:"Position Methods",id:"position-methods",level:3},{value:"Position Utilities",id:"position-utilities",level:3},{value:"Rotation Management",id:"rotation-management",level:2},{value:"Rotation Methods",id:"rotation-methods",level:3},{value:"Rotation Utilities",id:"rotation-utilities",level:3},{value:"Scale Management",id:"scale-management",level:2},{value:"Scale Methods",id:"scale-methods",level:3},{value:"Hierarchy and Parenting",id:"hierarchy-and-parenting",level:2},{value:"Parenting Methods",id:"parenting-methods",level:3},{value:"Hierarchical Transformations",id:"hierarchical-transformations",level:3},{value:"Animation Integration",id:"animation-integration",level:2},{value:"Transformation Events",id:"transformation-events",level:2},{value:"Common Transformation Patterns",id:"common-transformation-patterns",level:2},{value:"Movement and Pathfinding",id:"movement-and-pathfinding",level:3},{value:"Orbiting Behavior",id:"orbiting-behavior",level:3},{value:"Visual Effects",id:"visual-effects",level:3},{value:"Transformation-Related Components",id:"transformation-related-components",level:2},{value:"Special Transformation Mechanics",id:"special-transformation-mechanics",level:2},{value:"Entity Spawning",id:"entity-spawning",level:3},{value:"Camera Transformation",id:"camera-transformation",level:3},{value:"Local vs. World Coordinates",id:"local-vs-world-coordinates",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"transformation-properties",children:"Transformation Properties"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"API Version: 619045"})}),"\n",(0,r.jsx)(e.p,{children:"Transformation properties are a set of shared attributes and mechanics that define how entities are positioned, oriented, and scaled within the game world of Don't Starve Together. They form the spatial foundation for all entity interactions and visual rendering."}),"\n",(0,r.jsx)(e.h2,{id:"core-transformation-properties",children:"Core Transformation Properties"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Property"}),(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Transform"})}),(0,r.jsx)(e.td,{children:"Component"}),(0,r.jsx)(e.td,{children:"Core component handling position, rotation, and scale"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"AnimState"})}),(0,r.jsx)(e.td,{children:"Component"}),(0,r.jsx)(e.td,{children:"Manages visual appearance and animations"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"position"})}),(0,r.jsx)(e.td,{children:"Vector3"}),(0,r.jsx)(e.td,{children:"Entity's 3D coordinates in the world (x, y, z)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"rotation"})}),(0,r.jsx)(e.td,{children:"Number"}),(0,r.jsx)(e.td,{children:"Orientation angle in degrees (0-360)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"scale"})}),(0,r.jsx)(e.td,{children:"Vector3"}),(0,r.jsx)(e.td,{children:"Size multiplier in each dimension (x, y, z)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"parent"})}),(0,r.jsx)(e.td,{children:"Entity"}),(0,r.jsx)(e.td,{children:"Entity this object is attached to (if any)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"facing"})}),(0,r.jsx)(e.td,{children:"Direction"}),(0,r.jsx)(e.td,{children:"Default facing direction (usually -Z axis)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"collision"})}),(0,r.jsx)(e.td,{children:"Shape"}),(0,r.jsx)(e.td,{children:"Physical collision boundary for interactions"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"coordinate-system",children:"Coordinate System"}),"\n",(0,r.jsx)(e.p,{children:"Don't Starve Together uses a 3D coordinate system with these characteristics:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"X-axis"}),": Positive east, negative west"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Y-axis"}),": Positive up, negative down (vertical)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Z-axis"}),": Positive south, negative north"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Origin"}),": (0,0,0) is typically at the center of the map"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Scale"}),": One unit is approximately one ground tile"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Standard positioning example\nlocal x, y, z = 10, 0, -5  -- 10 units east, 5 units north\ninst.Transform:SetPosition(x, y, z)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"position-management",children:"Position Management"}),"\n",(0,r.jsx)(e.p,{children:"Position is the most fundamental transformation property, determining where an entity exists in the world:"}),"\n",(0,r.jsx)(e.h3,{id:"position-methods",children:"Position Methods"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Set absolute world position\ninst.Transform:SetPosition(x, y, z)\n\n-- Get current world position\nlocal x, y, z = inst.Transform:GetWorldPosition()\n\n-- Physics-based teleportation (if entity has Physics)\ninst.Physics:Teleport(x, y, z)\n\n-- Move relative to current position\nlocal current_x, current_y, current_z = inst.Transform:GetWorldPosition()\ninst.Transform:SetPosition(current_x + offset_x, current_y + offset_y, current_z + offset_z)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"position-utilities",children:"Position Utilities"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Calculate distance between entities\nlocal dist_sq = inst:GetDistanceSqToInst(other_entity)\nlocal dist = math.sqrt(dist_sq)\n\n-- Calculate distance to a point\nlocal dist_sq = inst:GetDistanceSqToPoint(x, y, z)\n\n-- Check if entity is near a point\nlocal is_near = inst:IsNear(Point(x, y, z), radius)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"rotation-management",children:"Rotation Management"}),"\n",(0,r.jsx)(e.p,{children:"Rotation defines which direction an entity is facing:"}),"\n",(0,r.jsx)(e.h3,{id:"rotation-methods",children:"Rotation Methods"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Set rotation angle (in degrees, 0-360)\ninst.Transform:SetRotation(angle)\n\n-- Get current rotation angle\nlocal angle = inst.Transform:GetRotation()\n\n-- Face a specific point\nlocal target_x, target_y, target_z = target.Transform:GetWorldPosition()\nlocal current_x, current_y, current_z = inst.Transform:GetWorldPosition()\nlocal dx, dz = target_x - current_x, target_z - current_z\nlocal angle = math.atan2(-dz, dx) * RADIANS\ninst.Transform:SetRotation(angle)\n\n-- Rotate incrementally\nlocal current_angle = inst.Transform:GetRotation()\ninst.Transform:SetRotation(current_angle + delta_angle)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"rotation-utilities",children:"Rotation Utilities"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Get angle to a point\nlocal angle = inst:GetAngleToPoint(x, y, z)\n\n-- Get angle to another entity\nlocal angle = inst:GetAngleToInst(other_entity)\n\n-- Get forward vector based on rotation\nlocal angle_rad = inst.Transform:GetRotation() * DEGREES\nlocal forward_x = math.cos(angle_rad)\nlocal forward_z = -math.sin(angle_rad)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"scale-management",children:"Scale Management"}),"\n",(0,r.jsx)(e.p,{children:"Scale affects the visual and sometimes physical size of entities:"}),"\n",(0,r.jsx)(e.h3,{id:"scale-methods",children:"Scale Methods"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Set uniform scale (same in all dimensions)\ninst.Transform:SetScale(scale)\n\n-- Set non-uniform scale (different for each axis)\ninst.Transform:SetScale(x_scale, y_scale, z_scale)\n\n-- Get current scale\nlocal scale = inst.Transform:GetScale()\n\n-- Scale gradually (grow or shrink over time)\ninst:DoTaskInTime(0, function(inst)\n    inst.Transform:SetScale(0.1, 0.1, 0.1) -- Start small\n    \n    inst:DoPeriodicTask(0.05, function(inst)\n        local current_scale = inst.Transform:GetScale()\n        if current_scale < 1.0 then\n            inst.Transform:SetScale(current_scale + 0.05)\n        end\n    end, 0, 18) -- Grow over time\nend)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"hierarchy-and-parenting",children:"Hierarchy and Parenting"}),"\n",(0,r.jsx)(e.p,{children:"Entities can be attached to create hierarchical relationships:"}),"\n",(0,r.jsx)(e.h3,{id:"parenting-methods",children:"Parenting Methods"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Attach child to parent\nchild_entity.entity:SetParent(parent_entity.entity)\n\n-- Detach from parent\nchild_entity.entity:SetParent(nil)\n\n-- Get parent entity\nlocal parent = child_entity.entity:GetParent()\n\n-- Set local position relative to parent\nchild_entity.Transform:SetPosition(local_x, local_y, local_z)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"hierarchical-transformations",children:"Hierarchical Transformations"}),"\n",(0,r.jsx)(e.p,{children:"When entities are parented:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Child's world position = Parent's position + Child's local position"}),"\n",(0,r.jsx)(e.li,{children:"Child inherits parent's rotation and scale"}),"\n",(0,r.jsx)(e.li,{children:"Moving the parent also moves all children"}),"\n",(0,r.jsx)(e.li,{children:"Removing the parent maintains children's world positions"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"animation-integration",children:"Animation Integration"}),"\n",(0,r.jsx)(e.p,{children:"Transformations work closely with the animation system:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:'-- Set up animation basics\ninst.AnimState:SetBank("character_bank")\ninst.AnimState:SetBuild("character_build")\ninst.AnimState:PlayAnimation("idle")\n\n-- Override specific symbols with transformed versions\ninst.AnimState:OverrideSymbol("swap_object", "swap_hammer", "swap_hammer")\n\n-- Scale animation\ninst.AnimState:SetScale(1.2, 1.2)\n\n-- Flip animation horizontally\ninst.AnimState:SetScale(-1, 1)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"transformation-events",children:"Transformation Events"}),"\n",(0,r.jsx)(e.p,{children:"Several events are triggered by transformation changes:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"onremove"})," - When entity is removed from the world"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"onbuilt"})," - When entity is first built/placed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"ms_positiondirty"})," - When position has been changed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"transform_changed"})," - Custom event some entities use when transformed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"animover"})," - When an animation completes"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-transformation-patterns",children:"Common Transformation Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"movement-and-pathfinding",children:"Movement and Pathfinding"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Basic locomotor movement\ninst.components.locomotor:GoToPoint(destination)\n\n-- Follow target\nlocal function UpdateFollowing(inst)\n    if inst.follow_target and inst.follow_target:IsValid() then\n        local target_x, target_y, target_z = inst.follow_target.Transform:GetWorldPosition()\n        local my_x, my_y, my_z = inst.Transform:GetWorldPosition()\n        \n        local dist_sq = inst:GetDistanceSqToInst(inst.follow_target)\n        if dist_sq > min_follow_dist * min_follow_dist then\n            inst.components.locomotor:GoToPoint(Point(target_x, target_y, target_z))\n        else\n            inst.components.locomotor:Stop()\n        end\n    end\nend\n\ninst:DoPeriodicTask(0.5, UpdateFollowing)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"orbiting-behavior",children:"Orbiting Behavior"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Make entity orbit around a point\nlocal function UpdateOrbit(inst)\n    local angle = (inst.orbit_angle or 0) + inst.orbit_speed\n    inst.orbit_angle = angle\n    \n    local orbit_x = inst.orbit_center_x + math.cos(angle * DEGREES) * inst.orbit_radius\n    local orbit_z = inst.orbit_center_z + math.sin(angle * DEGREES) * inst.orbit_radius\n    \n    inst.Transform:SetPosition(orbit_x, inst.orbit_center_y, orbit_z)\nend\n\ninst.orbit_center_x, inst.orbit_center_y, inst.orbit_center_z = center_entity.Transform:GetWorldPosition()\ninst.orbit_radius = 5\ninst.orbit_speed = 2\ninst.orbit_angle = 0\n\ninst:DoPeriodicTask(FRAMES, UpdateOrbit)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"visual-effects",children:"Visual Effects"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Pulsing scale effect\nlocal function PulseScale(inst)\n    local s = 1 + 0.1 * math.sin(GetTime() * 3)\n    inst.Transform:SetScale(s, s, s)\nend\n\ninst:DoPeriodicTask(FRAMES, PulseScale)\n\n-- Spin effect\nlocal function Spin(inst)\n    local current_angle = inst.Transform:GetRotation()\n    inst.Transform:SetRotation(current_angle + 2)\nend\n\ninst:DoPeriodicTask(FRAMES, Spin)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"transformation-related-components",children:"Transformation-Related Components"}),"\n",(0,r.jsx)(e.p,{children:"Several components interact with transformation properties:"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Component"}),(0,r.jsx)(e.th,{children:"Key Transformation Interactions"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Transform"})}),(0,r.jsx)(e.td,{children:"Core component for all spatial properties"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"AnimState"})}),(0,r.jsx)(e.td,{children:"Visual appearance and animations"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Locomotor"})}),(0,r.jsx)(e.td,{children:"Movement with pathfinding and collision avoidance"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Physics"})}),(0,r.jsx)(e.td,{children:"Physical collisions and forces"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Follower"})}),(0,r.jsx)(e.td,{children:"For entities that follow other entities"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Knownlocations"})}),(0,r.jsx)(e.td,{children:"Tracking important locations (home, etc.)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Walkableplatform"})}),(0,r.jsx)(e.td,{children:"For surfaces that can be walked on"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"Grouplocation"})}),(0,r.jsx)(e.td,{children:"Group movement behaviors"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"special-transformation-mechanics",children:"Special Transformation Mechanics"}),"\n",(0,r.jsx)(e.h3,{id:"entity-spawning",children:"Entity Spawning"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Spawn entity at a specific position\nlocal function SpawnAtPosition(prefab, x, y, z)\n    local inst = SpawnPrefab(prefab)\n    if inst then\n        inst.Transform:SetPosition(x, y, z)\n    end\n    return inst\nend\n\n-- Spawn entity near another entity\nlocal function SpawnNearEntity(prefab, target, radius)\n    local x, y, z = target.Transform:GetWorldPosition()\n    \n    -- Find random point in circle\n    local angle = math.random() * 2 * PI\n    local offset_x = math.cos(angle) * radius\n    local offset_z = math.sin(angle) * radius\n    \n    return SpawnAtPosition(prefab, x + offset_x, y, z + offset_z)\nend\n"})}),"\n",(0,r.jsx)(e.h3,{id:"camera-transformation",children:"Camera Transformation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Focus camera on entity\nTheCamera:SetTarget(entity)\n\n-- Set custom camera position\nTheCamera:SetCustomLocation(Vector3(x, y, z))\n\n-- Pan camera\nlocal function PanCamera(start_pos, end_pos, duration)\n    local start_time = GetTime()\n    local end_time = start_time + duration\n    \n    local function UpdateCameraPos()\n        local current_time = GetTime()\n        if current_time >= end_time then\n            TheCamera:SetCustomLocation(end_pos)\n            return true\n        end\n        \n        local t = (current_time - start_time) / duration\n        local smooth_t = t * t * (3 - 2 * t)  -- Smoothstep interpolation\n        local current_pos = LerpVector3(start_pos, end_pos, smooth_t)\n        \n        TheCamera:SetCustomLocation(current_pos)\n        return false\n    end\n    \n    StartThread(function()\n        while not UpdateCameraPos() do\n            Sleep(FRAMES)\n        end\n    end)\nend\n"})}),"\n",(0,r.jsx)(e.h3,{id:"local-vs-world-coordinates",children:"Local vs. World Coordinates"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-lua",children:"-- Convert local to world coordinates (for parented entities)\nfunction LocalToWorldPosition(parent, local_x, local_y, local_z)\n    local parent_x, parent_y, parent_z = parent.Transform:GetWorldPosition()\n    local angle_rad = parent.Transform:GetRotation() * DEGREES\n    local world_x = parent_x + local_x * math.cos(angle_rad) - local_z * math.sin(angle_rad)\n    local world_z = parent_z + local_x * math.sin(angle_rad) + local_z * math.cos(angle_rad)\n    return world_x, parent_y + local_y, world_z\nend\n"})}),"\n",(0,r.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimize Frequent Updates"}),": Avoid updating transformation properties every frame if possible"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Batch Transformations"}),": Combine position and rotation changes when appropriate"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use Appropriate Techniques"}),": Choose the right transformation approach for the task","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"Transform"})," for visual positioning"]}),"\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"Physics:Teleport()"})," for entities with physics"]}),"\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"parent-child"})," relationships for grouped movements"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Limit Scale Operations"}),": Scale changes are more expensive than position changes"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Consider Animation Cost"}),": Complex animation overrides can impact performance"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/shared-properties/transform",children:"Transform"})," - Detailed documentation of the Transform component"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/animstate-system",children:"AnimState"})," - For visual transformation integration"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/physics",children:"Physics"})," - For physics-based transformations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/entity-system",children:"Position Management"})," - For more about entity positioning"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/snippets/entity-spawning",children:"Entity Spawning"})," - For entity creation and placement"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/dst-api-webdocs/docs/api-vanilla/components/locomotor",children:"Locomotor"})," - For entity movement with pathfinding"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);