"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[125],{4404:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"api-vanilla/examples/snippets/component-snippets","title":"Component Snippets","description":"This page provides reusable code snippets for creating and modifying components in Don\'t Starve Together mods.","source":"@site/docs/api-vanilla/examples/snippets/component-snippets.md","sourceDirName":"api-vanilla/examples/snippets","slug":"/api-vanilla/examples/snippets/component-snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/component-snippets","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"component-snippets","title":"Component Snippets","sidebar_position":6,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Networking Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/networking-snippets"},"next":{"title":"Animation Snippets","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/snippets/animation-snippets"}}');var a=t(4848),i=t(8453);const s={id:"component-snippets",title:"Component Snippets",sidebar_position:6,last_updated:new Date("2023-07-06T00:00:00.000Z")},l="Component Snippets",r={},d=[{value:"Basic Component Creation",id:"basic-component-creation",level:2},{value:"Simple Component Template",id:"simple-component-template",level:3},{value:"Adding Component to an Entity",id:"adding-component-to-an-entity",level:3},{value:"Advanced Component Examples",id:"advanced-component-examples",level:2},{value:"Component with Replication",id:"component-with-replication",level:3},{value:"Component with Action Integration",id:"component-with-action-integration",level:3},{value:"Component Integration Examples",id:"component-integration-examples",level:2},{value:"Component that Integrates with Health",id:"component-that-integrates-with-health",level:3},{value:"Component that Integrates with Inventory",id:"component-that-integrates-with-inventory",level:3}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"component-snippets",children:"Component Snippets"})}),"\n",(0,a.jsx)(e.p,{children:"This page provides reusable code snippets for creating and modifying components in Don't Starve Together mods."}),"\n",(0,a.jsx)(e.h2,{id:"basic-component-creation",children:"Basic Component Creation"}),"\n",(0,a.jsx)(e.h3,{id:"simple-component-template",children:"Simple Component Template"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a simple component\nlocal MyComponent = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Initialize component properties\n    self.value = 0\n    self.enabled = true\n    self.cooldown = 0\n    \n    -- Add a periodic task\n    self.task = self.inst:DoPeriodicTask(1, function() self:OnUpdate() end)\nend)\n\n-- Add a method to the component\nfunction MyComponent:SetValue(val)\n    self.value = val\n    self.inst:PushEvent("valuechanged", {value = val})\nend\n\n-- Update method called by periodic task\nfunction MyComponent:OnUpdate()\n    if not self.enabled then return end\n    \n    if self.cooldown > 0 then\n        self.cooldown = self.cooldown - 1\n    end\nend\n\n-- Enable/disable the component\nfunction MyComponent:Enable(enable)\n    self.enabled = enable\nend\n\n-- Clean up when component is removed\nfunction MyComponent:OnRemoveFromEntity()\n    if self.task then\n        self.task:Cancel()\n        self.task = nil\n    end\nend\n\n-- Save/load functionality\nfunction MyComponent:OnSave()\n    return {\n        value = self.value,\n        enabled = self.enabled,\n        cooldown = self.cooldown\n    }\nend\n\nfunction MyComponent:OnLoad(data)\n    if data then\n        self.value = data.value or self.value\n        self.enabled = data.enabled ~= nil and data.enabled or self.enabled\n        self.cooldown = data.cooldown or self.cooldown\n    end\nend\n\nreturn MyComponent\n'})}),"\n",(0,a.jsx)(e.h3,{id:"adding-component-to-an-entity",children:"Adding Component to an Entity"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- In a prefab file\nlocal function fn()\n    local inst = CreateEntity()\n    \n    -- Add standard components\n    inst.entity:AddTransform()\n    inst.entity:AddAnimState()\n    inst.entity:AddNetwork()\n    \n    -- Add custom component\n    inst:AddComponent("mycomponent")\n    inst.components.mycomponent:SetValue(10)\n    \n    return inst\nend\n\n-- In modmain.lua to register the component\nlocal MyComponent = require "components/mycomponent"\nAddComponentPostInit("mycomponent", MyComponent)\n\n-- OR to add the component to an existing prefab\nAddPrefabPostInit("wilson", function(inst)\n    if not inst.components.mycomponent then\n        inst:AddComponent("mycomponent")\n    end\nend)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-component-examples",children:"Advanced Component Examples"}),"\n",(0,a.jsx)(e.h3,{id:"component-with-replication",children:"Component with Replication"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component with client-side replication\nlocal MyReplicatedComponent = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Server-side properties\n    self.max_value = 100\n    self.current_value = 100\n    self.regen_rate = 1\n    \n    -- Network variables\n    self.net_value = net_float(inst.GUID, "myreplicatedcomponent.value", "valuedirty")\n    self.net_max = net_float(inst.GUID, "myreplicatedcomponent.max", "maxdirty")\n    \n    -- Initialize network values\n    if TheWorld.ismastersim then\n        self.net_value:set(self.current_value)\n        self.net_max:set(self.max_value)\n    else\n        -- Client-side event handlers\n        inst:ListenForEvent("valuedirty", function() self:OnValueDirty() end)\n        inst:ListenForEvent("maxdirty", function() self:OnMaxDirty() end)\n    end\n    \n    -- Start regeneration task on server\n    if TheWorld.ismastersim then\n        self.regen_task = inst:DoPeriodicTask(1, function() self:OnRegenTick() end)\n    end\nend)\n\n-- Server-side methods\nfunction MyReplicatedComponent:SetValue(val)\n    if not TheWorld.ismastersim then return end\n    \n    self.current_value = math.clamp(val, 0, self.max_value)\n    self.net_value:set(self.current_value)\n    \n    self.inst:PushEvent("valuechanged", {value = self.current_value})\nend\n\nfunction MyReplicatedComponent:SetMax(val)\n    if not TheWorld.ismastersim then return end\n    \n    self.max_value = val\n    self.net_max:set(val)\n    \n    -- Clamp current value to new max\n    if self.current_value > self.max_value then\n        self:SetValue(self.max_value)\n    end\n    \n    self.inst:PushEvent("maxchanged", {max = self.max_value})\nend\n\nfunction MyReplicatedComponent:DoDelta(delta)\n    if not TheWorld.ismastersim then return end\n    \n    self:SetValue(self.current_value + delta)\nend\n\nfunction MyReplicatedComponent:OnRegenTick()\n    if not TheWorld.ismastersim then return end\n    \n    if self.current_value < self.max_value then\n        self:DoDelta(self.regen_rate)\n    end\nend\n\n-- Client-side methods\nfunction MyReplicatedComponent:OnValueDirty()\n    if TheWorld.ismastersim then return end\n    \n    local old_value = self.current_value\n    self.current_value = self.net_value:value()\n    \n    -- Trigger client-side event\n    self.inst:PushEvent("valuechanged_client", {\n        old_value = old_value,\n        new_value = self.current_value\n    })\nend\n\nfunction MyReplicatedComponent:OnMaxDirty()\n    if TheWorld.ismastersim then return end\n    \n    local old_max = self.max_value\n    self.max_value = self.net_max:value()\n    \n    -- Trigger client-side event\n    self.inst:PushEvent("maxchanged_client", {\n        old_max = old_max,\n        new_max = self.max_value\n    })\nend\n\n-- Methods that work on both client and server\nfunction MyReplicatedComponent:GetPercent()\n    return self.current_value / self.max_value\nend\n\nfunction MyReplicatedComponent:GetValue()\n    return self.current_value\nend\n\nfunction MyReplicatedComponent:GetMax()\n    return self.max_value\nend\n\n-- Clean up\nfunction MyReplicatedComponent:OnRemoveFromEntity()\n    if self.regen_task then\n        self.regen_task:Cancel()\n        self.regen_task = nil\n    end\nend\n\n-- Save/load\nfunction MyReplicatedComponent:OnSave()\n    if not TheWorld.ismastersim then return end\n    \n    return {\n        current_value = self.current_value,\n        max_value = self.max_value,\n        regen_rate = self.regen_rate\n    }\nend\n\nfunction MyReplicatedComponent:OnLoad(data)\n    if not TheWorld.ismastersim then return end\n    \n    if data then\n        self.max_value = data.max_value or self.max_value\n        self.regen_rate = data.regen_rate or self.regen_rate\n        \n        -- Set value last to ensure it\'s clamped to the loaded max\n        if data.current_value then\n            self:SetValue(data.current_value)\n        end\n        \n        -- Update network values\n        self.net_max:set(self.max_value)\n    end\nend\n\nreturn MyReplicatedComponent\n'})}),"\n",(0,a.jsx)(e.h3,{id:"component-with-action-integration",children:"Component with Action Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component that adds a custom action\nlocal MyActionComponent = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Component properties\n    self.uses_remaining = 10\n    self.use_fn = nil\n    self.can_use_test = nil\n    \n    -- Add action tag to entity\n    inst:AddTag("myactionable")\nend)\n\n-- Set the function to call when used\nfunction MyActionComponent:SetOnUseFn(fn)\n    self.use_fn = fn\nend\n\n-- Set a test function to determine if the action can be performed\nfunction MyActionComponent:SetCanUseTest(fn)\n    self.can_use_test = fn\nend\n\n-- Called when the action is performed\nfunction MyActionComponent:Use(doer)\n    if self.uses_remaining <= 0 then\n        return false\n    end\n    \n    -- Run custom test if provided\n    if self.can_use_test and not self.can_use_test(self.inst, doer) then\n        return false\n    end\n    \n    -- Decrease uses\n    self.uses_remaining = self.uses_remaining - 1\n    \n    -- Call custom use function if provided\n    if self.use_fn then\n        self.use_fn(self.inst, doer)\n    end\n    \n    -- Trigger events\n    self.inst:PushEvent("used", {doer = doer})\n    \n    -- Remove component when uses are depleted\n    if self.uses_remaining <= 0 then\n        self.inst:RemoveComponent("myactioncomponent")\n    end\n    \n    return true\nend\n\n-- Save/load\nfunction MyActionComponent:OnSave()\n    return {\n        uses_remaining = self.uses_remaining\n    }\nend\n\nfunction MyActionComponent:OnLoad(data)\n    if data then\n        self.uses_remaining = data.uses_remaining or self.uses_remaining\n    end\nend\n\n-- Define the action in modmain.lua\n--[[\nlocal MYACTION = Action({priority=10, mount_valid=true})\nMYACTION.str = "Use"\nMYACTION.id = "MYACTION"\nMYACTION.fn = function(act)\n    if act.target and act.target.components.myactioncomponent then\n        return act.target.components.myactioncomponent:Use(act.doer)\n    end\n    return false\nend\n\n-- Add the action to the component action handler\nAddComponentAction("SCENE", "myactioncomponent", function(inst, doer, actions, right)\n    if right and inst:HasTag("myactionable") then\n        table.insert(actions, ACTIONS.MYACTION)\n    end\nend)\n]]--\n\nreturn MyActionComponent\n'})}),"\n",(0,a.jsx)(e.h2,{id:"component-integration-examples",children:"Component Integration Examples"}),"\n",(0,a.jsx)(e.h3,{id:"component-that-integrates-with-health",children:"Component that Integrates with Health"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component that integrates with the health component\nlocal HealthModifier = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Component properties\n    self.health_bonus = 0\n    self.regen_amount = 0\n    self.damage_reduction = 0\n    \n    -- Apply effects when added\n    self:ApplyEffects()\n    \n    -- Listen for health events\n    inst:ListenForEvent("healthdelta", function(inst, data) self:OnHealthDelta(data) end)\nend)\n\n-- Apply health modifiers\nfunction HealthModifier:ApplyEffects()\n    local health = self.inst.components.health\n    if not health then return end\n    \n    -- Store original max health if not already stored\n    if not self.original_max_health then\n        self.original_max_health = health.maxhealth\n    end\n    \n    -- Apply max health bonus\n    if self.health_bonus ~= 0 then\n        health:SetMaxHealth(self.original_max_health + self.health_bonus)\n    end\nend\n\n-- Set health bonus\nfunction HealthModifier:SetHealthBonus(bonus)\n    self.health_bonus = bonus\n    self:ApplyEffects()\nend\n\n-- Set damage reduction (0-1 range, where 1 is 100% reduction)\nfunction HealthModifier:SetDamageReduction(reduction)\n    self.damage_reduction = math.clamp(reduction, 0, 1)\nend\n\n-- Set health regeneration amount per second\nfunction HealthModifier:SetRegeneration(amount)\n    self.regen_amount = amount\n    \n    -- Cancel existing regen task if any\n    if self.regen_task then\n        self.regen_task:Cancel()\n        self.regen_task = nil\n    end\n    \n    -- Start new regen task if amount is positive\n    if amount > 0 then\n        self.regen_task = self.inst:DoPeriodicTask(1, function() self:DoRegeneration() end)\n    end\nend\n\n-- Apply regeneration\nfunction HealthModifier:DoRegeneration()\n    local health = self.inst.components.health\n    if not health or health:IsDead() then return end\n    \n    health:DoDelta(self.regen_amount, true, "healthmodifier")\nend\n\n-- Handle health delta events\nfunction HealthModifier:OnHealthDelta(data)\n    -- Skip if not damage or if caused by this component\n    if data.amount >= 0 or data.cause == "healthmodifier" then return end\n    \n    -- Apply damage reduction\n    if self.damage_reduction > 0 and data.amount < 0 then\n        local health = self.inst.components.health\n        local reduction_amount = -data.amount * self.damage_reduction\n        \n        -- Apply healing to counteract some of the damage\n        health:DoDelta(reduction_amount, true, "healthmodifier")\n    end\nend\n\n-- Clean up when removed\nfunction HealthModifier:OnRemoveFromEntity()\n    -- Restore original max health\n    if self.original_max_health and self.inst.components.health then\n        self.inst.components.health:SetMaxHealth(self.original_max_health)\n    end\n    \n    -- Cancel regen task\n    if self.regen_task then\n        self.regen_task:Cancel()\n        self.regen_task = nil\n    end\nend\n\n-- Save/load\nfunction HealthModifier:OnSave()\n    return {\n        health_bonus = self.health_bonus,\n        regen_amount = self.regen_amount,\n        damage_reduction = self.damage_reduction,\n        original_max_health = self.original_max_health\n    }\nend\n\nfunction HealthModifier:OnLoad(data)\n    if data then\n        self.health_bonus = data.health_bonus or self.health_bonus\n        self.damage_reduction = data.damage_reduction or self.damage_reduction\n        self.original_max_health = data.original_max_health\n        \n        -- Apply effects\n        self:ApplyEffects()\n        \n        -- Set regeneration last to start the task if needed\n        self:SetRegeneration(data.regen_amount or self.regen_amount)\n    end\nend\n\nreturn HealthModifier\n'})}),"\n",(0,a.jsx)(e.h3,{id:"component-that-integrates-with-inventory",children:"Component that Integrates with Inventory"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- Define a component that integrates with the inventory component\nlocal InventoryExtension = Class(function(self, inst)\n    self.inst = inst\n    \n    -- Component properties\n    self.extra_slots = 0\n    self.item_use_bonus = {}\n    self.drop_on_death = true\n    \n    -- Apply effects when added\n    self:ApplyEffects()\n    \n    -- Listen for inventory events\n    inst:ListenForEvent("itemget", function(inst, data) self:OnItemGet(data) end)\n    inst:ListenForEvent("itemlose", function(inst, data) self:OnItemLose(data) end)\n    inst:ListenForEvent("death", function(inst) self:OnDeath() end)\nend)\n\n-- Apply inventory modifications\nfunction InventoryExtension:ApplyEffects()\n    local inventory = self.inst.components.inventory\n    if not inventory then return end\n    \n    -- Store original max slots if not already stored\n    if not self.original_max_slots then\n        self.original_max_slots = inventory.maxslots\n    end\n    \n    -- Apply extra slots\n    if self.extra_slots > 0 then\n        inventory.maxslots = self.original_max_slots + self.extra_slots\n    end\nend\n\n-- Set extra inventory slots\nfunction InventoryExtension:SetExtraSlots(slots)\n    self.extra_slots = math.max(0, slots)\n    self:ApplyEffects()\nend\n\n-- Add item use bonus\nfunction InventoryExtension:AddItemUseBonus(item_type, bonus)\n    self.item_use_bonus[item_type] = bonus\nend\n\n-- Remove item use bonus\nfunction InventoryExtension:RemoveItemUseBonus(item_type)\n    self.item_use_bonus[item_type] = nil\nend\n\n-- Get item use bonus for a specific item\nfunction InventoryExtension:GetItemUseBonus(item)\n    if not item or not item.prefab then return 0 end\n    return self.item_use_bonus[item.prefab] or 0\nend\n\n-- Handle item acquisition\nfunction InventoryExtension:OnItemGet(data)\n    local item = data.item\n    if not item then return end\n    \n    -- Apply any special effects when getting an item\n    if item.components.finiteuses and self.item_use_bonus[item.prefab] then\n        -- Store original max uses if not already stored\n        if not item.original_max_uses then\n            item.original_max_uses = item.components.finiteuses.total\n        end\n        \n        -- Apply bonus\n        local bonus = self.item_use_bonus[item.prefab]\n        item.components.finiteuses.total = item.original_max_uses * (1 + bonus)\n    end\nend\n\n-- Handle item loss\nfunction InventoryExtension:OnItemLose(data)\n    local item = data.item\n    if not item then return end\n    \n    -- Restore original values when losing an item\n    if item.components.finiteuses and item.original_max_uses then\n        item.components.finiteuses.total = item.original_max_uses\n        item.original_max_uses = nil\n    end\nend\n\n-- Handle death\nfunction InventoryExtension:OnDeath()\n    if not self.drop_on_death then return end\n    \n    -- Drop special items instead of destroying them\n    local inventory = self.inst.components.inventory\n    if not inventory then return end\n    \n    -- Find special items to drop\n    local items_to_drop = {}\n    for i = 1, inventory:NumItems() do\n        local item = inventory:GetItemInSlot(i)\n        if item and self.item_use_bonus[item.prefab] then\n            table.insert(items_to_drop, item)\n        end\n    end\n    \n    -- Drop the special items\n    for _, item in ipairs(items_to_drop) do\n        inventory:DropItem(item)\n    end\nend\n\n-- Clean up when removed\nfunction InventoryExtension:OnRemoveFromEntity()\n    -- Restore original inventory size\n    local inventory = self.inst.components.inventory\n    if inventory and self.original_max_slots then\n        inventory.maxslots = self.original_max_slots\n    end\n    \n    -- Restore original item values\n    if inventory then\n        for i = 1, inventory:NumItems() do\n            local item = inventory:GetItemInSlot(i)\n            if item and item.components.finiteuses and item.original_max_uses then\n                item.components.finiteuses.total = item.original_max_uses\n                item.original_max_uses = nil\n            end\n        end\n    end\nend\n\n-- Save/load\nfunction InventoryExtension:OnSave()\n    return {\n        extra_slots = self.extra_slots,\n        item_use_bonus = self.item_use_bonus,\n        drop_on_death = self.drop_on_death,\n        original_max_slots = self.original_max_slots\n    }\nend\n\nfunction InventoryExtension:OnLoad(data)\n    if data then\n        self.extra_slots = data.extra_slots or self.extra_slots\n        self.item_use_bonus = data.item_use_bonus or self.item_use_bonus\n        self.drop_on_death = data.drop_on_death ~= nil and data.drop_on_death or self.drop_on_death\n        self.original_max_slots = data.original_max_slots\n        \n        -- Apply effects\n        self:ApplyEffects()\n    end\nend\n\nreturn InventoryExtension\n'})})]})}function f(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>l});var o=t(6540);const a={},i=o.createContext(a);function s(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);