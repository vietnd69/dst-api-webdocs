"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[2475],{7583:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api-vanilla/examples/case-geometric","title":"Case Study - Geometric Placement","description":"This case study examines the popular \\"Geometric Placement\\" mod for Don\'t Starve Together, which enhances the building system by adding grid-based placement options. We\'ll analyze its implementation and learn valuable modding techniques.","source":"@site/docs/api-vanilla/examples/case-geometric.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/case-geometric","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-geometric","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"id":"case-geometric","title":"Case Study - Geometric Placement","sidebar_position":11},"sidebar":"docs","previous":{"title":"Profiling and Debugging Performance Issues","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/profiling-debugging"},"next":{"title":"Case Study - Wormhole Marks","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/case-wormhole"}}');var s=i(4848),o=i(8453);const l={id:"case-geometric",title:"Case Study - Geometric Placement",sidebar_position:11},r="Case Study: Geometric Placement Mod",a={},d=[{value:"Mod Overview",id:"mod-overview",level:2},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"Core Techniques Used",id:"core-techniques-used",level:3},{value:"1. Placement Prediction Modification",id:"1-placement-prediction-modification",level:2},{value:"Key Code Elements",id:"key-code-elements",level:3},{value:"Implementation Analysis",id:"implementation-analysis",level:3},{value:"2. Multiple Geometry Systems",id:"2-multiple-geometry-systems",level:2},{value:"Key Code Elements",id:"key-code-elements-1",level:3},{value:"Implementation Analysis",id:"implementation-analysis-1",level:3},{value:"3. Visual Feedback System",id:"3-visual-feedback-system",level:2},{value:"Key Code Elements",id:"key-code-elements-2",level:3},{value:"Implementation Analysis",id:"implementation-analysis-2",level:3},{value:"4. Configuration Management",id:"4-configuration-management",level:2},{value:"Key Code Elements",id:"key-code-elements-3",level:3},{value:"Implementation Analysis",id:"implementation-analysis-3",level:3},{value:"5. Performance Optimization",id:"5-performance-optimization",level:2},{value:"Key Code Elements",id:"key-code-elements-4",level:3},{value:"Implementation Analysis",id:"implementation-analysis-4",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"1. Non-Invasive Modification",id:"1-non-invasive-modification",level:3},{value:"2. User Experience Focus",id:"2-user-experience-focus",level:3},{value:"3. Performance Consciousness",id:"3-performance-consciousness",level:3},{value:"4. Progressive Enhancement",id:"4-progressive-enhancement",level:3},{value:"Implementing Similar Features",id:"implementing-similar-features",level:2},{value:"Step 1: Study the Placement System",id:"step-1-study-the-placement-system",level:3},{value:"Step 2: Create a Basic Placement Hook",id:"step-2-create-a-basic-placement-hook",level:3},{value:"Step 3: Add Visual Feedback",id:"step-3-add-visual-feedback",level:3},{value:"Step 4: Implement User Controls",id:"step-4-implement-user-controls",level:3},{value:"Cross-References and Related Documentation",id:"cross-references-and-related-documentation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"case-study-geometric-placement-mod",children:"Case Study: Geometric Placement Mod"})}),"\n",(0,s.jsx)(n.p,{children:"This case study examines the popular \"Geometric Placement\" mod for Don't Starve Together, which enhances the building system by adding grid-based placement options. We'll analyze its implementation and learn valuable modding techniques."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/rezecib/Geometric-Placement",children:"Github"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://steamcommunity.com/sharedfiles/filedetails/?id=351325790",children:"Steam Workshop"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mod-overview",children:"Mod Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Geometric Placement mod allows players to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Place structures on a customizable grid with multiple geometry options"}),"\n",(0,s.jsx)(n.li,{children:"Align objects precisely with each other"}),"\n",(0,s.jsx)(n.li,{children:"Create perfectly symmetrical bases"}),"\n",(0,s.jsx)(n.li,{children:"Toggle between different placement modes using hotkeys"}),"\n",(0,s.jsx)(n.li,{children:"Customize colors, grid sizes, and visual feedback"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"core-techniques-used",children:"Core Techniques Used"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Placement Prediction Modification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Multiple Geometry Systems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Visual Feedback System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Configuration Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Performance Optimization"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's examine each of these techniques in detail."}),"\n",(0,s.jsx)(n.h2,{id:"1-placement-prediction-modification",children:"1. Placement Prediction Modification"}),"\n",(0,s.jsx)(n.p,{children:"The mod works by intercepting and modifying the game's placement prediction system. When a player is about to place an object, the mod calculates a grid-aligned position and updates the placement visualization."}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Hook into the placement system with more sophisticated geometry handling\nfunction Placer:GetPreciseGridPoint(geometry, spacing, offset_type, pt)\n    local ROW_OFFSET, COL_OFFSET = geometry.row_offset, geometry.col_offset\n    local ORIGIN_OFFSET = ORIGIN_OFFSETS[offset_type]\n    \n    -- Calculate the offset from origin in grid space\n    local offx, offz = 0, 0\n    if geometry == GEOMETRIES.SQUARE then\n        offx = math.floor((pt.x - ORIGIN_OFFSET.x) / spacing + 0.5)\n        offz = math.floor((pt.z - ORIGIN_OFFSET.z) / spacing + 0.5)\n    else\n        -- Handle more complex geometries\n        offx, offz = GetGridOffsetForPoint(geometry, pt, spacing)\n    end\n    \n    -- Transform the grid coordinate back to world space\n    return COL_OFFSET * spacing * offx + ROW_OFFSET * spacing * offz + ORIGIN_OFFSET\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:'The mod uses a technique called "function hooking" to modify the game\'s behavior without changing the original code. This is done by:'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Storing a reference to the original function"}),"\n",(0,s.jsxs)(n.li,{children:["Replacing it with a custom function that:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Calls the original function to get the base result"}),"\n",(0,s.jsx)(n.li,{children:"Applies custom logic to modify the result"}),"\n",(0,s.jsx)(n.li,{children:"Returns the modified result"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach is powerful because it:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Preserves compatibility with other mods"}),"\n",(0,s.jsx)(n.li,{children:"Allows toggling the functionality on/off"}),"\n",(0,s.jsx)(n.li,{children:"Maintains the original behavior when needed"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-multiple-geometry-systems",children:"2. Multiple Geometry Systems"}),"\n",(0,s.jsx)(n.p,{children:"One of the mod's most powerful features is its support for multiple grid geometries, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Square (standard grid)"}),"\n",(0,s.jsx)(n.li,{children:"Diamond (rotated square)"}),"\n",(0,s.jsx)(n.li,{children:"X-Hexagon (hexagons aligned with x-axis)"}),"\n",(0,s.jsx)(n.li,{children:"Z-Hexagon (hexagons aligned with z-axis)"}),"\n",(0,s.jsx)(n.li,{children:"Flat Hexagon (flat-topped hexagons)"}),"\n",(0,s.jsx)(n.li,{children:"Pointy Hexagon (pointy-topped hexagons)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements-1",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Implementation of different geometry systems\nlocal sqrt2_over_2 = math.sqrt(2)*0.5\nlocal sqrt3_over_2 = math.sqrt(3)*0.5\nlocal GEOMETRIES = {\n    SQUARE = {\n        GetRowRange = function(grid_size)\n            return -grid_size, grid_size\n        end,\n        GetColRangeForRow = function(row, grid_size)\n            return -grid_size, grid_size\n        end,\n        HasOverlap = function(dx, dz, grid_size)\n            return not(math.abs(dx) > grid_size*2 or math.abs(dz) > grid_size*2)\n        end,\n        col_offset = Vector3(1, 0, 0),\n        row_offset = Vector3(0, 0, 1),\n        gridplacer_rotation = 0,\n    },\n    X_HEXAGON = {\n        GetRowRange = function(grid_size)\n            return -grid_size, grid_size\n        end,\n        GetColRangeForRow = function(row, grid_size)\n            local is_odd = math.abs(row % 2) > 0\n            local row_start = -grid_size\n            if is_odd then row_start = row_start - 0.5 end\n            return row_start, grid_size + (is_odd and 0.5 or 0)\n        end,\n        HasOverlap = function(dx, dz, grid_size)\n            -- Hexagonal overlap check\n            return not(math.abs(dx) > grid_size*2 or math.abs(dz) > grid_size*2)\n        end,\n        col_offset = Vector3(1, 0, 0),\n        row_offset = Vector3(0.5, 0, sqrt3_over_2),\n        gridplacer_rotation = 0,\n    },\n    -- Additional geometries defined similarly\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-1",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The geometry system demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mathematical precision"}),": Applying geometric transformations to create different grid patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstracted coordinate systems"}),": Converting between lattice space and world space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular design"}),": Each geometry is defined with its own transformation functions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visual differentiation"}),": Different grid patterns provide unique building aesthetics"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-visual-feedback-system",children:"3. Visual Feedback System"}),"\n",(0,s.jsx)(n.p,{children:"To help users understand the grid system, the mod provides visual feedback by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Displaying grid points when placing objects"}),"\n",(0,s.jsx)(n.li,{children:"Highlighting valid/invalid placement positions with configurable colors"}),"\n",(0,s.jsx)(n.li,{children:"Creating visual distinctions between placement types (buildings, walls, farm tiles)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements-2",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'function Placer:BuildGridPoint(bgx, bgz, bgpt, bgp)\n    if bgp == nil then\n        bgp = SpawnPrefab(self.placertype)\n        bgp.Transform:SetRotation(self.geometry.gridplacer_rotation)\n    end\n    self.build_grid[bgx][bgz] = bgp\n    self.build_grid_positions[bgx][bgz] = bgpt\n    bgp.Transform:SetPosition(bgpt:Get())\n    table.insert(self.refresh_queue, {bgx, bgz})\nend\n\nfunction Placer:RefreshGridPoint(bgx, bgz)\n    local row = self.build_grid[bgx]\n    if row == nil then return end\n    local bgp = row[bgz]\n    if bgp == nil then return end\n    local bgpt = self.build_grid_positions[bgx][bgz]\n    local can_build = self:TestPoint(bgp, bgpt)\n    local color = can_build and COLORS.GOOD or COLORS.BAD\n    if self.snap_to_tile then\n        color = can_build and COLORS.GOODTILE or COLORS.BADTILE\n        bgp.AnimState:SetSortOrder(can_build and 1 or 0)\n    end\n    if color == "hidden" then\n        bgp:Hide()\n    else\n        bgp:Show()\n        if color == "on" or color == "off" then\n            bgp.AnimState:PlayAnimation(color, true)\n            bgp.AnimState:SetAddColour(0, 0, 0, 0)\n        else\n            bgp.AnimState:PlayAnimation("anim", true)\n            bgp.AnimState:SetAddColour(color.x, color.y, color.z, 1)\n        end\n    end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-2",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The visual feedback system demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic entity creation"}),": Spawning visual markers as needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient recycling"}),": Reusing existing entities for better performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visual styling"}),": Setting colors and transparency for UI elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup management"}),": Properly removing elements when no longer needed"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-configuration-management",children:"4. Configuration Management"}),"\n",(0,s.jsx)(n.p,{children:"The mod provides extensive customization options through both a configuration menu and in-game toggles."}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements-3",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Excerpt from modinfo.lua showing configuration options\nconfiguration_options = {\n    {\n        name = "CTRL",\n        label = "CTRL Turns Mod",\n        options = {\n            {description = "On", data = true},\n            {description = "Off", data = false},\n        },\n        default = false,\n        hover = "Whether holding CTRL enables or disables the mod.",\n    },\n    {\n        name = "KEYBOARDTOGGLEKEY",\n        label = "Options Button",\n        options = keyslist, -- List of keyboard keys\n        default = "B",\n        hover = "A key to open the mod\'s options. On controllers, open\\nthe scoreboard and then use Menu Misc 3 (left stick click). When set to None, controller is also unbound.",\n    },    \n    {\n        name = "GEOMETRY",\n        label = "Grid Geometry",\n        options = {\n            {description = "Square", data = "SQUARE"},\n            {description = "Diamond", data = "DIAMOND"},\n            {description = "X Hexagon", data = "X_HEXAGON"},\n            {description = "Z Hexagon", data = "Z_HEXAGON"},\n            {description = "Flat Hexagon", data = "FLAT_HEXAGON"},\n            {description = "Pointy Hexagon", data = "POINTY_HEXAGON"},\n        },\n        default = "SQUARE",    \n        hover = "What build grid geometry to use.",\n    },\n    -- Many more options for grid sizes, colors, etc.\n}\n\n-- Loading and applying configuration\nlocal CTRL = GetConfig("CTRL", false, "boolean")\nlocal GEOMETRY_NAME = GetConfig("GEOMETRY", "SQUARE", function(g) return GEOMETRIES[g] ~= nil end)\nlocal SMALLGRIDSIZE = GetConfig("SMALLGRIDSIZE", 10, "number")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-3",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The configuration system shows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User-friendly options"}),": Descriptive labels and helpful hover text"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensible defaults"}),": Pre-configured for immediate usability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type validation"}),": Ensuring configuration values have the correct data type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runtime configuration"}),": Both startup and in-game configuration options"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"5-performance-optimization",children:"5. Performance Optimization"}),"\n",(0,s.jsx)(n.p,{children:"The mod implements several optimizations to ensure it doesn't impact game performance."}),"\n",(0,s.jsx)(n.h3,{id:"key-code-elements-4",children:"Key Code Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"function Placer:RefreshBuildGrid(time_remaining) --if not time_remaining, then config was set to no limit\n    if time_remaining then\n        if time_remaining < 0 then return end --we were over time already (common on generation updates)\n        -- we only have 1ms accuracy, so subtract off a ms\n        time_remaining = time_remaining - 0.001\n    end\n    local refresh_start = os.clock()\n    local refresh_queue_size = #self.refresh_queue\n    for i = 1, refresh_queue_size do\n        if time_remaining and i%20 == 0 then\n            if os.clock() - refresh_start > time_remaining then\n                return\n            end\n        end\n        self:RefreshGridPoint(unpack(table.remove(self.refresh_queue)))\n    end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-analysis-4",children:"Implementation Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The performance optimizations demonstrate:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Time budget system"}),": Limiting processing time to prevent frame rate drops"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incremental updates"}),": Processing grid points in batches"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prioritized visual feedback"}),": Updating the most relevant grid points first"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient calculations"}),": Using optimized math operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory recycling"}),": Reusing existing entities when possible"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,s.jsx)(n.p,{children:"From analyzing the Geometric Placement mod, we can extract several valuable lessons for mod development:"}),"\n",(0,s.jsx)(n.h3,{id:"1-non-invasive-modification",children:"1. Non-Invasive Modification"}),"\n",(0,s.jsx)(n.p,{children:"The mod demonstrates how to modify game behavior without replacing entire systems. By hooking into specific functions, it maintains compatibility with other mods and future game updates."}),"\n",(0,s.jsx)(n.h3,{id:"2-user-experience-focus",children:"2. User Experience Focus"}),"\n",(0,s.jsx)(n.p,{children:"The mod prioritizes user experience through:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clear visual feedback with customizable colors"}),"\n",(0,s.jsx)(n.li,{children:"Multiple grid geometries for different building styles"}),"\n",(0,s.jsx)(n.li,{children:"Intuitive controls with configurable key bindings"}),"\n",(0,s.jsx)(n.li,{children:"Helpful status indicators and toggle options"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-performance-consciousness",children:"3. Performance Consciousness"}),"\n",(0,s.jsx)(n.p,{children:"Despite adding visual elements and calculations, the mod maintains good performance by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Using a time budget system to prevent frame drops"}),"\n",(0,s.jsx)(n.li,{children:"Processing updates incrementally"}),"\n",(0,s.jsx)(n.li,{children:"Recycling grid point entities"}),"\n",(0,s.jsx)(n.li,{children:"Limiting visual updates to what's necessary"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-progressive-enhancement",children:"4. Progressive Enhancement"}),"\n",(0,s.jsx)(n.p,{children:"The mod follows a progressive enhancement approach:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Basic functionality works without configuration"}),"\n",(0,s.jsx)(n.li,{children:"Advanced features are optional"}),"\n",(0,s.jsx)(n.li,{children:"Users can customize the experience to their needs"}),"\n",(0,s.jsx)(n.li,{children:"Default settings provide a good starting point"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementing-similar-features",children:"Implementing Similar Features"}),"\n",(0,s.jsx)(n.p,{children:"If you want to create a mod with similar placement enhancement features, follow these steps:"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-study-the-placement-system",children:"Step 1: Study the Placement System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Understand how the game\'s placement system works\nfunction AnalyzePlacementSystem()\n    -- Find the component responsible for placement\n    local placer_component = GetPlayer().components.placer\n    \n    -- Log its methods and properties\n    for k, v in pairs(placer_component) do\n        print(k, type(v))\n    end\n    \n    -- Monitor placement events\n    GetPlayer():ListenForEvent("onbuildstructure", function(inst, data)\n        print("Structure built:", data.item.prefab)\n        print("Position:", data.pos.x, data.pos.y, data.pos.z)\n    end)\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-a-basic-placement-hook",children:"Step 2: Create a Basic Placement Hook"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Create a simple hook to modify placement\nfunction SetupPlacementHook()\n    local player = GetPlayer()\n    if not player or not player.components.placer then return end\n    \n    -- Store original function\n    local original_fn = player.components.placer.GetPlacementPosition\n    \n    -- Replace with custom function\n    player.components.placer.GetPlacementPosition = function(self)\n        -- Get original position\n        local pos = original_fn(self)\n        \n        -- Apply your modifications\n        -- Example: Round to nearest whole number\n        pos.x = math.floor(pos.x + 0.5)\n        pos.z = math.floor(pos.z + 0.5)\n        \n        return pos\n    end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-add-visual-feedback",children:"Step 3: Add Visual Feedback"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Create visual indicators for placement\nfunction CreatePlacementIndicator(pos, color)\n    local indicator = SpawnPrefab("buildgridplacer")\n    \n    indicator.Transform:SetPosition(pos.x, pos.y, pos.z)\n    if type(color) == "table" then\n        indicator.AnimState:SetAddColour(color.x, color.y, color.z, 1)\n    end\n    \n    -- Ensure proper cleanup\n    indicator:DoTaskInTime(30, function() \n        if indicator:IsValid() then\n            indicator:Remove() \n        end\n    end)\n    \n    return indicator\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-implement-user-controls",children:"Step 4: Implement User Controls"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Set up user controls\nfunction SetupControls()\n    -- Define toggle function\n    local function TogglePlacementMode()\n        GEOMETRY_INDEX = (GEOMETRY_INDEX % #GEOMETRY_OPTIONS) + 1\n        local new_geometry = GEOMETRY_OPTIONS[GEOMETRY_INDEX]\n        SetGeometry(new_geometry)\n        \n        -- Update UI\n        if ANNOUNCE_CHANGES then\n            Announcement("Grid Geometry: " .. new_geometry)\n        end\n    end\n    \n    -- Register key handler\n    TheInput:AddKeyHandler(function(key, down)\n        if key == KEY_G and not down then\n            TogglePlacementMode()\n            return true -- Consume the input\n        end\n        return false\n    end)\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"cross-references-and-related-documentation",children:"Cross-References and Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Learn more about the ",(0,s.jsx)(n.a,{href:"/docs/api-vanilla/components",children:"components system"})," that this mod interacts with"]}),"\n",(0,s.jsxs)(n.li,{children:["Explore ",(0,s.jsx)(n.a,{href:"/docs/api-vanilla/stategraphs",children:"stategraphs"})," for understanding game state handling"]}),"\n",(0,s.jsxs)(n.li,{children:["Check out ",(0,s.jsx)(n.a,{href:"/docs/api-vanilla/prefabs",children:"prefab creation"})," to learn how the grid visuals are implemented"]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/api-vanilla/world",children:"world manipulation"})," documentation for understanding grid placement mechanics"]}),"\n",(0,s.jsxs)(n.li,{children:["Review ",(0,s.jsx)(n.a,{href:"/docs/api-vanilla/core/ui-events",children:"UI events and input handling"})," to learn how to capture and process key presses"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The Geometric Placement mod exemplifies excellent mod design through:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thoughtful integration"})," with the game's existing systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Intuitive user interface"})," that enhances rather than complicates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance-conscious implementation"})," that minimizes impact"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexible configuration"})," that adapts to user preferences"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By studying this mod, we can learn how to create mods that enhance the game experience while maintaining compatibility and performance. These principles apply not just to placement mods, but to any mod that modifies core game systems."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);