"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5256],{3157:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-vanilla/node-types/behavior-tree","title":"Behavior Tree","description":"Last Update: 2023-08-15","source":"@site/docs/api-vanilla/node-types/behavior-tree.md","sourceDirName":"api-vanilla/node-types","slug":"/api-vanilla/node-types/behavior-tree","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/behavior-tree","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"behavior-tree","title":"Behavior Tree","sidebar_position":2,"last_updated":"2023-08-15T00:00:00.000Z","version":624447}}');var i=r(4848),o=r(8453);const s={id:"behavior-tree",title:"Behavior Tree",sidebar_position:2,last_updated:new Date("2023-08-15T00:00:00.000Z"),version:624447},d="Behavior Tree",a={},l=[{value:"Behavior Tree properties and methods",id:"behavior-tree-properties-and-methods",level:2},{value:"Properties",id:"properties",level:2},{value:"inst: Entity <code>[readonly]</code>",id:"inst-entity-readonly",level:3},{value:"root: BehaviorNode <code>[readonly]</code>",id:"root-behaviornode-readonly",level:3},{value:"currentnode: BehaviorNode <code>[readonly]</code>",id:"currentnode-behaviornode-readonly",level:3},{value:"lastresult: &#39;READY&#39; | &#39;RUNNING&#39; | &#39;SUCCESS&#39; | &#39;FAILURE&#39; <code>[readonly]</code>",id:"lastresult-ready--running--success--failure-readonly",level:3},{value:"Methods",id:"methods",level:2},{value:"Update(): &#39;READY&#39; | &#39;RUNNING&#39; | &#39;SUCCESS&#39; | &#39;FAILURE&#39;",id:"update-ready--running--success--failure",level:3},{value:"Reset(): <code>void</code>",id:"reset-void",level:3},{value:"Stop(): <code>void</code>",id:"stop-void",level:3},{value:"GetTreeString(): <code>string</code>",id:"gettreestring-string",level:3},{value:"Behavior Tree Construction",id:"behavior-tree-construction",level:2},{value:"Common Tree Structures",id:"common-tree-structures",level:2},{value:"Basic Priority Structure",id:"basic-priority-structure",level:3},{value:"Sequence with Conditions",id:"sequence-with-conditions",level:3},{value:"Parallel Processing",id:"parallel-processing",level:3},{value:"Integration with Brain",id:"integration-with-brain",level:2},{value:"Debugging Behavior Trees",id:"debugging-behavior-trees",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last Update: 2023-08-15"})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"behavior-tree",children:"Behavior Tree"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"API Version: 624447"})}),"\n",(0,i.jsx)(n.p,{children:"The Behavior Tree (BT) is a core AI decision-making structure in Don't Starve Together that organizes nodes into hierarchical trees. It manages the execution of behavior nodes to determine entity actions based on conditions and priorities."}),"\n",(0,i.jsx)(n.h2,{id:"behavior-tree-properties-and-methods",children:"Behavior Tree properties and methods"}),"\n",(0,i.jsx)(n.p,{children:"Behavior Tree provides the following key properties and methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Properties"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"inst"})," - Reference to the entity this tree controls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"root"})," - Root node of the behavior tree"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"currentnode"})," - The node currently being executed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lastresult"})," - Result of the last tree evaluation"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Update()"})," - Evaluates the behavior tree to determine actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Reset()"})," - Resets the tree to its initial state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Stop()"})," - Stops the tree's execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GetTreeString()"})," - Returns a string representation of the tree structure"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,i.jsxs)(n.h3,{id:"inst-entity-readonly",children:["inst: ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/entity",children:"Entity"})," ",(0,i.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,i.jsx)(n.p,{children:"A reference to the entity that this behavior tree is controlling."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Access the behavior tree's entity\nlocal health = behaviorTree.inst.components.health\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"root-behaviornode-readonly",children:["root: ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/behavior-node",children:"BehaviorNode"})," ",(0,i.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,i.jsx)(n.p,{children:"The root node of the behavior tree. This is typically a PriorityNode or SequenceNode that forms the starting point for evaluating the tree."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Create a behavior tree with a root node\nlocal root = PriorityNode(inst, {\n    FindFoodNode(inst),\n    WanderNode(inst)\n})\nlocal behaviorTree = BehaviorTree(inst, root)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"currentnode-behaviornode-readonly",children:["currentnode: ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/behavior-node",children:"BehaviorNode"})," ",(0,i.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,i.jsx)(n.p,{children:"The node currently being executed in the behavior tree. Updated during tree evaluation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Check which node is currently active\nif behaviorTree.currentnode then\n    print("Currently executing: " .. behaviorTree.currentnode.name)\nend\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"lastresult-ready--running--success--failure-readonly",children:["lastresult: 'READY' | 'RUNNING' | 'SUCCESS' | 'FAILURE' ",(0,i.jsx)(n.code,{children:"[readonly]"})]}),"\n",(0,i.jsx)(n.p,{children:"Result of the last tree evaluation. One of READY, RUNNING, SUCCESS, or FAILURE."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Check the last result of the behavior tree update\nif behaviorTree.lastresult == RUNNING then\n    print("Behavior tree is still running")\nelseif behaviorTree.lastresult == SUCCESS then\n    print("Behavior tree evaluation succeeded")\nelseif behaviorTree.lastresult == FAILURE then\n    print("Behavior tree evaluation failed")\nend\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"update-ready--running--success--failure",children:"Update(): 'READY' | 'RUNNING' | 'SUCCESS' | 'FAILURE'"}),"\n",(0,i.jsx)(n.p,{children:"Evaluates the behavior tree by visiting the root node and progressing through the tree based on node results. This is typically called each frame or on a schedule for AI-controlled entities."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function BehaviorTree:Update()\n    if not self.root then \n        return FAILURE \n    end\n\n    -- If the tree hasn't started yet, start at the root\n    if not self.currentnode then\n        self.root:Start()\n        self.currentnode = self.root\n    end\n\n    -- Visit the current node and get result\n    local result = self.currentnode:Visit()\n    \n    -- If we've reached a terminal state, reset the current node\n    if result ~= RUNNING then\n        self.currentnode = nil\n    end\n    \n    self.lastresult = result\n    return result\nend\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"reset-void",children:["Reset(): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n",(0,i.jsx)(n.p,{children:"Resets the behavior tree to its initial state, clearing the current node and last result."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function BehaviorTree:Reset()\n    if self.root then\n        self.root:Reset()\n    end\n    self.currentnode = nil\n    self.lastresult = nil\nend\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"stop-void",children:["Stop(): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n",(0,i.jsx)(n.p,{children:"Stops the behavior tree's execution, resetting the current node."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"function BehaviorTree:Stop()\n    if self.root then\n        self.root:Stop()\n    end\n    self.currentnode = nil\nend\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"gettreestring-string",children:["GetTreeString(): ",(0,i.jsx)(n.code,{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Returns a string representation of the tree structure, useful for debugging and visualization."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function BehaviorTree:GetTreeString()\n    if not self.root then \n        return "Empty Tree" \n    end\n    \n    return self:FormatNodeString(self.root, 0)\nend\n\nfunction BehaviorTree:FormatNodeString(node, depth)\n    local indent = string.rep("  ", depth)\n    local result = indent .. node.name\n    \n    if node.children then\n        for _, child in ipairs(node.children) do\n            result = result .. "\\n" .. self:FormatNodeString(child, depth + 1)\n        end\n    end\n    \n    return result\nend\n\n-- Usage:\nprint(behaviorTree:GetTreeString())\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"behavior-tree-construction",children:"Behavior Tree Construction"}),"\n",(0,i.jsx)(n.p,{children:"Behavior trees are constructed by composing various node types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local function CreateBehaviorTree(inst)\n    return BehaviorTree(inst, \n        PriorityNode({\n            -- Flee from danger\n            SequenceNode({\n                ConditionNode(function() return IsInDanger(inst) end),\n                RunAwayNode(inst, "danger", 20, 30)\n            }),\n            \n            -- Get food when hungry\n            SequenceNode({\n                ConditionNode(function() return IsHungry(inst) end),\n                FindFoodNode(inst),\n                EatFoodNode(inst)\n            }),\n            \n            -- Default: explore and wander\n            PriorityNode({\n                ExploreNode(inst),\n                WanderNode(inst)\n            })\n        })\n    )\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-tree-structures",children:"Common Tree Structures"}),"\n",(0,i.jsx)(n.p,{children:"Here are some common behavior tree structures used in Don't Starve Together:"}),"\n",(0,i.jsx)(n.h3,{id:"basic-priority-structure",children:"Basic Priority Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"PriorityNode({\n    EmergencyBehaviorNode(inst),    -- Highest priority\n    NeedsBehaviorNode(inst),        -- Medium priority\n    WantsBehaviorNode(inst),        -- Low priority\n    IdleBehaviorNode(inst)          -- Fallback behavior\n})\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sequence-with-conditions",children:"Sequence with Conditions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"SequenceNode({\n    ConditionNode(inst, CheckConditionFunction),\n    ActionNode1(inst),\n    ActionNode2(inst),\n    ActionNode3(inst)\n})\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parallel-processing",children:"Parallel Processing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"ParallelNode({\n    MonitorHealthNode(inst),\n    MonitorHungerNode(inst),\n    MainBehaviorTree(inst)\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-brain",children:"Integration with Brain"}),"\n",(0,i.jsx)(n.p,{children:"Behavior trees are typically used within a Brain component:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'require "behaviortree"\n\nlocal MyBrain = Class(Brain, function(self, inst)\n    Brain._ctor(self, inst)\n    \n    -- Create the behavior tree\n    local root = PriorityNode({\n        CombatBehavior(inst),\n        ForagingBehavior(inst),\n        IdleBehavior(inst)\n    })\n    \n    self.bt = BehaviorTree(inst, root)\nend)\n\nfunction MyBrain:OnStart()\n    -- Initialize brain state\nend\n\nfunction MyBrain:OnUpdate()\n    -- Update the behavior tree\n    if self.bt then\n        self.bt:Update()\n    end\nend\n\nreturn MyBrain\n'})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-behavior-trees",children:"Debugging Behavior Trees"}),"\n",(0,i.jsx)(n.p,{children:"To debug behavior trees:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Print the structure of a behavior tree\nfunction DebugPrintTree(tree)\n    print(tree:GetTreeString())\nend\n\n-- Monitor the active node during execution\nfunction MonitorActiveNode(tree)\n    if tree.currentnode then\n        print("Active node: " .. tree.currentnode.name)\n        print("Status: " .. tree.lastresult)\n    else\n        print("No active node")\n    end\nend\n\n-- Add a debugging decorator to any node\nfunction DebugDecorator(node, name)\n    return DecoratorNode(function(child)\n        local status = child:Visit()\n        print(name .. " returned " .. status)\n        return status\n    end, node)\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tree Depth"}),": Keep behavior trees reasonably shallow to prevent performance issues"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Evaluation Frequency"}),": Consider different update frequencies for different parts of the tree"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Caching"}),": Cache expensive condition checks where appropriate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node Count"}),": Keep the number of nodes manageable for better performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reusable Subtrees"}),": Create reusable behavior subtrees for common behaviors"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/brain",children:"Brain"})," - Brain component that uses behavior trees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/behavior-node",children:"Behavior Node"})," - Base class for all behavior tree nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes",children:"Priority Nodes"})," - Nodes that select between different actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes",children:"Condition Nodes"})," - Nodes that evaluate conditions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes",children:"Sequence Nodes"})," - Nodes that execute actions in sequence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes",children:"Decorator Nodes"})," - Nodes that modify other nodes' behavior"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);