"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[56674],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var s=i(96540);const t={},l=s.createContext(t);function o(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},88586:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"game-scripts/core-systems/system-core/engine/physics","title":"Physics System","description":"Physics collision handling, entity launching, and area destruction utilities for Don\'t Starve Together","source":"@site/docs/game-scripts/core-systems/system-core/engine/physics.md","sourceDirName":"game-scripts/core-systems/system-core/engine","slug":"/game-scripts/core-systems/system-core/engine/physics","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/engine/physics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"physics","title":"Physics System","description":"Physics collision handling, entity launching, and area destruction utilities for Don\'t Starve Together","sidebar_position":3,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Map Utilities","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/engine/maputil"},"next":{"title":"Runtime System Overview","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/system-core/runtime/"}}');var t=i(74848),l=i(28453);const o={id:"physics",title:"Physics System",description:"Physics collision handling, entity launching, and area destruction utilities for Don't Starve Together",sidebar_position:3,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},r="Physics System",a={},c=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Collision System",id:"collision-system",level:2},{value:"OnPhysicsCollision(guid1, guid2, world_position_on_a_x, world_position_on_a_y, world_position_on_a_z, world_position_on_b_x, world_position_on_b_y, world_position_on_b_z, world_normal_on_b_x, world_normal_on_b_y, world_normal_on_b_z, lifetime_in_frames)",id:"on-physics-collision",level:3},{value:"PhysicsCollisionCallbacks",id:"physics-collision-callbacks",level:3},{value:"Collision Mask Management",id:"collision-mask-management",level:2},{value:"CollisionMaskBatcher",id:"collision-mask-batcher",level:3},{value:"Constructor",id:"constructor",level:4},{value:"Methods",id:"methods",level:4},{value:"ClearCollisionMask()",id:"clear-collision-mask",level:5},{value:"SetCollisionMask(...)",id:"set-collision-mask",level:5},{value:"CollidesWith(mask)",id:"collides-with",level:5},{value:"ClearCollidesWith(mask)",id:"clear-collides-with",level:5},{value:"CommitTo(ent)",id:"commit-to",level:5},{value:"Entity Launching Functions",id:"entity-launching-functions",level:2},{value:"Launch(inst, launcher, basespeed)",id:"launch",level:3},{value:"Launch2(inst, launcher, basespeed, speedmult, startheight, startradius, vertical_speed, force_angle)",id:"launch2",level:3},{value:"LaunchAt(inst, launcher, target, speedmult, startheight, startradius, randomangleoffset)",id:"launch-at",level:3},{value:"Area Destruction Functions",id:"area-destruction-functions",level:2},{value:"DestroyEntity(ent, destroyer, kill_all_creatures, remove_entity_as_fallback)",id:"destroy-entity",level:3},{value:"LaunchAndClearArea(inst, radius, launch_basespeed, launch_speedmult, launch_startheight, launch_startradius)",id:"launch-and-clear-area",level:3},{value:"Constants and Tags",id:"constants-and-tags",level:2},{value:"Collision-Related Constants",id:"collision-related-constants",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Complete Physics-Based Game System",id:"complete-physics-based-game-system",level:3},{value:"Related Modules",id:"related-modules",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Security and Safety Notes",id:"security-and-safety-notes",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"physics-system",children:"Physics System"})}),"\n",(0,t.jsx)(n.h2,{id:"version-history",children:"Version History"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Build Version"}),(0,t.jsx)(n.th,{children:"Change Date"}),(0,t.jsx)(n.th,{children:"Change Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"676042"}),(0,t.jsx)(n.td,{children:"2025-06-21"}),(0,t.jsx)(n.td,{children:"stable"}),(0,t.jsx)(n.td,{children:"Current version"})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"physics"})," module provides essential physics-related functionality for Don't Starve Together, including collision detection callbacks, entity launching mechanics, area destruction systems, and collision mask management. This module serves as the bridge between the engine's physics system and Lua gameplay logic, enabling complex interactions between entities and environmental effects."]}),"\n",(0,t.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Register physics collision callback\nPhysicsCollisionCallbacks[entity.GUID] = function(inst, other, ...)\n    print("Collision detected between " .. inst.prefab .. " and " .. other.prefab)\nend\n\n-- Launch entity with basic parameters\nLaunch(projectile, launcher, 10)  -- Launch at speed 10\n\n-- Launch with advanced control\nLaunch2(item, explosion_source, 5, 3, 0.5, 2, 8)  -- Complex launch parameters\n\n-- Create explosion effect with area clearing\nLaunchAndClearArea(bomb, 8, 6, 4, 0.3, 1.5)  -- Radius 8, various launch parameters\n'})}),"\n",(0,t.jsx)(n.h2,{id:"collision-system",children:"Collision System"}),"\n",(0,t.jsx)(n.h3,{id:"on-physics-collision",children:"OnPhysicsCollision(guid1, guid2, world_position_on_a_x, world_position_on_a_y, world_position_on_a_z, world_position_on_b_x, world_position_on_b_y, world_position_on_b_z, world_normal_on_b_x, world_normal_on_b_y, world_normal_on_b_z, lifetime_in_frames)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nEngine callback function that handles physics collisions between entities. Automatically called by the engine when two physics objects collide, dispatching to registered callback functions for each entity involved."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"guid1"})," (number): GUID of first entity in collision"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"guid2"})," (number): GUID of second entity in collision"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"world_position_on_a_x/y/z"})," (number): World position of collision point on entity A"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"world_position_on_b_x/y/z"})," (number): World position of collision point on entity B"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"world_normal_on_b_x/y/z"})," (number): World normal vector on entity B"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"lifetime_in_frames"})," (number): Duration of collision in frames"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns:"}),"\nNone"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Set up collision detection for a projectile\nlocal function SetupProjectileCollision(projectile)\n    PhysicsCollisionCallbacks[projectile.GUID] = function(inst, other, \n        pos_a_x, pos_a_y, pos_a_z, \n        pos_b_x, pos_b_y, pos_b_z, \n        normal_x, normal_y, normal_z, \n        lifetime)\n        \n        print("Projectile hit " .. (other.prefab or "unknown"))\n        \n        -- Calculate impact force based on collision normal\n        local impact_force = math.sqrt(normal_x^2 + normal_y^2 + normal_z^2)\n        \n        -- Apply damage based on impact\n        if other.components.health then\n            other.components.health:DoDelta(-10 * impact_force)\n        end\n        \n        -- Create impact effect at collision point\n        local fx = SpawnPrefab("impact_fx")\n        fx.Transform:SetPosition(pos_a_x, pos_a_y, pos_a_z)\n        \n        -- Remove projectile on impact\n        inst:Remove()\n    end\nend\n\n-- Clean up collision callback when entity is removed\nlocal function CleanupProjectileCollision(projectile)\n    PhysicsCollisionCallbacks[projectile.GUID] = nil\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"physics-collision-callbacks",children:"PhysicsCollisionCallbacks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nGlobal table storing collision callback functions indexed by entity GUID. Register functions here to receive collision notifications for specific entities."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Structure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"PhysicsCollisionCallbacks[entity_guid] = callback_function\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Advanced collision handling system\nlocal CollisionManager = {}\n\nfunction CollisionManager:RegisterEntity(entity, collision_type)\n    local callback_func\n    \n    if collision_type == "bouncy" then\n        callback_func = function(inst, other, ...)\n            -- Bounce off other entities\n            local vel_x, vel_y, vel_z = inst.Physics:GetVel()\n            inst.Physics:SetVel(-vel_x * 0.8, vel_y, -vel_z * 0.8)\n        end\n        \n    elseif collision_type == "sticky" then\n        callback_func = function(inst, other, ...)\n            -- Stick to the first thing we hit\n            inst.Physics:Stop()\n            inst:AddTag("stuck")\n        end\n        \n    elseif collision_type == "explosive" then\n        callback_func = function(inst, other, ...)\n            -- Explode on any collision\n            LaunchAndClearArea(inst, 5, 8, 6, 0.5, 2)\n            inst:Remove()\n        end\n    end\n    \n    PhysicsCollisionCallbacks[entity.GUID] = callback_func\n    \n    -- Cleanup when entity is removed\n    entity:DoTaskInTime(0, function()\n        entity:ListenForEvent("onremove", function()\n            PhysicsCollisionCallbacks[entity.GUID] = nil\n        end)\n    end)\nend\n\n-- Usage examples\nCollisionManager:RegisterEntity(bouncy_ball, "bouncy")\nCollisionManager:RegisterEntity(glue_blob, "sticky")\nCollisionManager:RegisterEntity(bomb, "explosive")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"collision-mask-management",children:"Collision Mask Management"}),"\n",(0,t.jsx)(n.h3,{id:"collision-mask-batcher",children:"CollisionMaskBatcher"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nHelper class for efficiently managing entity collision masks without multiple C++ calls. Allows batching of collision mask operations before committing changes to the Physics component."]}),"\n",(0,t.jsx)(n.h4,{id:"constructor",children:"Constructor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"CollisionMaskBatcher(entormask)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"entormask"})," (Entity|number): Entity to copy mask from, or initial mask value"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h5,{id:"clear-collision-mask",children:"ClearCollisionMask()"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nClears all collision mask bits."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(CollisionMaskBatcher): Self for method chaining"}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"set-collision-mask",children:"SetCollisionMask(...)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nSets collision mask bits using bitwise OR operation."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"..."})," (number): Variable number of collision mask constants"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(CollisionMaskBatcher): Self for method chaining"}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"collides-with",children:"CollidesWith(mask)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nAdds collision mask bits using bitwise OR operation."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mask"})," (number): Collision mask to add"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(CollisionMaskBatcher): Self for method chaining"}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"clear-collides-with",children:"ClearCollidesWith(mask)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nRemoves collision mask bits using bitwise AND NOT operation."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mask"})," (number): Collision mask to remove"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(CollisionMaskBatcher): Self for method chaining"}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"commit-to",children:"CommitTo(ent)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nApplies the batched collision mask changes to the entity's Physics component."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ent"})," (Entity): Entity to apply collision mask to"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Efficient collision mask management for flying creatures\nlocal function SetupFlyingCreature(creature)\n    CollisionMaskBatcher(creature)\n        :ClearCollisionMask()                    -- Start fresh\n        :CollidesWith(COLLISION.GROUND)          -- Collide with ground\n        :CollidesWith(COLLISION.OBSTACLES)       -- Collide with obstacles\n        :ClearCollidesWith(COLLISION.ITEMS)      -- Don\'t collide with items\n        :CollidesWith(COLLISION.FLYERS)          -- Collide with other flyers\n        :CommitTo(creature)                      -- Apply all changes at once\nend\n\n-- Dynamic collision mask switching\nlocal function ToggleGhostMode(entity, is_ghost)\n    local batcher = CollisionMaskBatcher(entity)\n    \n    if is_ghost then\n        batcher:ClearCollidesWith(COLLISION.GROUND)\n               :ClearCollidesWith(COLLISION.OBSTACLES)\n               :CollidesWith(COLLISION.GHOSTS)\n    else\n        batcher:CollidesWith(COLLISION.GROUND)\n               :CollidesWith(COLLISION.OBSTACLES)\n               :ClearCollidesWith(COLLISION.GHOSTS)\n    end\n    \n    batcher:CommitTo(entity)\nend\n\n-- Advanced collision setup for projectiles\nlocal function SetupProjectileCollisions(projectile, projectile_type)\n    local batcher = CollisionMaskBatcher(0)  -- Start with empty mask\n    \n    -- Base collisions for all projectiles\n    batcher:CollidesWith(COLLISION.GROUND)\n           :CollidesWith(COLLISION.OBSTACLES)\n    \n    -- Type-specific collisions\n    if projectile_type == "magic" then\n        batcher:ClearCollidesWith(COLLISION.ITEMS)      -- Pass through items\n               :CollidesWith(COLLISION.CHARACTERS)       -- Hit characters\n    elseif projectile_type == "physical" then\n        batcher:CollidesWith(COLLISION.ITEMS)           -- Interact with items\n               :CollidesWith(COLLISION.CHARACTERS)       -- Hit characters\n    elseif projectile_type == "ghost" then\n        batcher:ClearCollidesWith(COLLISION.GROUND)     -- Pass through ground\n               :CollidesWith(COLLISION.GHOSTS)           -- Only hit ghosts\n    end\n    \n    batcher:CommitTo(projectile)\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"entity-launching-functions",children:"Entity Launching Functions"}),"\n",(0,t.jsx)(n.h3,{id:"launch",children:"Launch(inst, launcher, basespeed)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nLaunches an entity away from a launcher with basic physics parameters. Calculates direction based on relative positions and applies randomized angle variation."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Entity to launch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launcher"})," (Entity): Entity that causes the launch (determines direction)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"basespeed"})," (number, optional): Base launch speed (default: 5)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns:"}),"\nNone"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Basic entity launching\nlocal function ExplodeBarrel(barrel)\n    local x, y, z = barrel.Transform:GetWorldPosition()\n    local nearby_items = TheSim:FindEntities(x, y, z, 3, {"_inventoryitem"})\n    \n    for _, item in ipairs(nearby_items) do\n        if item.Physics and item.Physics:IsActive() then\n            Launch(item, barrel, 8)  -- Launch items at speed 8\n        end\n    end\nend\n\n-- Launch items from chest when destroyed\nlocal function OnChestDestroyed(chest)\n    if chest.components.container then\n        for _, item in pairs(chest.components.container.slots) do\n            if item then\n                item.Transform:SetPosition(chest.Transform:GetWorldPosition())\n                Launch(item, chest, 6)  -- Scatter items\n            end\n        end\n    end\nend\n\n-- Simple knockback effect\nlocal function KnockbackEntity(target, source, force)\n    if target.Physics and target.Physics:IsActive() then\n        Launch(target, source, force or 5)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"launch2",children:"Launch2(inst, launcher, basespeed, speedmult, startheight, startradius, vertical_speed, force_angle)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nAdvanced entity launching with comprehensive control over trajectory, starting position, and velocity components. Provides precise control for complex launching scenarios."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Entity to launch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launcher"})," (Entity): Entity that causes the launch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"basespeed"})," (number): Base horizontal speed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"speedmult"})," (number): Additional random speed multiplier"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"startheight"})," (number): Starting height (Y position)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"startradius"})," (number): Starting distance from launcher"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"vertical_speed"})," (number, optional): Vertical velocity (default: basespeed * 5 + random)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"force_angle"})," (number, optional): Forced launch angle in degrees"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(number): Launch angle in radians"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Advanced explosion system\nlocal function CreateAdvancedExplosion(center, radius, force)\n    local x, y, z = center.Transform:GetWorldPosition()\n    local items = TheSim:FindEntities(x, y, z, radius, {"_inventoryitem"})\n    \n    for _, item in ipairs(items) do\n        if item.Physics and item.Physics:IsActive() then\n            -- Calculate distance-based parameters\n            local distance = center:GetDistanceSqToInst(item)\n            local distance_factor = 1 - (distance / (radius * radius))\n            \n            -- Launch with parameters based on distance\n            local launch_angle = Launch2(\n                item,                           -- item to launch\n                center,                         -- explosion center\n                8 * distance_factor,           -- base speed (closer = faster)\n                4 * distance_factor,           -- speed multiplier\n                0.2,                           -- start slightly above ground\n                1,                             -- start 1 unit from center\n                12 * distance_factor           -- vertical speed\n            )\n            \n            -- Add spin based on launch angle\n            if item.Physics then\n                local spin_speed = 5 * distance_factor\n                item.Physics:SetAngularVel(spin_speed)\n            end\n        end\n    end\nend\n\n-- Catapult system\nlocal function FireCatapult(catapult, projectile, target_pos, power)\n    local angle_to_target = catapult:GetAngleToPoint(target_pos:Get())\n    \n    Launch2(\n        projectile,                    -- projectile to fire\n        catapult,                      -- catapult as launcher\n        power * 0.8,                   -- base speed\n        power * 0.4,                   -- speed variation\n        2,                             -- start high up\n        1.5,                           -- start in front of catapult\n        power * 1.2,                   -- high arc\n        angle_to_target                -- aim at target\n    )\n    \n    -- Track projectile trajectory\n    projectile:DoPeriodicTask(0.1, function()\n        local px, py, pz = projectile.Transform:GetWorldPosition()\n        if py <= 0.1 then  -- Hit ground\n            -- Create impact effect\n            LaunchAndClearArea(projectile, 3, 4, 2, 0.1, 0.5)\n            projectile:Remove()\n        end\n    end)\nend\n\n-- Volcanic eruption effect\nlocal function CreateVolcanicEruption(volcano, intensity)\n    local x, y, z = volcano.Transform:GetWorldPosition()\n    \n    -- Launch multiple projectiles in sequence\n    for i = 1, intensity do\n        volcano:DoTaskInTime(i * 0.2, function()\n            local rock = SpawnPrefab("volcanic_rock")\n            \n            local random_angle = math.random() * 360\n            Launch2(\n                rock,                      -- volcanic rock\n                volcano,                   -- volcano center\n                15,                        -- high speed\n                10,                        -- high variation\n                0,                         -- ground level start\n                math.random() * 3,         -- varying start radius\n                20 + math.random() * 10,   -- very high vertical speed\n                random_angle               -- random direction\n            )\n        end)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"launch-at",children:"LaunchAt(inst, launcher, target, speedmult, startheight, startradius, randomangleoffset)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nLaunches an entity toward a specific target with randomized angle offset. Useful for creating targeted attacks or guided projectiles with some inaccuracy."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Entity to launch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launcher"})," (Entity): Entity that causes the launch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"})," (Entity, optional): Target to aim at (uses camera direction if nil)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"speedmult"})," (number, optional): Speed multiplier (default: 1)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"startheight"})," (number, optional): Starting height (default: 0.1)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"startradius"})," (number, optional): Starting distance from launcher (default: 0)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"randomangleoffset"})," (number, optional): Maximum angle offset in degrees (default: 30)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns:"}),"\nNone"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Targeted magic missile system\nlocal function FireMagicMissile(caster, target, accuracy)\n    local missile = SpawnPrefab("magic_missile")\n    \n    -- Calculate accuracy (lower offset = higher accuracy)\n    local angle_offset = (100 - accuracy) * 0.3  -- 0-30 degrees based on accuracy\n    \n    LaunchAt(\n        missile,        -- magic missile\n        caster,         -- spell caster\n        target,         -- intended target\n        2,              -- medium speed\n        1,              -- start at waist height\n        0.5,            -- slight offset from caster\n        angle_offset    -- accuracy-based spread\n    )\n    \n    -- Add homing behavior after initial launch\n    missile:DoPeriodicTask(0.1, function()\n        if target and target:IsValid() then\n            local missile_pos = missile:GetPosition()\n            local target_pos = target:GetPosition()\n            local direction = (target_pos - missile_pos):Normalize()\n            \n            -- Slight course correction\n            local current_vel = Vector3(missile.Physics:GetVel())\n            local corrected_vel = current_vel + direction * 0.5\n            missile.Physics:SetVel(corrected_vel:Get())\n        end\n    end)\nend\n\n-- Area bombardment system\nlocal function BombardArea(artillery, center_target, num_shells, spread_radius)\n    for i = 1, num_shells do\n        artillery:DoTaskInTime(i * 0.3, function()\n            local shell = SpawnPrefab("artillery_shell")\n            \n            -- Create virtual target around the center\n            local angle = (i / num_shells) * 360 * DEGREES\n            local spread = math.random() * spread_radius\n            local virtual_target = {\n                Transform = {\n                    GetWorldPosition = function()\n                        local cx, cy, cz = center_target.Transform:GetWorldPosition()\n                        return cx + math.cos(angle) * spread, cy, cz + math.sin(angle) * spread\n                    end\n                },\n                GetAngleToPoint = function(_, x, y, z)\n                    local tx, ty, tz = center_target.Transform:GetWorldPosition()\n                    return math.atan2(tz - z, tx - x) * RADIANS\n                end\n            }\n            \n            LaunchAt(\n                shell,           -- artillery shell\n                artillery,       -- artillery piece\n                virtual_target,  -- randomized target\n                3,               -- high speed\n                2,               -- high starting point\n                1,               -- start in front of artillery\n                15               -- moderate spread for area effect\n            )\n        end)\n    end\nend\n\n-- Smart enemy projectile system\nlocal function EnemyRangedAttack(enemy, player_target)\n    local projectile = SpawnPrefab("enemy_projectile")\n    \n    -- Adjust accuracy based on distance and enemy skill\n    local distance = enemy:GetDistanceSqToInst(player_target)\n    local base_accuracy = 20  -- Base spread\n    local distance_penalty = math.sqrt(distance) * 2  -- More spread at distance\n    local final_spread = base_accuracy + distance_penalty\n    \n    LaunchAt(\n        projectile,      -- enemy projectile\n        enemy,           -- attacking enemy\n        player_target,   -- player target\n        1.5,             -- moderate speed\n        0.8,             -- shoulder height\n        0.3,             -- slight forward offset\n        final_spread     -- distance-based accuracy\n    )\n    \n    -- Add projectile tracking\n    projectile.target = player_target\n    projectile:AddTag("enemy_projectile")\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"area-destruction-functions",children:"Area Destruction Functions"}),"\n",(0,t.jsx)(n.h3,{id:"destroy-entity",children:"DestroyEntity(ent, destroyer, kill_all_creatures, remove_entity_as_fallback)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nIntelligently destroys an entity using the most appropriate method based on its components and tags. Handles workable objects, pickable items, creatures, and fallback removal."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ent"})," (Entity): Entity to destroy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"destroyer"})," (Entity): Entity causing the destruction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"kill_all_creatures"})," (boolean): Whether to kill creatures with health"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"remove_entity_as_fallback"})," (boolean): Whether to remove entity if other methods fail"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns:"}),"\nNone"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Special Handling:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Workable entities"}),": Uses workable component destruction (trees, rocks, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pickable entities"}),": Picks items instead of destroying them"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Creatures"}),": Kills entities with health if ",(0,t.jsx)(n.code,{children:"kill_all_creatures"})," is true"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combat entities"}),": Kills stationary combat entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fallback"}),": Removes entity if ",(0,t.jsx)(n.code,{children:"remove_entity_as_fallback"})," is true"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Smart demolition system\nlocal function DemolishArea(center, radius, demolition_type)\n    local x, y, z = center.Transform:GetWorldPosition()\n    local entities = TheSim:FindEntities(x, y, z, radius)\n    \n    for _, entity in ipairs(entities) do\n        if entity:IsValid() and entity ~= center then\n            if demolition_type == "construction" then\n                -- Only destroy workable structures, preserve creatures and items\n                DestroyEntity(entity, center, false, false)\n                \n            elseif demolition_type == "natural_disaster" then\n                -- Destroy everything including creatures\n                DestroyEntity(entity, center, true, true)\n                \n            elseif demolition_type == "harvest" then\n                -- Gentle destruction that preserves items\n                DestroyEntity(entity, center, false, false)\n                \n            elseif demolition_type == "military" then\n                -- Aggressive destruction but don\'t remove non-destroyable entities\n                DestroyEntity(entity, center, true, false)\n            end\n        end\n    end\nend\n\n-- Earthquake effect\nlocal function CreateEarthquake(epicenter, magnitude, duration)\n    local x, y, z = epicenter.Transform:GetWorldPosition()\n    local max_radius = magnitude * 5\n    \n    -- Progressive destruction waves\n    for wave = 1, 5 do\n        epicenter:DoTaskInTime(wave * (duration / 5), function()\n            local wave_radius = (wave / 5) * max_radius\n            local entities = TheSim:FindEntities(x, y, z, wave_radius)\n            \n            for _, entity in ipairs(entities) do\n                if entity:IsValid() then\n                    -- Higher chance of destruction closer to epicenter\n                    local distance = entity:GetDistanceSqToInst(epicenter)\n                    local destruction_chance = 1 - (distance / (max_radius * max_radius))\n                    \n                    if math.random() < destruction_chance then\n                        DestroyEntity(entity, epicenter, false, false)\n                        \n                        -- Add shake effect\n                        if entity.AnimState then\n                            entity.AnimState:SetOffset(\n                                math.random(-0.2, 0.2),\n                                0,\n                                math.random(-0.2, 0.2)\n                            )\n                            \n                            entity:DoTaskInTime(0.5, function()\n                                if entity:IsValid() then\n                                    entity.AnimState:SetOffset(0, 0, 0)\n                                end\n                            end)\n                        end\n                    end\n                end\n            end\n        end)\n    end\nend\n\n-- Controlled demolition for base clearing\nlocal function ControlledDemolition(structures, delay_between)\n    delay_between = delay_between or 0.5\n    \n    for i, structure in ipairs(structures) do\n        structure:DoTaskInTime(i * delay_between, function()\n            if structure:IsValid() then\n                -- Create demolition effect\n                local fx = SpawnPrefab("demolition_fx")\n                fx.Transform:SetPosition(structure.Transform:GetWorldPosition())\n                \n                -- Destroy with force\n                DestroyEntity(structure, structure, false, true)\n                \n                print("Demolished: " .. (structure.prefab or "unknown"))\n            end\n        end)\n    end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"launch-and-clear-area",children:"LaunchAndClearArea(inst, radius, launch_basespeed, launch_speedmult, launch_startheight, launch_startradius)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," ",(0,t.jsx)(n.code,{children:"stable"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"}),"\nComprehensive area effect function that destroys entities and launches items within a radius. Creates realistic explosion or impact effects by combining destruction and physics launching."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"inst"})," (Entity): Central entity causing the effect"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"radius"})," (number): Effect radius"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launch_basespeed"})," (number): Base speed for launched items"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launch_speedmult"})," (number): Speed multiplier for launched items"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launch_startheight"})," (number): Starting height for launched items"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"launch_startradius"})," (number): Starting radius for launched items"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns:"}),"\nNone"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Effect Categories:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Destroys"}),": Workable objects, pickable items, creatures (based on tags)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launches"}),": Inventory items with physics (excludes locomotor entities)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Special"}),": Deactivates mines before launching"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Bomb explosion system\nlocal function CreateBombExplosion(bomb, explosion_power)\n    local base_radius = explosion_power * 2\n    local launch_speed = explosion_power * 1.5\n    \n    -- Create visual explosion effect first\n    local fx = SpawnPrefab("explosion_fx")\n    fx.Transform:SetPosition(bomb.Transform:GetWorldPosition())\n    fx.Transform:SetScale(explosion_power, explosion_power, explosion_power)\n    \n    -- Launch and clear area\n    LaunchAndClearArea(\n        bomb,                    -- explosion center\n        base_radius,             -- destruction radius\n        launch_speed,            -- base launch speed\n        launch_speed * 0.5,      -- speed variation\n        0.5,                     -- items start slightly above ground\n        1                        -- items start 1 unit from center\n    )\n    \n    -- Remove the bomb after explosion\n    bomb:Remove()\nend\n\n-- Meteor impact system\nlocal function MeteorImpact(meteor, impact_force)\n    local x, y, z = meteor.Transform:GetWorldPosition()\n    \n    -- Create crater effect\n    local crater = SpawnPrefab("meteor_crater")\n    crater.Transform:SetPosition(x, y, z)\n    \n    -- Multiple impact waves\n    for wave = 1, 3 do\n        meteor:DoTaskInTime(wave * 0.1, function()\n            LaunchAndClearArea(\n                meteor,                      -- impact center\n                wave * 3,                    -- expanding radius\n                impact_force * (4 - wave),   -- decreasing force\n                impact_force * (4 - wave),   -- decreasing variation\n                wave * 0.2,                  -- increasing height\n                wave                         -- increasing start radius\n            )\n        end)\n    end\n    \n    meteor:Remove()\nend\n\n-- Magical explosion with special effects\nlocal function MagicalExplosion(caster, spell_power, element_type)\n    local explosion_radius = spell_power * 1.5\n    \n    -- Pre-explosion effects\n    local warning_fx = SpawnPrefab("magic_warning")\n    warning_fx.Transform:SetPosition(caster.Transform:GetWorldPosition())\n    \n    caster:DoTaskInTime(1, function()  -- 1 second warning\n        warning_fx:Remove()\n        \n        -- Main explosion\n        LaunchAndClearArea(\n            caster,              -- spell center\n            explosion_radius,    -- magical radius\n            spell_power * 2,     -- magical force\n            spell_power,         -- force variation\n            1,                   -- magical levitation\n            0.5                  -- tight start radius\n        )\n        \n        -- Element-specific aftereffects\n        local x, y, z = caster.Transform:GetWorldPosition()\n        if element_type == "fire" then\n            -- Leave burning patches\n            for i = 1, 5 do\n                local fire = SpawnPrefab("fire_patch")\n                local angle = (i / 5) * 360 * DEGREES\n                local distance = explosion_radius * 0.7\n                fire.Transform:SetPosition(\n                    x + math.cos(angle) * distance,\n                    y,\n                    z + math.sin(angle) * distance\n                )\n            end\n            \n        elseif element_type == "ice" then\n            -- Freeze remaining entities\n            local survivors = TheSim:FindEntities(x, y, z, explosion_radius * 1.2)\n            for _, survivor in ipairs(survivors) do\n                if survivor.components.freezable then\n                    survivor.components.freezable:AddColdness(100)\n                end\n            end\n            \n        elseif element_type == "lightning" then\n            -- Chain lightning to nearby entities\n            local targets = TheSim:FindEntities(x, y, z, explosion_radius * 2)\n            for _, target in ipairs(targets) do\n                if target.components.health then\n                    local lightning = SpawnPrefab("lightning_fx")\n                    lightning.Transform:SetPosition(target.Transform:GetWorldPosition())\n                end\n            end\n        end\n    end)\nend\n\n-- Building collapse system\nlocal function TriggerBuildingCollapse(building, collapse_direction)\n    local x, y, z = building.Transform:GetWorldPosition()\n    \n    -- Gradual collapse with directional bias\n    for stage = 1, 4 do\n        building:DoTaskInTime(stage * 0.3, function()\n            if building:IsValid() then\n                local stage_radius = stage * 2\n                local directional_offset = collapse_direction * stage\n                \n                LaunchAndClearArea(\n                    building,                           -- collapse center\n                    stage_radius,                       -- expanding destruction\n                    5 + stage,                         -- increasing force\n                    3,                                 -- consistent variation\n                    0.1 * stage,                       -- progressive height\n                    1                                  -- consistent start radius\n                )\n                \n                -- Create dust clouds\n                local dust = SpawnPrefab("dust_cloud")\n                dust.Transform:SetPosition(\n                    x + directional_offset.x,\n                    y,\n                    z + directional_offset.z\n                )\n            end\n        end)\n    end\n    \n    -- Final building removal\n    building:DoTaskInTime(1.5, function()\n        if building:IsValid() then\n            building:Remove()\n        end\n    end)\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"constants-and-tags",children:"Constants and Tags"}),"\n",(0,t.jsx)(n.p,{children:"The module references several important constants and tag sets:"}),"\n",(0,t.jsx)(n.h3,{id:"collision-related-constants",children:"Collision-Related Constants"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Used in entity destruction and area clearing\nCOLLAPSIBLE_WORK_ACTIONS = {\n    CHOP = true,      -- Trees and wooden structures\n    DIG = true,       -- Buried or planted items\n    HAMMER = true,    -- Built structures\n    MINE = true,      -- Rocks and mineral deposits\n}\n\nCOLLAPSIBLE_TAGS = { \n    "_combat", "pickable", "NPC_workable",\n    "CHOP_workable", "DIG_workable", \n    "HAMMER_workable", "MINE_workable" \n}\n\nNON_COLLAPSIBLE_TAGS = { \n    "antlion", "groundspike", "flying", "shadow", \n    "ghost", "playerghost", "FX", "NOCLICK", \n    "DECOR", "INLIMBO" \n}\n\nTOSS_MUST_TAGS = { "_inventoryitem" }\nTOSS_CANT_TAGS = { "locomotor", "INLIMBO" }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"complete-physics-based-game-system",children:"Complete Physics-Based Game System"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'-- Advanced physics-based interaction system\nlocal PhysicsGameSystem = {}\n\nfunction PhysicsGameSystem:Initialize()\n    self.active_explosions = {}\n    self.collision_handlers = {}\n    self.launch_effects = {}\nend\n\nfunction PhysicsGameSystem:RegisterExplosive(entity, power, explosion_type)\n    entity.explosion_power = power\n    entity.explosion_type = explosion_type\n    \n    -- Register collision callback for detonation\n    PhysicsCollisionCallbacks[entity.GUID] = function(inst, other, ...)\n        if other.components.health or other:HasTag("structure") then\n            self:TriggerExplosion(inst, inst.explosion_power, inst.explosion_type)\n        end\n    end\nend\n\nfunction PhysicsGameSystem:TriggerExplosion(source, power, explosion_type)\n    local explosion_id = source.GUID .. "_" .. GetTime()\n    self.active_explosions[explosion_id] = true\n    \n    if explosion_type == "fragmentation" then\n        -- Multiple small explosions\n        for i = 1, power do\n            source:DoTaskInTime(i * 0.1, function()\n                LaunchAndClearArea(source, power * 0.5, power * 2, power, 0.3, 0.8)\n            end)\n        end\n        \n    elseif explosion_type == "incendiary" then\n        -- Fire-based explosion\n        LaunchAndClearArea(source, power * 1.5, power, power * 0.5, 0.2, 1)\n        self:CreateFireField(source, power * 2)\n        \n    elseif explosion_type == "concussive" then\n        -- High-force, low-damage explosion\n        LaunchAndClearArea(source, power * 2, power * 3, power * 2, 0.8, 1.5)\n        \n    else\n        -- Standard explosion\n        LaunchAndClearArea(source, power, power * 1.5, power, 0.4, 1)\n    end\n    \n    self.active_explosions[explosion_id] = nil\nend\n\nfunction PhysicsGameSystem:CreateChainReaction(entities, reaction_delay)\n    reaction_delay = reaction_delay or 0.3\n    \n    for i, entity in ipairs(entities) do\n        entity:DoTaskInTime(i * reaction_delay, function()\n            if entity:IsValid() and entity.explosion_power then\n                self:TriggerExplosion(entity, entity.explosion_power, entity.explosion_type)\n            end\n        end)\n    end\nend\n\nreturn PhysicsGameSystem\n'})}),"\n",(0,t.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./constants.md",children:"Collision Constants"}),": COLLISION mask constants used in CollisionMaskBatcher"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./entityscript.md",children:"Entity Script"}),": Base entity functionality for physics entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../components/",children:"Components"}),": Physics-related components like locomotor and health"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./debugtools.md",children:"Debug Tools"}),": Physics debugging and visualization tools"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./map/",children:"World Generation"}),": World physics setup and configuration"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collision Callbacks"}),": Only register callbacks for entities that need them to avoid unnecessary overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collision Mask Batching"}),": Use CollisionMaskBatcher for multiple mask operations to reduce C++ calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Area Effects"}),": Large radius effects can impact performance - use staged execution for major explosions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physics Queries"}),": Entity finding operations in large areas should be used judiciously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleanup"}),": Always remove collision callbacks when entities are destroyed to prevent memory leaks"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"security-and-safety-notes",children:"Security and Safety Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Entity Validation"}),": Always check if entities are valid before performing physics operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Checks"}),": Verify Physics component exists before calling physics methods"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleanup"}),": Properly remove collision callbacks to prevent orphaned references"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Limit simultaneous large-scale physics operations to maintain frame rate"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);