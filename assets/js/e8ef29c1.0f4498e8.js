"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[14310],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var t=i(96540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}},53386:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"game-scripts/core-systems/fundamentals/actions/componentactions","title":"Component Actions","description":"DST component action system for handling interactive behaviors and player actions on entities","source":"@site/docs/game-scripts/core-systems/fundamentals/actions/componentactions.md","sourceDirName":"game-scripts/core-systems/fundamentals/actions","slug":"/game-scripts/core-systems/fundamentals/actions/componentactions","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/componentactions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"componentactions","title":"Component Actions","description":"DST component action system for handling interactive behaviors and player actions on entities","sidebar_position":3,"last_updated":"2025-06-21T00:00:00.000Z","build_version":676042,"change_status":"stable"},"sidebar":"docs","previous":{"title":"Buffered Action System","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/bufferedaction"},"next":{"title":"Equip Slot Utilities","permalink":"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/equipslotutil"}}');var o=i(74848),s=i(28453);const a={id:"componentactions",title:"Component Actions",description:"DST component action system for handling interactive behaviors and player actions on entities",sidebar_position:3,last_updated:new Date("2025-06-21T00:00:00.000Z"),build_version:676042,change_status:"stable"},r="Component Actions",c={},l=[{value:"Version History",id:"version-history",level:2},{value:"Overview",id:"overview",level:2},{value:"Action Types",id:"action-types",level:2},{value:"SCENE Actions",id:"scene-actions",level:3},{value:"USEITEM Actions",id:"useitem-actions",level:3},{value:"POINT Actions",id:"point-actions",level:3},{value:"EQUIPPED Actions",id:"equipped-actions",level:3},{value:"INVENTORY Actions",id:"inventory-actions",level:3},{value:"ISVALID Actions",id:"isvalid-actions",level:3},{value:"Core Functions",id:"core-functions",level:2},{value:"RegisterComponentActions",id:"registercomponentactions",level:3},{value:"UnregisterComponentActions",id:"unregistercomponentactions",level:3},{value:"CollectActions",id:"collectactions",level:3},{value:"IsActionValid",id:"isactionvalid",level:3},{value:"HasActionComponent",id:"hasactioncomponent",level:3},{value:"Helper Functions",id:"helper-functions",level:2},{value:"CanCastFishingNetAtPoint",id:"cancastfishingnetatpoint",level:3},{value:"GetFishingAction",id:"getfishingaction",level:3},{value:"Row",id:"row",level:3},{value:"CheckRowOverride",id:"checkrowoverride",level:3},{value:"PlantRegistryResearch",id:"plantregistryresearch",level:3},{value:"Mod Support",id:"mod-support",level:2},{value:"AddComponentAction",id:"addcomponentaction",level:3},{value:"Network Optimization",id:"network-optimization",level:2},{value:"Component ID Mapping",id:"component-id-mapping",level:3},{value:"System Constants",id:"system-constants",level:2},{value:"Action Type Categories",id:"action-type-categories",level:3},{value:"Special Tag Sets",id:"special-tag-sets",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Tag-Based Action Filtering",id:"tag-based-action-filtering",level:3},{value:"Conditional Action Validation",id:"conditional-action-validation",level:3},{value:"Right-Click Specificity",id:"right-click-specificity",level:3},{value:"Mount and Riding Restrictions",id:"mount-and-riding-restrictions",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Mod Component Validation",id:"mod-component-validation",level:3},{value:"Action Type Validation",id:"action-type-validation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Efficient Component Lookup",id:"efficient-component-lookup",level:3},{value:"Memory Optimization",id:"memory-optimization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\ud83d\udfe2 Do&#39;s",id:"-dos",level:3},{value:"\u274c Don&#39;ts",id:"-donts",level:3},{value:"Related Systems",id:"related-systems",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"component-actions",children:"Component Actions"})}),"\n",(0,o.jsx)(e.h2,{id:"version-history",children:"Version History"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Build Version"}),(0,o.jsx)(e.th,{children:"Change Date"}),(0,o.jsx)(e.th,{children:"Change Type"}),(0,o.jsx)(e.th,{children:"Description"})]})}),(0,o.jsx)(e.tbody,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"676042"}),(0,o.jsx)(e.td,{children:"2025-06-21"}),(0,o.jsx)(e.td,{children:"stable"}),(0,o.jsx)(e.td,{children:"Current version"})]})})]}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.strong,{children:"Component Actions"})," system is the core mechanism in Don't Starve Together that defines how players can interact with entities through various components. It provides a structured way to register, manage, and execute actions based on component presence and game context."]}),"\n",(0,o.jsxs)(e.p,{children:["The system categorizes actions into different types based on the interaction method and context, providing flexibility for complex interactive behaviors. All component actions are stored in the ",(0,o.jsx)(e.code,{children:"COMPONENT_ACTIONS"})," table and are organized by action type, with each component having specific action collectors that determine available interactions."]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Core Features:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Automatic action discovery based on entity components"}),"\n",(0,o.jsx)(e.li,{children:"Context-sensitive interactions (left/right click, mounted/dismounted)"}),"\n",(0,o.jsx)(e.li,{children:"Mod support for custom component actions"}),"\n",(0,o.jsx)(e.li,{children:"Network-optimized component registration system"}),"\n",(0,o.jsx)(e.li,{children:"Validation framework for action availability"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"action-types",children:"Action Types"}),"\n",(0,o.jsx)(e.h3,{id:"scene-actions",children:"SCENE Actions"}),"\n",(0,o.jsx)(e.p,{children:"Direct interactions with objects in the world without using items."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, doer, actions, right)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"inst"}),": The entity being interacted with"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player performing the action"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"actions"}),": Array to insert available actions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"right"}),": Boolean indicating right-click interaction"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'activatable = function(inst, doer, actions, right)\n    if inst:HasTag("inactive") then\n        --portableengineer needs r.click for dismantle\n        if right and inst:HasTag("engineering") and doer:HasTag("portableengineer") then\n            return\n        elseif not right and (inst.replica.inventoryitem or inst:HasTag("activatable_forceright")) then\n            --no l.click for inventoryitem or forceright\n            return\n        end\n        if not (inst:HasTag("smolder") or inst:HasTag("fire")) then\n            table.insert(actions, ACTIONS.ACTIVATE)\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Common SCENE Actions:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"activatable"}),": Activate/turn on inactive objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"container"}),": Open containers and storage"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"pickable"}),": Harvest plants and collectibles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"workable"}),": Work objects with tools (chopping, mining, etc.)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"burnable"}),": Smother fires or stoke fires"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"sleepingbag"}),": Sleep in beds and sleeping bags"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"useitem-actions",children:"USEITEM Actions"}),"\n",(0,o.jsx)(e.p,{children:"Using an inventory item on a target entity."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, doer, target, actions, right)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"inst"}),": The item being used"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player using the item"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"target"}),": The entity being targeted"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"actions"}),": Array to insert available actions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"right"}),": Boolean indicating right-click interaction"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'fuel = function(inst, doer, target, actions)\n    if not (doer.replica.rider ~= nil and doer.replica.rider:IsRiding())\n        or (target.replica.inventoryitem ~= nil and target.replica.inventoryitem:IsGrandOwner(doer)) then\n        if inst.prefab ~= "spoiled_food" and\n            inst:HasTag("quagmire_stewable") and\n            target:HasTag("quagmire_stewer") and\n            target.replica.container ~= nil and\n            target.replica.container:IsOpenedBy(doer) then\n            return\n        end\n        for k, v in pairs(FUELTYPE) do\n            if inst:HasTag(v.."_fuel") then\n                if target:HasTag(v.."_fueled") then\n                    table.insert(actions, inst:GetIsWet() and ACTIONS.ADDWETFUEL or ACTIONS.ADDFUEL)\n                end\n                return\n            end\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Common USEITEM Actions:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"fuel"}),": Add fuel to burnable objects (campfires, lanterns)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"tool"}),": Use tools on workable objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"edible"}),": Feed food to creatures or players"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"weapon"}),": Attack targets or store weapons in containers"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"repairer"}),": Repair damaged items with appropriate materials"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"tradable"}),": Trade items with NPCs"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"point-actions",children:"POINT Actions"}),"\n",(0,o.jsx)(e.p,{children:"Using items on specific world positions."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, doer, pos, actions, right, target)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"inst"}),": The item being used"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player using the item"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"pos"}),": World position Vector3"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"actions"}),": Array to insert available actions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"right"}),": Boolean indicating right-click interaction"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"target"}),": Optional target entity at position"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'deployable = function(inst, doer, pos, actions, right, target)\n    if right and inst.replica.inventoryitem ~= nil then\n        if CLIENT_REQUESTED_ACTION == ACTIONS.DEPLOY_TILEARRIVE or CLIENT_REQUESTED_ACTION == ACTIONS.DEPLOY then\n            table.insert(actions, CLIENT_REQUESTED_ACTION)\n        elseif inst.replica.inventoryitem:CanDeploy(pos, nil, doer, rotation) then\n            if inst:HasTag("tile_deploy") then\n                table.insert(actions, ACTIONS.DEPLOY_TILEARRIVE)\n            elseif not (inst.CanTossInWorld and inst:HasTag("projectile") and not inst:CanTossInWorld(doer, pos)) then\n                table.insert(actions, ACTIONS.DEPLOY)\n            end\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"equipped-actions",children:"EQUIPPED Actions"}),"\n",(0,o.jsx)(e.p,{children:"Actions available when an item is equipped."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, doer, target, actions, right)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'tool = function(inst, doer, target, actions, right)\n    if not target:HasTag("INLIMBO") then\n        for k in pairs(TOOLACTIONS) do\n            if inst:HasTag(k.."_tool")\n                    and target:IsActionValid(ACTIONS[k], right)\n                    and (not right or ACTIONS[k].rmb or not target:HasTag("smolder")) then\n                table.insert(actions, ACTIONS[k])\n                return\n            end\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inventory-actions",children:"INVENTORY Actions"}),"\n",(0,o.jsx)(e.p,{children:"Actions available for items in inventory."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, doer, actions, right)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'edible = function(inst, doer, actions, right)\n    local rider = doer.replica.rider\n    local mount = rider and rider:GetMount() or nil\n    local isactiveitem = doer.replica.inventory:GetActiveItem() == inst\n\n    if mount and (isactiveitem or (not right and doer.components.playercontroller.isclientcontrollerattached)) then\n        -- Feed mount logic\n        for k, v in pairs(FOODGROUP) do\n            if mount:HasTag(v.name.."_eater") then\n                for i, v2 in ipairs(v.types) do\n                    if inst:HasTag("edible_"..v2) then\n                        table.insert(actions, ACTIONS.FEED)\n                        return\n                    end\n                end\n            end\n        end\n    end\n\n    if (right or inst.replica.equippable == nil) and not (mount and isactiveitem) then\n        for k, v in pairs(FOODTYPE) do\n            if inst:HasTag("edible_"..v) and doer:HasTag(v.."_eater") then\n                table.insert(actions, ACTIONS.EAT)\n                return\n            end\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"isvalid-actions",children:"ISVALID Actions"}),"\n",(0,o.jsx)(e.p,{children:"Validation functions for determining if an action is valid."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Function Signature:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function(inst, action, right)\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example Implementation:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'workable = function(inst, action, right)\n    return (right or action ~= ACTIONS.HAMMER) and\n        inst:HasTag(action.id.."_workable")\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,o.jsx)(e.h3,{id:"registercomponentactions",children:"RegisterComponentActions"}),"\n",(0,o.jsx)(e.p,{children:"Registers a component to participate in the action system."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function EntityScript:RegisterComponentActions(name)\n    local id = ACTION_COMPONENT_IDS[name]\n    if id ~= nil then\n        table.insert(self.actioncomponents, id)\n        if self.actionreplica ~= nil then\n            self.actionreplica.actioncomponents:set(self.actioncomponents)\n        end\n    end\n    -- Handle mod component actions...\nend\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Usage Example:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In component constructor\nlocal function OnCreate(inst)\n    inst:RegisterComponentActions("workable")\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"unregistercomponentactions",children:"UnregisterComponentActions"}),"\n",(0,o.jsx)(e.p,{children:"Removes a component from the action system."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function EntityScript:UnregisterComponentActions(name)\n    local id = ACTION_COMPONENT_IDS[name]\n    if id ~= nil then\n        for i, v in ipairs(self.actioncomponents) do\n            if v == id then\n                table.remove(self.actioncomponents, i)\n                if self.actionreplica ~= nil then\n                    self.actionreplica.actioncomponents:set(self.actioncomponents)\n                end\n                break\n            end\n        end\n    end\n    -- Handle mod component actions...\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"collectactions",children:"CollectActions"}),"\n",(0,o.jsx)(e.p,{children:"Gathers all available actions for an entity based on its registered components."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function EntityScript:CollectActions(actiontype, ...)\n    local t = COMPONENT_ACTIONS[actiontype]\n    if t == nil then\n        print("Action type", actiontype, "doesn\'t exist in the table of component actions.")\n        return\n    end\n    for i, v in ipairs(self.actioncomponents) do\n        local collector = t[ACTION_COMPONENT_NAMES[v]]\n        if collector ~= nil then\n            collector(self, ...)\n        end\n    end\n    -- Handle mod component actions...\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"isactionvalid",children:"IsActionValid"}),"\n",(0,o.jsx)(e.p,{children:"Validates whether a specific action is valid for an entity."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function EntityScript:IsActionValid(action, right)\n    if action.rmb and action.rmb ~= right then\n        return false\n    end\n    local isvalid_list = COMPONENT_ACTIONS.ISVALID\n    for _, v in ipairs(self.actioncomponents) do\n        local validator = isvalid_list[ACTION_COMPONENT_NAMES[v]]\n        if validator ~= nil and validator(self, action, right) then\n            return true\n        end\n    end\n    -- Handle mod validators...\n    return false\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"hasactioncomponent",children:"HasActionComponent"}),"\n",(0,o.jsx)(e.p,{children:"Checks if an entity has a specific action component registered."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function EntityScript:HasActionComponent(name)\n    local id = ACTION_COMPONENT_IDS[name]\n    if id ~= nil then\n        for i, v in ipairs(self.actioncomponents) do\n            if v == id then\n                return true\n            end\n        end\n    end\n    -- Handle mod components...\n    return false\nend\n"})}),"\n",(0,o.jsx)(e.h2,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,o.jsx)(e.h3,{id:"cancastfishingnetatpoint",children:"CanCastFishingNetAtPoint"}),"\n",(0,o.jsx)(e.p,{children:"Validates if a fishing net can be cast at a specific location."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"thrower"}),": The entity throwing the net"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"target_x"}),": Target X coordinate"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"target_z"}),": Target Z coordinate"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Returns:"})," Boolean indicating if the cast is valid"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"local function CanCastFishingNetAtPoint(thrower, target_x, target_z)\n    local min_throw_distance = 2\n    local thrower_x, thrower_y, thrower_z = thrower.Transform:GetWorldPosition()\n\n    local isoceanactionable = TheWorld.Map:IsOceanAtPoint(target_x, 0, target_z) or \n                             FindVirtualOceanEntity(target_x, 0, target_z) ~= nil\n    if isoceanactionable and VecUtil_LengthSq(target_x - thrower_x, target_z - thrower_z) > \n       min_throw_distance * min_throw_distance then\n        return true\n    end\n    return false\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"getfishingaction",children:"GetFishingAction"}),"\n",(0,o.jsx)(e.p,{children:"Determines the appropriate fishing action based on current state."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player performing the fishing action"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"fishing_target"}),": The target entity for fishing"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Returns:"})," The appropriate ACTIONS constant or nil"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local function GetFishingAction(doer, fishing_target)\n    if doer:HasTag("fishing_idle") then\n        if fishing_target ~= nil and not fishing_target:HasTag("projectile") then\n            if fishing_target:HasTag("oceanfishing_catchable") then\n                if fishing_target:HasTag("fishinghook") then\n                    return ACTIONS.OCEAN_FISHING_STOP\n                else\n                    return ACTIONS.OCEAN_FISHING_CATCH\n                end\n            end\n            return ACTIONS.OCEAN_FISHING_REEL\n        end\n    end\n    return nil\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"row",children:"Row"}),"\n",(0,o.jsx)(e.p,{children:"Handles boat rowing actions and movement on water."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"inst"}),": The oar item being used"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player using the oar"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"pos"}),": Target position for rowing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"actions"}),": Array to insert available actions"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"local function Row(inst, doer, pos, actions)\n    local map = TheWorld.Map\n    local platform_under_cursor = map:GetPlatformAtPoint(pos.x, pos.z)\n    local doer_x, doer_y, doer_z = doer.Transform:GetWorldPosition()\n    local my_platform = doer:GetCurrentPlatform()\n    local is_controller_attached = doer.components.playercontroller.isclientcontrollerattached\n\n    -- Determines appropriate rowing action based on platform, position, and player state\n    -- Handles both keyboard/mouse and controller input differently\n    -- Returns ROW, ROW_CONTROLLER, or ROW_FAIL actions\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"checkrowoverride",children:"CheckRowOverride"}),"\n",(0,o.jsx)(e.p,{children:"Checks if an object overrides the rowing action (like ocean trawler)."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player attempting to row"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"target"}),": The target entity that might override rowing"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Returns:"})," Boolean indicating if rowing should be overridden"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local function CheckRowOverride(doer, target)\n    if target ~= nil then\n        local doer_pos = doer:GetPosition()\n        local boat = TheWorld.Map:GetPlatformAtPoint(doer_pos.x, doer_pos.z)\n        if boat == nil then\n            return false\n        end\n\n        local target_pos = target:GetPosition()\n        local dist_to_target = VecUtil_Dist(target_pos.x, target_pos.z, doer_pos.x, doer_pos.z)\n        local boat_pos = boat:GetPosition()\n        local dist_to_boat = VecUtil_Dist(target_pos.x, target_pos.z, boat_pos.x, boat_pos.z)\n        local boatradius = boat.components.boatringdata and boat.components.boatringdata:GetRadius() or 0\n        local boat_dist_to_target = dist_to_boat - boatradius\n\n        if target:HasTag("overriderowaction") and math.min(dist_to_target, boat_dist_to_target) < TUNING.OVERRIDE_ROW_ACTION_DISTANCE then\n            return true\n        end\n    end\n    return false\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"plantregistryresearch",children:"PlantRegistryResearch"}),"\n",(0,o.jsx)(e.p,{children:"Handles plant registry research actions for botanical inspection."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"inst"}),": The plant or fertilizer being researched"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"doer"}),": The player performing the research"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"actions"}),": Array to insert available actions"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local function PlantRegistryResearch(inst, doer, actions)\n    if inst ~= doer and (doer.CanExamine == nil or doer:CanExamine()) then\n        local plantinspector = doer.replica.inventory and \n                              doer.replica.inventory:EquipHasTag("plantinspector") or false\n        local plantkin = doer:HasTag("plantkin")\n\n        if plantinspector and ((inst.GetPlantRegistryKey and inst.GetResearchStage) or \n                              inst.GetFertilizerKey) then\n            local act = CLIENT_REQUESTED_ACTION\n            if (not TheNet:IsDedicated() and doer == ThePlayer) then\n                if (inst:HasTag("plantresearchable") and \n                    not ThePlantRegistry:KnowsPlantStage(inst:GetPlantRegistryKey(), inst:GetResearchStage())) or\n                   (inst:HasTag("fertilizerresearchable") and \n                    not ThePlantRegistry:KnowsFertilizer(inst:GetFertilizerKey())) then\n                    act = ACTIONS.PLANTREGISTRY_RESEARCH\n                else\n                    act = ACTIONS.PLANTREGISTRY_RESEARCH_FAIL\n                end\n            end\n            if act == ACTIONS.PLANTREGISTRY_RESEARCH or act == ACTIONS.PLANTREGISTRY_RESEARCH_FAIL then\n                table.insert(actions, act)\n            end\n        end\n\n        if (plantinspector or plantkin) and \n           (inst:HasTag("farmplantstress") or inst:HasTag("weedplantstress")) then\n            table.insert(actions, ACTIONS.ASSESSPLANTHAPPINESS)\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"mod-support",children:"Mod Support"}),"\n",(0,o.jsx)(e.h3,{id:"addcomponentaction",children:"AddComponentAction"}),"\n",(0,o.jsx)(e.p,{children:"Allows mods to register custom component actions."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"function AddComponentAction(actiontype, component, fn, modname)\n    if MOD_COMPONENT_ACTIONS[modname] == nil then\n        MOD_COMPONENT_ACTIONS[modname] = { [actiontype] = {} }\n        MOD_ACTION_COMPONENT_NAMES[modname] = {}\n        MOD_ACTION_COMPONENT_IDS[modname] = {}\n    elseif MOD_COMPONENT_ACTIONS[modname][actiontype] == nil then\n        MOD_COMPONENT_ACTIONS[modname][actiontype] = {}\n    end\n    MOD_COMPONENT_ACTIONS[modname][actiontype][component] = fn\n    table.insert(MOD_ACTION_COMPONENT_NAMES[modname], component)\n    MOD_ACTION_COMPONENT_IDS[modname][component] = #MOD_ACTION_COMPONENT_NAMES[modname]\nend\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Usage Example:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- In mod code\nAddComponentAction("SCENE", "mycomponent", function(inst, doer, actions, right)\n    if inst:HasTag("my_tag") and not inst:HasTag("fire") then\n        table.insert(actions, ACTIONS.MY_ACTION)\n    end\nend, "MyModName")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"network-optimization",children:"Network Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"component-id-mapping",children:"Component ID Mapping"}),"\n",(0,o.jsx)(e.p,{children:"The system uses numeric IDs for efficient component lookup and network synchronization:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local ACTION_COMPONENT_NAMES = {}\nlocal ACTION_COMPONENT_IDS = {}\n\nlocal function RemapComponentActions()\n    for k, v in orderedPairs(COMPONENT_ACTIONS) do\n        for cmp, fn in orderedPairs(v) do\n            if ACTION_COMPONENT_IDS[cmp] == nil then\n                table.insert(ACTION_COMPONENT_NAMES, cmp)\n                ACTION_COMPONENT_IDS[cmp] = #ACTION_COMPONENT_NAMES\n            end\n        end\n    end\nend\nRemapComponentActions()\nassert(#ACTION_COMPONENT_NAMES <= 255, "Increase actioncomponents network data size.")\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Network Constraints:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Maximum 255 component types for network efficiency"}),"\n",(0,o.jsx)(e.li,{children:"Uses 8-bit integers for component ID transmission"}),"\n",(0,o.jsx)(e.li,{children:"Component names stored once in lookup tables for memory optimization"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Network Synchronization:"}),"\nComponent registration is replicated efficiently using numeric arrays to minimize bandwidth usage."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"-- Client-server synchronization\nif self.actionreplica ~= nil then\n    self.actionreplica.actioncomponents:set(self.actioncomponents)\nend\n\n-- Mod component synchronization\nif self.actionreplica ~= nil then\n    self.actionreplica.modactioncomponents[modname]:set(self.modactioncomponents[modname])\nend\n"})}),"\n",(0,o.jsx)(e.h2,{id:"system-constants",children:"System Constants"}),"\n",(0,o.jsx)(e.h3,{id:"action-type-categories",children:"Action Type Categories"}),"\n",(0,o.jsx)(e.p,{children:"The system defines several action type constants:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'-- Action categories used in COMPONENT_ACTIONS table\nSCENE = "using an object in the world"\nUSEITEM = "using an inventory item on an object in the world"  \nPOINT = "using an inventory item on a point in the world"\nEQUIPPED = "using an equipped item on yourself or a target object"\nINVENTORY = "using an inventory item"\nISVALID = "validation functions for action availability"\n'})}),"\n",(0,o.jsx)(e.h3,{id:"special-tag-sets",children:"Special Tag Sets"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local SCYTHE_ONEOFTAGS = {"plant", "lichen", "oceanvine", "kelp"}\nlocal KITCOON_MUST_TAGS = {"kitcoonden"}\n\nlocal function IsValidScytheTarget(target)\n    return target:HasOneOfTags(SCYTHE_ONEOFTAGS)\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"tag-based-action-filtering",children:"Tag-Based Action Filtering"}),"\n",(0,o.jsx)(e.p,{children:"Most component actions use entity tags to determine availability:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'pickable = function(inst, doer, actions)\n    if inst:HasTag("pickable") and not (inst:HasTag("fire") or inst:HasTag("intense")) then\n        table.insert(actions, ACTIONS.PICK)\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"conditional-action-validation",children:"Conditional Action Validation"}),"\n",(0,o.jsx)(e.p,{children:"Actions often include multiple condition checks:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'container = function(inst, doer, actions, right)\n    if not inst:HasTag("burnt") and\n        inst.replica.container:CanBeOpened() and\n        doer.replica.inventory ~= nil and\n        not (doer.replica.rider ~= nil and doer.replica.rider:IsRiding()) then\n        table.insert(actions, ACTIONS.RUMMAGE)\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h3,{id:"right-click-specificity",children:"Right-Click Specificity"}),"\n",(0,o.jsx)(e.p,{children:"Some actions are only available on right-click:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"portablestructure = function(inst, doer, actions, right)\n    if not right then\n        return\n    end\n    -- Right-click specific logic for dismantling...\n    if not inst.candismantle or inst.candismantle(inst) then\n        table.insert(actions, ACTIONS.DISMANTLE)\n    end\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"mount-and-riding-restrictions",children:"Mount and Riding Restrictions"}),"\n",(0,o.jsx)(e.p,{children:"Actions must consider player riding state:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'stewer = function(inst, doer, actions, right)\n    if not inst:HasTag("burnt") and\n        not (doer.replica.rider ~= nil and doer.replica.rider:IsRiding()) then\n        if inst:HasTag("donecooking") then\n            table.insert(actions, ACTIONS.HARVEST)\n        elseif right and inst:HasTag("readytocook") then\n            table.insert(actions, ACTIONS.COOK)\n        end\n    end\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(e.h3,{id:"mod-component-validation",children:"Mod Component Validation"}),"\n",(0,o.jsx)(e.p,{children:"The system includes warnings for mod synchronization issues:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'local function ModComponentWarning(self, modname)\n    print("ERROR: Mod component actions are out of sync for mod "..(modname or "unknown")..\n          ". This is likely a result of your mod\'s calls to AddComponentAction not happening on both the server and the client.")\n    print("self.modactioncomponents is\\n"..(dumptable(self.modactioncomponents) or ""))\n    print("MOD_COMPONENT_ACTIONS is\\n"..(dumptable(MOD_COMPONENT_ACTIONS) or ""))\nend\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Error Context Functions:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:"local function CheckModComponentActions(self, modname)\n    return MOD_COMPONENT_ACTIONS[modname] or ModComponentWarning(self, modname)\nend\n\nlocal function CheckModComponentNames(self, modname)\n    return MOD_ACTION_COMPONENT_NAMES[modname] or ModComponentWarning(self, modname)\nend\n\nlocal function CheckModComponentIds(self, modname)\n    return MOD_ACTION_COMPONENT_IDS[modname] or ModComponentWarning(self, modname)\nend\n"})}),"\n",(0,o.jsx)(e.h3,{id:"action-type-validation",children:"Action Type Validation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-lua",children:'function EntityScript:CollectActions(actiontype, ...)\n    local t = COMPONENT_ACTIONS[actiontype]\n    if t == nil then\n        print("Action type", actiontype, "doesn\'t exist in the table of component actions. Is your component name correct in AddComponentAction?")\n        return\n    end\n    -- Continue processing...\nend\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"efficient-component-lookup",children:"Efficient Component Lookup"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Uses numeric component IDs for fast array indexing"}),"\n",(0,o.jsx)(e.li,{children:"Limits component actions to 255 total types for network efficiency"}),"\n",(0,o.jsx)(e.li,{children:"Batch processes mod component actions to reduce overhead"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"memory-optimization",children:"Memory Optimization"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Component names are stored once in lookup tables"}),"\n",(0,o.jsx)(e.li,{children:"Action functions are shared across all entities with the same component"}),"\n",(0,o.jsx)(e.li,{children:"Network data uses compact numeric representations"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"-dos",children:"\ud83d\udfe2 Do's"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Use specific tags to control action availability"}),"\n",(0,o.jsx)(e.li,{children:"Include proper validation checks (burned, broken, etc.)"}),"\n",(0,o.jsx)(e.li,{children:"Consider both left and right-click contexts"}),"\n",(0,o.jsx)(e.li,{children:"Handle mounted player restrictions appropriately"}),"\n",(0,o.jsx)(e.li,{children:"Check component existence before accessing properties"}),"\n",(0,o.jsx)(e.li,{children:"Validate network state consistency between client and server"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"-donts",children:"\u274c Don'ts"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Don't forget to handle edge cases like burning/broken entities"}),"\n",(0,o.jsxs)(e.li,{children:["Don't ignore the ",(0,o.jsx)(e.code,{children:"right"})," parameter for click-specific actions"]}),"\n",(0,o.jsx)(e.li,{children:"Don't add actions without proper state validation"}),"\n",(0,o.jsx)(e.li,{children:"Don't assume components exist without checking"}),"\n",(0,o.jsx)(e.li,{children:"Don't create actions that work only on client or server"}),"\n",(0,o.jsx)(e.li,{children:"Don't register component actions inconsistently across game states"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"related-systems",children:"Related Systems"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/",children:"Actions"})}),": Core action definitions and execution"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/bufferedaction",children:"BufferedAction"})}),": Action queuing and execution system"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"./entityscript.md",children:"EntityScript"})}),": Core entity functionality"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"./networking.md",children:"Networking"})}),": Client-server action synchronization"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsxs)(e.em,{children:["For implementation examples of specific component actions, see the individual component documentation. For action execution details, refer to the ",(0,o.jsx)(e.a,{href:"/dst-api-webdocs/docs/game-scripts/core-systems/fundamentals/actions/",children:"Actions documentation"}),"."]})})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);