"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[9308],{5744:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-vanilla/node-types/decorator-nodes","title":"Decorator Nodes","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/node-types/decorator-nodes.md","sourceDirName":"api-vanilla/node-types","slug":"/api-vanilla/node-types/decorator-nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/decorator-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"decorator-nodes","title":"Decorator Nodes","sidebar_position":4,"last_updated":"2023-07-06T00:00:00.000Z","version":619045},"sidebar":"docs","previous":{"title":"Condition Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes"},"next":{"title":"Priority Nodes","permalink":"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes"}}');var o=t(4848),i=t(8453);const r={id:"decorator-nodes",title:"Decorator Nodes",sidebar_position:4,last_updated:new Date("2023-07-06T00:00:00.000Z"),version:619045},a="Decorator Nodes",l={},c=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Decorator Node States",id:"decorator-node-states",level:2},{value:"Built-in Decorator Nodes",id:"built-in-decorator-nodes",level:2},{value:"NotDecorator",id:"notdecorator",level:3},{value:"FailIfRunningDecorator",id:"failifrunningdecorator",level:3},{value:"LoopNode",id:"loopnode",level:3},{value:"SuccessIfRunningDecorator",id:"successifrunningdecorator",level:3},{value:"RandomNode",id:"randomnode",level:3},{value:"Common Decorator Patterns",id:"common-decorator-patterns",level:2},{value:"Timers and Cooldowns",id:"timers-and-cooldowns",level:3},{value:"Condition Limiters",id:"condition-limiters",level:3},{value:"Retry Mechanics",id:"retry-mechanics",level:3},{value:"Creating Custom Decorator Nodes",id:"creating-custom-decorator-nodes",level:2},{value:"Example: Probability Decorator",id:"example-probability-decorator",level:2},{value:"Example: Tracking Decorator",id:"example-tracking-decorator",level:2},{value:"Integration with Other Node Types",id:"integration-with-other-node-types",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"decorator-nodes",children:"Decorator Nodes"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"API Version: 619045"})}),"\n",(0,o.jsx)(n.p,{children:"Decorator Nodes are specialized behavior tree nodes that modify the behavior of other nodes. They typically wrap a single child node and either change its execution behavior, modify its return value, or control when and how it runs. Decorator nodes are a powerful tool for creating complex behaviors without needing to create entirely new node types."}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Basic decorator node structure\nlocal MyDecorator = Class(BehaviorNode, function(self, inst, child, param)\n    BehaviorNode._ctor(self, "MyDecorator")\n    self.inst = inst\n    self.child = child\n    self.param = param\nend)\n\nfunction MyDecorator:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.child:Start()\n    end\n\n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        -- Modify the child node\'s result or behavior\n        if status == SUCCESS or status == FAILURE then\n            -- Apply decorator logic\n            self.status = self:ModifyResult(status)\n        end\n    end\n    \n    return self.status\nend\n\nfunction MyDecorator:ModifyResult(status)\n    -- This is where the decorator modifies the result\n    if self.param then\n        return SUCCESS\n    else\n        return status\n    end\nend\n\n-- Used in a behavior tree\nlocal root = PriorityNode(\n{\n    -- Apply a decorator to a node\n    MyDecorator(inst, \n        DoAction(inst, SomeAction), \n        true\n    ),\n    -- Other nodes\n}, 0.5) -- Run every 0.5 seconds\n'})}),"\n",(0,o.jsx)(n.h2,{id:"decorator-node-states",children:"Decorator Node States"}),"\n",(0,o.jsx)(n.p,{children:"Decorator nodes can be in the same states as other behavior nodes:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"State"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"READY"})}),(0,o.jsx)(n.td,{children:"Node is ready to be executed"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"RUNNING"})}),(0,o.jsx)(n.td,{children:"Node is currently executing"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SUCCESS"})}),(0,o.jsx)(n.td,{children:"Node has completed successfully"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"FAILURE"})}),(0,o.jsx)(n.td,{children:"Node has failed to complete"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"built-in-decorator-nodes",children:"Built-in Decorator Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Don't Starve Together includes several pre-defined decorator nodes:"}),"\n",(0,o.jsx)(n.h3,{id:"notdecorator",children:"NotDecorator"}),"\n",(0,o.jsx)(n.p,{children:"Inverts the result of its child node - SUCCESS becomes FAILURE and vice versa."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"-- Basic format\nNotDecorator(child_node)\n\n-- Example: Invert the result of an action\nNotDecorator(\n    DoAction(inst, function()\n        return inst.components.hunger:GetPercent() > 0.5\n    end)\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"failifrunningdecorator",children:"FailIfRunningDecorator"}),"\n",(0,o.jsx)(n.p,{children:"Returns FAILURE if the child is still RUNNING after a certain time."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"-- Basic format\nFailIfRunningDecorator(child_node, max_time)\n\n-- Example: Fail if action is taking too long\nFailIfRunningDecorator(\n    GoToEntity(inst, function() return FindClosestFood(inst) end, 1), \n    5 -- Fail if taking more than 5 seconds\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"loopnode",children:"LoopNode"}),"\n",(0,o.jsx)(n.p,{children:"Repeatedly executes the child node, either forever or a specific number of times."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Basic format for infinite loop\nLoopNode(child_node)\n\n-- Basic format for specific iterations\nLoopNode(child_node, max_loops)\n\n-- Example: Try to find food 3 times\nLoopNode(\n    FindFood(inst, {"fruit", "veggie"}, 20),\n    3\n)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"successifrunningdecorator",children:"SuccessIfRunningDecorator"}),"\n",(0,o.jsx)(n.p,{children:"Returns SUCCESS if the child node is still RUNNING."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"-- Basic format\nSuccessIfRunningDecorator(child_node)\n\n-- Example: Consider it a success if we're still chasing the target\nSuccessIfRunningDecorator(\n    ChaseAndAttack(inst, 10)\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"randomnode",children:"RandomNode"}),"\n",(0,o.jsx)(n.p,{children:"Randomly selects from its children nodes, based on weighted probabilities."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Basic format\nRandomNode(\n    {chance1, node1},\n    {chance2, node2},\n    ...\n)\n\n-- Example: Random behavior selection\nRandomNode(\n    {0.6, Wander(inst)},\n    {0.3, DoAction(inst, EatFood)},\n    {0.1, RunAway(inst, "character", 5, 8)}\n)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"common-decorator-patterns",children:"Common Decorator Patterns"}),"\n",(0,o.jsx)(n.p,{children:"Here are some common ways to use decorator nodes in Don't Starve Together AI:"}),"\n",(0,o.jsx)(n.h3,{id:"timers-and-cooldowns",children:"Timers and Cooldowns"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Run a behavior only every X seconds\nTimerDecorator = Class(BehaviorNode, function(self, inst, child, cooldown_time)\n    BehaviorNode._ctor(self, "TimerDecorator")\n    self.inst = inst\n    self.child = child\n    self.cooldown_time = cooldown_time\n    self.last_execution = 0\nend)\n\nfunction TimerDecorator:Visit()\n    if self.status == READY then\n        -- Check if cooldown has passed\n        if (GetTime() - self.last_execution) >= self.cooldown_time then\n            self.status = RUNNING\n            self.child:Start()\n        else\n            self.status = FAILURE\n            return self.status\n        end\n    end\n    \n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        if status ~= RUNNING then\n            self.last_execution = GetTime()\n            self.status = status\n        end\n    end\n    \n    return self.status\nend\n'})}),"\n",(0,o.jsx)(n.h3,{id:"condition-limiters",children:"Condition Limiters"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Only execute child node if condition is true\nConditionalDecorator = Class(BehaviorNode, function(self, inst, child, cond_fn)\n    BehaviorNode._ctor(self, "ConditionalDecorator")\n    self.inst = inst\n    self.child = child\n    self.cond_fn = cond_fn\nend)\n\nfunction ConditionalDecorator:Visit()\n    if self.status == READY then\n        if self.cond_fn(self.inst) then\n            self.status = RUNNING\n            self.child:Start()\n        else\n            self.status = FAILURE\n            return self.status\n        end\n    end\n    \n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        if status ~= RUNNING then\n            self.status = status\n        end\n    end\n    \n    return self.status\nend\n'})}),"\n",(0,o.jsx)(n.h3,{id:"retry-mechanics",children:"Retry Mechanics"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Try the child node multiple times until success\nRetryDecorator = Class(BehaviorNode, function(self, inst, child, max_attempts)\n    BehaviorNode._ctor(self, "RetryDecorator")\n    self.inst = inst\n    self.child = child\n    self.max_attempts = max_attempts\n    self.attempts = 0\nend)\n\nfunction RetryDecorator:Visit()\n    if self.status == READY then\n        self.attempts = 0\n        self.status = RUNNING\n    end\n    \n    if self.status == RUNNING then\n        if self.attempts >= self.max_attempts then\n            self.status = FAILURE\n            return self.status\n        end\n        \n        if self.child.status ~= RUNNING then\n            self.child:Start()\n        end\n        \n        local status = self.child:Visit()\n        \n        if status == SUCCESS then\n            self.status = SUCCESS\n        elseif status == FAILURE then\n            self.attempts = self.attempts + 1\n            self.child:Stop()\n            -- Let it try again in the next Visit\n        end\n    end\n    \n    return self.status\nend\n'})}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-decorator-nodes",children:"Creating Custom Decorator Nodes"}),"\n",(0,o.jsx)(n.p,{children:"To create a custom decorator node:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Derive from BehaviorNode"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'local CustomDecorator = Class(BehaviorNode, function(self, inst, child, ...)\n    BehaviorNode._ctor(self, "CustomDecorator")\n    self.inst = inst\n    self.child = child\n    -- Store other parameters\nend)\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Implement Visit function"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function CustomDecorator:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.child:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        -- Here is where you implement your decorator logic\n        -- to modify the behavior of the child node\n        \n        if status ~= RUNNING then\n            -- Handle completion\n            self.status = self:ProcessChildResult(status)\n        end\n    end\n    \n    return self.status\nend\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Optional: Implement Stop and Reset functions"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"function CustomDecorator:Stop()\n    self.child:Stop()\n    self.status = READY\nend\n\nfunction CustomDecorator:Reset()\n    self.child:Reset()\n    self.status = READY\nend\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-probability-decorator",children:"Example: Probability Decorator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- A decorator that has a percentage chance of executing its child node\nlocal ProbabilityDecorator = Class(BehaviorNode, function(self, inst, child, chance)\n    BehaviorNode._ctor(self, "ProbabilityDecorator")\n    self.inst = inst\n    self.child = child\n    self.chance = math.clamp(chance, 0, 1) -- Probability between 0 and 1\nend)\n\nfunction ProbabilityDecorator:Visit()\n    if self.status == READY then\n        if math.random() <= self.chance then\n            self.status = RUNNING\n            self.child:Start()\n        else\n            self.status = FAILURE\n            return self.status\n        end\n    end\n    \n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        if status ~= RUNNING then\n            self.status = status\n        end\n    end\n    \n    return self.status\nend\n\nfunction ProbabilityDecorator:Stop()\n    self.child:Stop()\n    self.status = READY\nend\n\n-- Usage in a behavior tree\nlocal behavior = PriorityNode(\n{\n    -- 50% chance to run away when health is low\n    ProbabilityDecorator(\n        IfNode(function() return inst.components.health:GetPercent() < 0.3 end,\n            RunAway(inst, "character", 5, 8)\n        ),\n        0.5\n    ),\n    \n    -- Default behavior\n    Wander(inst)\n}, 0.5)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"example-tracking-decorator",children:"Example: Tracking Decorator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- A decorator that logs success/failure statistics\nlocal TrackingDecorator = Class(BehaviorNode, function(self, inst, child, name)\n    BehaviorNode._ctor(self, "TrackingDecorator")\n    self.inst = inst\n    self.child = child\n    self.name = name or "unnamed"\n    self.success_count = 0\n    self.failure_count = 0\n    self.last_status = nil\nend)\n\nfunction TrackingDecorator:Visit()\n    if self.status == READY then\n        self.status = RUNNING\n        self.child:Start()\n    end\n    \n    if self.status == RUNNING then\n        local status = self.child:Visit()\n        \n        if status ~= RUNNING then\n            if status == SUCCESS then\n                self.success_count = self.success_count + 1\n            elseif status == FAILURE then\n                self.failure_count = self.failure_count + 1\n            end\n            \n            self.last_status = status\n            self.status = status\n            \n            -- Log statistics\n            print(string.format("[%s] Success: %d, Failure: %d, Last Status: %s", \n                self.name, self.success_count, self.failure_count, \n                status == SUCCESS and "SUCCESS" or "FAILURE"))\n        end\n    end\n    \n    return self.status\nend\n\nfunction TrackingDecorator:GetStats()\n    return {\n        name = self.name,\n        success = self.success_count,\n        failure = self.failure_count,\n        total = self.success_count + self.failure_count,\n        success_rate = self.success_count / \n            (self.success_count + self.failure_count > 0 and \n             (self.success_count + self.failure_count) or 1)\n    }\nend\n'})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-other-node-types",children:"Integration with Other Node Types"}),"\n",(0,o.jsx)(n.p,{children:"Decorator nodes work with other node types to create complex behaviors:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Complex behavior tree with decorators\nlocal behavior = PriorityNode(\n{\n    -- Only try to find food every 10 seconds\n    TimerDecorator(\n        FindAndEatFood(inst),\n        10\n    ),\n    \n    -- Try attacking up to 3 times when target is present\n    IfNode(function() return inst.components.combat:HasTarget() end,\n        RetryDecorator(\n            AttackTarget(inst, function() return inst.components.combat.target end),\n            3\n        )\n    ),\n    \n    -- 75% chance to run away at night, otherwise keep wandering\n    IfNode(function() return TheWorld.state.isnight end,\n        ProbabilityDecorator(\n            RunAway(inst, "character", 10, 15),\n            0.75\n        )\n    ),\n    \n    -- Track wandering success/failure\n    TrackingDecorator(\n        Wander(inst),\n        "wander_tracking"\n    )\n}, 0.5)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Decorator nodes add an extra layer of function calls, so use them judiciously"}),"\n",(0,o.jsx)(n.li,{children:"Prefer built-in decorator nodes when available for better performance"}),"\n",(0,o.jsx)(n.li,{children:"Consider consolidating multiple decorators into a single custom decorator when possible"}),"\n",(0,o.jsx)(n.li,{children:"Avoid deeply nested chains of decorators if performance is critical"}),"\n",(0,o.jsx)(n.li,{children:"Use tracking decorators during development but remove them for production"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/brain",children:"Brain"})," - For brain implementation using behavior trees"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/action-nodes",children:"Action Nodes"})," - For nodes that perform actions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/priority-nodes",children:"Priority Nodes"})," - For selecting between different actions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/condition-nodes",children:"Condition Nodes"})," - For conditional execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/node-types/sequence-nodes",children:"Sequence Nodes"})," - For executing actions in sequence"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);