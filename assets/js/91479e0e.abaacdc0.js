"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[169],{7857:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api-vanilla/examples/networking-mod","title":"Networking and Multiplayer","description":"Last Update: 2023-07-06","source":"@site/docs/api-vanilla/examples/networking-mod.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/networking-mod","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/networking-mod","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"id":"networking-mod","title":"Networking and Multiplayer","sidebar_position":9,"last_updated":"2023-07-06T00:00:00.000Z"},"sidebar":"docs","previous":{"title":"Performance Optimization","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/optimization"},"next":{"title":"Reducing Resource Usage","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/resource-usage"}}');var i=t(4848),o=t(8453);const l={id:"networking-mod",title:"Networking and Multiplayer",sidebar_position:9,last_updated:new Date("2023-07-06T00:00:00.000Z")},r="Networking and Multiplayer",a={},d=[{value:"Project Overview",id:"project-overview",level:2},{value:"Step 1: Set Up the Mod Structure",id:"step-1-set-up-the-mod-structure",level:2},{value:"Step 2: Create the modinfo.lua File",id:"step-2-create-the-modinfolua-file",level:2},{value:"Step 3: Create the Player Notes Component",id:"step-3-create-the-player-notes-component",level:2},{value:"Step 4: Create the Notes UI Widget",id:"step-4-create-the-notes-ui-widget",level:2},{value:"Step 5: Create the Note Screen",id:"step-5-create-the-note-screen",level:2},{value:"Step 6: Create the modmain.lua File",id:"step-6-create-the-modmainlua-file",level:2},{value:"Step 7: Create the UI Assets",id:"step-7-create-the-ui-assets",level:2},{value:"Step 8: Testing Your Networking Mod",id:"step-8-testing-your-networking-mod",level:2},{value:"Understanding Networking in Don&#39;t Starve Together",id:"understanding-networking-in-dont-starve-together",level:2},{value:"Server and Client Roles",id:"server-and-client-roles",level:3},{value:"Network Components",id:"network-components",level:3},{value:"The Master Sim",id:"the-master-sim",level:3},{value:"Key Networking Concepts",id:"key-networking-concepts",level:2},{value:"1. Server Authority",id:"1-server-authority",level:3},{value:"2. Data Synchronization",id:"2-data-synchronization",level:3},{value:"3. Network Efficiency",id:"3-network-efficiency",level:3},{value:"4. Player Join/Leave Handling",id:"4-player-joinleave-handling",level:3},{value:"Customization Options",id:"customization-options",level:2},{value:"Add Player-Specific Data",id:"add-player-specific-data",level:3},{value:"Add Real-Time Collaboration",id:"add-real-time-collaboration",level:3},{value:"Add Data Persistence",id:"add-data-persistence",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Problem: Data not syncing between clients",id:"problem-data-not-syncing-between-clients",level:3},{value:"Problem: Network spam causing lag",id:"problem-network-spam-causing-lag",level:3},{value:"Problem: Data lost when server restarts",id:"problem-data-lost-when-server-restarts",level:3},{value:"Problem: Late-joining players don&#39;t get data",id:"problem-late-joining-players-dont-get-data",level:3},{value:"Problem: Race conditions in network code",id:"problem-race-conditions-in-network-code",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last Update: 2023-07-06"})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"networking-and-multiplayer",children:"Networking and Multiplayer"})}),"\n",(0,i.jsx)(n.p,{children:"This tutorial walks through creating mods that handle networking and multiplayer functionality in Don't Starve Together. We'll build a mod that synchronizes custom data between clients and the server."}),"\n",(0,i.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,i.jsx)(n.p,{children:'We\'ll create a mod that adds a "Player Notes" system with:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ability to write notes that are visible to all players"}),"\n",(0,i.jsx)(n.li,{children:"Real-time synchronization of note data between clients"}),"\n",(0,i.jsx)(n.li,{children:"Proper handling of player join/leave events"}),"\n",(0,i.jsx)(n.li,{children:"Network-efficient updates using RPC calls"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-1-set-up-the-mod-structure",children:"Step 1: Set Up the Mod Structure"}),"\n",(0,i.jsx)(n.p,{children:"Create these folders and files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"playernotes_mod/\n\u251c\u2500\u2500 modinfo.lua\n\u251c\u2500\u2500 modmain.lua\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 playernotes.lua\n\u2502   \u251c\u2500\u2500 screens/\n\u2502   \u2502   \u2514\u2500\u2500 playernotescreen.lua\n\u2502   \u2514\u2500\u2500 widgets/\n\u2502       \u2514\u2500\u2500 playernotesui.lua\n\u2514\u2500\u2500 images/\n    \u2514\u2500\u2500 notes_assets.tex\n    \u2514\u2500\u2500 notes_assets.xml\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-2-create-the-modinfolua-file",children:"Step 2: Create the modinfo.lua File"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'name = "Player Notes"\ndescription = "Add shareable notes between players"\nauthor = "Your Name"\nversion = "1.0.0"\n\n-- Compatible with Don\'t Starve Together\ndst_compatible = true\n\n-- Not compatible with Don\'t Starve\ndont_starve_compatible = false\nreign_of_giants_compatible = false\n\n-- This mod is required on all clients\nall_clients_require_mod = true\n\n-- This mod is not a client-only mod\nclient_only_mod = false\n\n-- Icon displayed in the server list\nicon_atlas = "modicon.xml"\nicon = "modicon.tex"\n\n-- Tags that describe your mod\nserver_filter_tags = {\n    "utility",\n    "multiplayer"\n}\n\n-- Configuration options\nconfiguration_options = {\n    {\n        name = "max_note_length",\n        label = "Max Note Length",\n        options = {\n            {description = "Short (100 chars)", data = 100},\n            {description = "Medium (250 chars)", data = 250},\n            {description = "Long (500 chars)", data = 500}\n        },\n        default = 250\n    },\n    {\n        name = "note_history",\n        label = "Note History",\n        options = {\n            {description = "Keep 5 notes", data = 5},\n            {description = "Keep 10 notes", data = 10},\n            {description = "Keep 20 notes", data = 20}\n        },\n        default = 10\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-3-create-the-player-notes-component",children:"Step 3: Create the Player Notes Component"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"scripts/components/playernotes.lua"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local PlayerNotes = Class(function(self, inst)\n    self.inst = inst\n    self.notes = {}\n    self.max_notes = GetModConfigData("note_history") or 10\n    self.max_note_length = GetModConfigData("max_note_length") or 250\n    \n    -- Initialize network variables\n    self.net_dirty = false\n    \n    if TheWorld.ismastersim then\n        -- Server-side initialization\n        self.inst:DoTaskInTime(0, function() self:SyncNotes() end)\n        \n        -- Listen for player join events to sync notes\n        self.inst:ListenForEvent("ms_playerleft", function(world, player)\n            -- When a player leaves, update the player list\n            self:SyncNotes()\n        end, TheWorld)\n        \n        self.inst:ListenForEvent("ms_playerjoined", function(world, player)\n            -- When a player joins, send them the notes\n            self:SyncNotes()\n        end, TheWorld)\n    end\nend)\n\n-- Add a new note (server-side)\nfunction PlayerNotes:AddNote(author, content)\n    if not TheWorld.ismastersim then\n        -- Client should send RPC instead\n        return\n    end\n    \n    -- Sanitize and trim content\n    content = content:sub(1, self.max_note_length)\n    content = content:gsub("<[^>]+>", "") -- Remove HTML-like tags\n    \n    -- Create the note\n    local note = {\n        author = author,\n        content = content,\n        timestamp = os.time()\n    }\n    \n    -- Add to notes list\n    table.insert(self.notes, note)\n    \n    -- Trim list if it exceeds max_notes\n    while #self.notes > self.max_notes do\n        table.remove(self.notes, 1)\n    end\n    \n    -- Mark as dirty to sync\n    self.net_dirty = true\n    \n    -- Sync to all clients\n    self:SyncNotes()\n    \n    return true\nend\n\n-- Sync notes to clients\nfunction PlayerNotes:SyncNotes()\n    if not TheWorld.ismastersim then\n        -- Only the server should sync\n        return\n    end\n    \n    -- Reset dirty flag\n    self.net_dirty = false\n    \n    -- Prepare data for network\n    local data = {}\n    for i, note in ipairs(self.notes) do\n        table.insert(data, {\n            author = note.author,\n            content = note.content,\n            timestamp = note.timestamp\n        })\n    end\n    \n    -- Serialize data\n    local serialized = json.encode(data)\n    \n    -- Send to all clients\n    for i, player in ipairs(AllPlayers) do\n        if player.userid then\n            SendModRPCToClient(GetClientModRPC("PlayerNotes", "SyncNotes"), player.userid, serialized)\n        end\n    end\nend\n\n-- Receive notes from server (client-side)\nfunction PlayerNotes:ReceiveNotes(serialized)\n    if TheWorld.ismastersim then\n        -- Server shouldn\'t receive notes\n        return\n    end\n    \n    -- Deserialize data\n    local success, data = pcall(function() return json.decode(serialized) end)\n    \n    if success and data then\n        self.notes = data\n        \n        -- Notify UI to update\n        self.inst:PushEvent("noteschanged", { notes = self.notes })\n    end\nend\n\n-- Get all notes\nfunction PlayerNotes:GetNotes()\n    return self.notes\nend\n\n-- Clear all notes (server-side)\nfunction PlayerNotes:ClearNotes()\n    if not TheWorld.ismastersim then\n        -- Client should send RPC instead\n        return\n    end\n    \n    self.notes = {}\n    self.net_dirty = true\n    self:SyncNotes()\n    \n    return true\nend\n\nreturn PlayerNotes\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-4-create-the-notes-ui-widget",children:"Step 4: Create the Notes UI Widget"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"scripts/widgets/playernotesui.lua"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local Widget = require "widgets/widget"\nlocal Image = require "widgets/image"\nlocal Text = require "widgets/text"\nlocal TextEdit = require "widgets/textedit"\nlocal ScrollableList = require "widgets/scrollablelist"\nlocal Button = require "widgets/button"\n\n-- Define our custom widget\nlocal PlayerNotesUI = Class(Widget, function(self, owner)\n    -- Call the parent constructor\n    Widget._ctor(self, "PlayerNotesUI")\n    \n    -- Store reference to the player\n    self.owner = owner\n    \n    -- Initialize widget\n    self:SetupUI()\n    \n    -- Listen for note changes\n    self.owner:ListenForEvent("noteschanged", function(inst, data) \n        self:RefreshNotes(data.notes)\n    end)\nend)\n\n-- Set up the UI elements\nfunction PlayerNotesUI:SetupUI()\n    -- Create the background panel\n    self.bg = self:AddChild(Image("images/notes_assets.xml", "notes_bg.tex"))\n    self.bg:SetSize(500, 400)\n    \n    -- Add title\n    self.title = self:AddChild(Text(TITLEFONT, 30))\n    self.title:SetPosition(0, 170, 0)\n    self.title:SetString("Player Notes")\n    self.title:SetColour(1, 1, 1, 1)\n    \n    -- Add close button\n    self.close_btn = self:AddChild(ImageButton("images/notes_assets.xml", "close_button.tex"))\n    self.close_btn:SetPosition(230, 170, 0)\n    self.close_btn:SetOnClick(function() self:Hide() end)\n    \n    -- Create notes list container\n    self.notes_root = self:AddChild(Widget("notes_root"))\n    self.notes_root:SetPosition(0, 30, 0)\n    \n    -- Create text entry for new notes\n    self.note_entry = self:AddChild(TextEdit(CHATFONT, 20, ""))\n    self.note_entry:SetPosition(0, -140, 0)\n    self.note_entry:SetForceEdit(true)\n    self.note_entry:SetCharacterLimit(GetModConfigData("max_note_length") or 250)\n    self.note_entry:SetWidth(400)\n    self.note_entry:SetHeight(60)\n    \n    -- Add submit button\n    self.submit_btn = self:AddChild(ImageButton("images/notes_assets.xml", "submit_button.tex"))\n    self.submit_btn:SetPosition(200, -140, 0)\n    self.submit_btn:SetOnClick(function() self:SubmitNote() end)\n    \n    -- Add clear button\n    self.clear_btn = self:AddChild(ImageButton("images/notes_assets.xml", "clear_button.tex"))\n    self.clear_btn:SetPosition(-200, -140, 0)\n    self.clear_btn:SetOnClick(function() self:ClearNotes() end)\n    \n    -- Hide by default\n    self:Hide()\nend\n\n-- Submit a new note\nfunction PlayerNotesUI:SubmitNote()\n    local content = self.note_entry:GetString()\n    \n    if content and content:len() > 0 then\n        -- Send RPC to server\n        SendModRPCToServer(GetModRPC("PlayerNotes", "AddNote"), content)\n        \n        -- Clear the input\n        self.note_entry:SetString("")\n    end\nend\n\n-- Clear all notes\nfunction PlayerNotesUI:ClearNotes()\n    -- Send RPC to server\n    SendModRPCToServer(GetModRPC("PlayerNotes", "ClearNotes"))\nend\n\n-- Refresh the notes display\nfunction PlayerNotesUI:RefreshNotes(notes)\n    -- Clear existing notes\n    self.notes_root:KillAllChildren()\n    \n    -- No notes to display\n    if not notes or #notes == 0 then\n        local empty_text = self.notes_root:AddChild(Text(CHATFONT, 20))\n        empty_text:SetString("No notes yet. Be the first to add one!")\n        empty_text:SetPosition(0, 0, 0)\n        return\n    end\n    \n    -- Create scrollable list\n    local list_items = {}\n    \n    -- Create items for each note\n    for i, note in ipairs(notes) do\n        local item = Widget("note_item_" .. i)\n        \n        -- Format timestamp\n        local timestamp = note.timestamp and os.date("%Y-%m-%d %H:%M", note.timestamp) or "Unknown time"\n        \n        -- Add author and timestamp\n        local header = item:AddChild(Text(CHATFONT, 16))\n        header:SetString(note.author .. " - " .. timestamp)\n        header:SetPosition(0, 15, 0)\n        header:SetColour(0.7, 0.7, 1, 1)\n        \n        -- Add content\n        local content = item:AddChild(Text(CHATFONT, 18))\n        content:SetString(note.content)\n        content:SetPosition(0, -10, 0)\n        content:SetMultilineTruncatedString(note.content, 3, 400)\n        \n        -- Set item size\n        item.height = 60\n        \n        table.insert(list_items, item)\n    end\n    \n    -- Create scrollable list\n    self.notes_list = self.notes_root:AddChild(ScrollableList(list_items, 450, 250))\n    self.notes_list:SetPosition(0, 0, 0)\nend\n\n-- Toggle visibility\nfunction PlayerNotesUI:ToggleVisibility()\n    if self:IsVisible() then\n        self:Hide()\n    else\n        self:Show()\n        -- Request latest notes when showing\n        if TheWorld.ismastersim then\n            -- Server already has the data\n            self:RefreshNotes(TheWorld.components.playernotes:GetNotes())\n        else\n            -- Client needs to request from server\n            SendModRPCToServer(GetModRPC("PlayerNotes", "RequestNotes"))\n        end\n    end\nend\n\nreturn PlayerNotesUI\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-5-create-the-note-screen",children:"Step 5: Create the Note Screen"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"scripts/screens/playernotescreen.lua"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local Screen = require "widgets/screen"\nlocal PlayerNotesUI = require "widgets/playernotesui"\n\nlocal PlayerNoteScreen = Class(Screen, function(self, owner)\n    Screen._ctor(self, "PlayerNoteScreen")\n    self.owner = owner\n    \n    -- Create the main UI widget\n    self.notes_ui = self:AddChild(PlayerNotesUI(owner))\n    self.notes_ui:SetPosition(0, 0, 0)\n    \n    -- Set up input handlers\n    self:SetupInputHandlers()\nend)\n\n-- Set up input handlers\nfunction PlayerNoteScreen:SetupInputHandlers()\n    -- Close on ESC key\n    self.cancel_handler = TheInput:AddKeyDownHandler(KEY_ESCAPE, function() \n        self:Close() \n    end)\nend\n\n-- Close the screen\nfunction PlayerNoteScreen:Close()\n    TheFrontEnd:PopScreen(self)\nend\n\n-- Clean up when the screen is removed\nfunction PlayerNoteScreen:OnDestroy()\n    if self.cancel_handler then\n        self.cancel_handler:Remove()\n        self.cancel_handler = nil\n    end\n    Screen.OnDestroy(self)\nend\n\nreturn PlayerNoteScreen\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-6-create-the-modmainlua-file",children:"Step 6: Create the modmain.lua File"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Import globals into the environment\nGLOBAL.setmetatable(env, {__index = function(t, k) return GLOBAL.rawget(GLOBAL, k) end})\n\n-- Add asset files\nAssets = {\n    -- UI assets\n    Asset("IMAGE", "images/notes_assets.tex"),\n    Asset("ATLAS", "images/notes_assets.xml"),\n}\n\n-- Require our custom modules\nlocal PlayerNotes = require "components/playernotes"\nlocal PlayerNoteScreen = require "screens/playernotescreen"\n\n-- Add custom strings\nSTRINGS.NAMES.PLAYERNOTES = "Player Notes"\nSTRINGS.UI.PLAYERNOTES = {\n    TITLE = "Player Notes",\n    SUBMIT = "Submit",\n    CLEAR = "Clear All",\n    EMPTY = "No notes yet. Be the first to add one!",\n    PLACEHOLDER = "Type your note here...",\n}\n\n-- Define RPC handlers\nAddModRPCHandler("PlayerNotes", "AddNote", function(player, content)\n    if TheWorld.components.playernotes then\n        local author = player.name or "Unknown Player"\n        TheWorld.components.playernotes:AddNote(author, content)\n    end\nend)\n\nAddModRPCHandler("PlayerNotes", "ClearNotes", function(player)\n    if TheWorld.components.playernotes then\n        TheWorld.components.playernotes:ClearNotes()\n    end\nend)\n\nAddModRPCHandler("PlayerNotes", "RequestNotes", function(player)\n    if TheWorld.components.playernotes then\n        TheWorld.components.playernotes:SyncNotes()\n    end\nend)\n\n-- Define client RPC handlers\nAddClientModRPCHandler("PlayerNotes", "SyncNotes", function(serialized)\n    if ThePlayer and ThePlayer.components.playernotes then\n        ThePlayer.components.playernotes:ReceiveNotes(serialized)\n    end\nend)\n\n-- Add the component to the world (server-side)\nAddPrefabPostInit("world", function(inst)\n    if TheWorld.ismastersim then\n        inst:AddComponent("playernotes")\n    end\nend)\n\n-- Add the component to the player (client-side)\nAddPlayerPostInit(function(inst)\n    if not TheWorld.ismastersim or inst == ThePlayer then\n        inst:AddComponent("playernotes")\n    end\n    \n    -- Add key handler to open notes screen (client-side only)\n    if inst == ThePlayer then\n        TheInput:AddKeyDownHandler(KEY_N, function()\n            if not TheFrontEnd:GetActiveScreen() or TheFrontEnd:GetActiveScreen().name == "HUD" then\n                TheFrontEnd:PushScreen(PlayerNoteScreen(inst))\n            end\n        end)\n    end\nend)\n\n-- Add a button to the pause menu\nAddClassPostConstruct("screens/pausescreen", function(self)\n    if self.menu and self.menu.items then\n        self.menu:AddItem("Player Notes", function()\n            self:Close()\n            TheFrontEnd:PushScreen(PlayerNoteScreen(ThePlayer))\n        end, "Open shared player notes")\n    end\nend)\n\n-- Print instructions when the game starts\nAddSimPostInit(function()\n    print("Player Notes mod loaded! Press \'N\' to open the notes screen.")\nend)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-7-create-the-ui-assets",children:"Step 7: Create the UI Assets"}),"\n",(0,i.jsx)(n.p,{children:"For a complete mod, you'll need to create these asset files:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"UI Textures"}),": ",(0,i.jsx)(n.code,{children:"images/notes_assets.tex"})," and ",(0,i.jsx)(n.code,{children:"notes_assets.xml"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Contains textures for the panel background, buttons, and icons"}),"\n",(0,i.jsx)(n.li,{children:'Should include "notes_bg.tex", "close_button.tex", "submit_button.tex", and "clear_button.tex"'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-8-testing-your-networking-mod",children:"Step 8: Testing Your Networking Mod"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Launch Don't Starve Together"}),"\n",(0,i.jsx)(n.li,{children:"Enable your mod in the Mods menu"}),"\n",(0,i.jsx)(n.li,{children:"Start a new server and invite a friend to join"}),"\n",(0,i.jsxs)(n.li,{children:["Test the networking features by:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Opening the notes screen with the 'N' key"}),"\n",(0,i.jsx)(n.li,{children:"Adding notes and verifying they appear on both clients"}),"\n",(0,i.jsx)(n.li,{children:"Having your friend add notes and checking that they sync to your client"}),"\n",(0,i.jsx)(n.li,{children:"Disconnecting and reconnecting to verify notes persist"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-networking-in-dont-starve-together",children:"Understanding Networking in Don't Starve Together"}),"\n",(0,i.jsx)(n.p,{children:"DST uses a client-server architecture for networking:"}),"\n",(0,i.jsx)(n.h3,{id:"server-and-client-roles",children:"Server and Client Roles"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Server"}),": Authoritative source of truth for game state"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Runs on the host's machine or a dedicated server"}),"\n",(0,i.jsx)(n.li,{children:"Processes all game logic and physics"}),"\n",(0,i.jsx)(n.li,{children:"Sends state updates to clients"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Client"}),": Displays the game state and sends player inputs"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Receives updates from the server"}),"\n",(0,i.jsx)(n.li,{children:"Sends player actions to the server"}),"\n",(0,i.jsx)(n.li,{children:"Can run prediction for smoother gameplay"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"network-components",children:"Network Components"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NetVars"}),": Synchronized variables that automatically replicate"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Used for simple data that changes frequently"}),"\n",(0,i.jsx)(n.li,{children:"Examples: health, position, animation state"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RPCs (Remote Procedure Calls)"}),": Function calls across the network"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Used for events and complex data"}),"\n",(0,i.jsx)(n.li,{children:"Can be client-to-server or server-to-client"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Events"}),": Local notifications that can trigger network updates"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Used to respond to state changes"}),"\n",(0,i.jsx)(n.li,{children:"Can be used with RPCs to sync changes"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-master-sim",children:"The Master Sim"}),"\n",(0,i.jsx)(n.p,{children:'Don\'t Starve Together uses a concept called "master simulation" (mastersim):'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TheWorld.ismastersim"})," indicates if the current instance is the authoritative server"]}),"\n",(0,i.jsx)(n.li,{children:"Only the server should make authoritative changes to game state"}),"\n",(0,i.jsx)(n.li,{children:"Clients should send requests to the server via RPCs"}),"\n",(0,i.jsx)(n.li,{children:"The server then updates the state and broadcasts changes"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-networking-concepts",children:"Key Networking Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"1-server-authority",children:"1. Server Authority"}),"\n",(0,i.jsx)(n.p,{children:"Always remember that the server is the authority. Important rules:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Check if we\'re on the server before making changes\nif TheWorld.ismastersim then\n    -- Make authoritative changes\n    entity.components.health:SetVal(100)\nelse\n    -- Send request to server\n    SendModRPCToServer(GetModRPC("MyMod", "SetHealth"), entity, 100)\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-data-synchronization",children:"2. Data Synchronization"}),"\n",(0,i.jsx)(n.p,{children:"There are multiple ways to sync data:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"NetVars"}),": For simple, frequently changing data"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- In component initialization\nself.damage = net_float(inst.GUID, "weapon.damage", "damagechanged")\n\n-- When setting the value (server-side)\nself.damage:set(new_damage)\n\n-- When getting the value (either side)\nlocal current_damage = self.damage:value()\n\n-- Listening for changes (client-side)\ninst:ListenForEvent("damagechanged", OnDamageChanged)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RPCs"}),": For complex data or infrequent updates"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Define the RPC handler (in modmain)\nAddModRPCHandler("MyMod", "SyncData", function(player, entity_id, data_json)\n    local entity = Ents[entity_id]\n    if entity and entity.components.mycomponent then\n        entity.components.mycomponent:ReceiveData(data_json)\n    end\nend)\n\n-- Send data from server to clients\nfor i, player in ipairs(AllPlayers) do\n    SendModRPCToClient(GetClientModRPC("MyMod", "SyncData"), player.userid, entity.GUID, json.encode(data))\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-network-efficiency",children:"3. Network Efficiency"}),"\n",(0,i.jsx)(n.p,{children:"Be mindful of network bandwidth:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Throttle Updates"}),": Don't send updates every frame"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Only sync if enough time has passed\nif self.last_sync_time + SYNC_INTERVAL < GetTime() then\n    self:SyncToClients()\n    self.last_sync_time = GetTime()\nend\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delta Compression"}),": Only send changes, not the entire state"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Track what has changed\nself.dirty_fields = {}\n\n-- When a field changes\nfunction MyComponent:SetField(name, value)\n    if self.fields[name] ~= value then\n        self.fields[name] = value\n        self.dirty_fields[name] = true\n    end\nend\n\n-- When syncing\nfunction MyComponent:SyncToClients()\n    if next(self.dirty_fields) then\n        -- Only send dirty fields\n        SendModRPCToClient(GetClientModRPC("MyMod", "SyncFields"), player.userid, json.encode(self.dirty_fields))\n        self.dirty_fields = {}\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-player-joinleave-handling",children:"4. Player Join/Leave Handling"}),"\n",(0,i.jsx)(n.p,{children:"Handle players joining and leaving properly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Listen for player events\ninst:ListenForEvent("ms_playerjoined", function(world, player)\n    -- Send current state to the new player\n    self:SyncToPlayer(player)\nend, TheWorld)\n\ninst:ListenForEvent("ms_playerleft", function(world, player)\n    -- Clean up any player-specific data\n    self.player_data[player.userid] = nil\n    -- Notify remaining players\n    self:BroadcastPlayerLeft(player)\nend, TheWorld)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"customization-options",children:"Customization Options"}),"\n",(0,i.jsx)(n.p,{children:"Here are some ways to enhance your networking mod:"}),"\n",(0,i.jsx)(n.h3,{id:"add-player-specific-data",children:"Add Player-Specific Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- In the component, store player-specific data\nfunction PlayerNotes:InitializePlayer(player)\n    if not self.player_data then\n        self.player_data = {}\n    end\n    \n    self.player_data[player.userid] = {\n        last_read_note = 0,\n        favorite_notes = {}\n    }\nend\n\n-- Add functions to work with player data\nfunction PlayerNotes:MarkNoteAsFavorite(player, note_id, is_favorite)\n    if not self.player_data[player.userid] then\n        self:InitializePlayer(player)\n    end\n    \n    if is_favorite then\n        table.insert(self.player_data[player.userid].favorite_notes, note_id)\n    else\n        for i, id in ipairs(self.player_data[player.userid].favorite_notes) do\n            if id == note_id then\n                table.remove(self.player_data[player.userid].favorite_notes, i)\n                break\n            end\n        end\n    end\n    \n    -- Sync this player's favorites\n    self:SyncPlayerData(player)\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"add-real-time-collaboration",children:"Add Real-Time Collaboration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Add a "currently typing" indicator\nfunction PlayerNotesUI:StartTyping()\n    -- Send RPC to server\n    SendModRPCToServer(GetModRPC("PlayerNotes", "PlayerTyping"), true)\nend\n\nfunction PlayerNotesUI:StopTyping()\n    -- Send RPC to server\n    SendModRPCToServer(GetModRPC("PlayerNotes", "PlayerTyping"), false)\nend\n\n-- In the component, track who\'s typing\nfunction PlayerNotes:SetPlayerTyping(player, is_typing)\n    if not self.typing_players then\n        self.typing_players = {}\n    end\n    \n    if is_typing then\n        self.typing_players[player.userid] = player.name\n    else\n        self.typing_players[player.userid] = nil\n    end\n    \n    -- Broadcast typing status to all players\n    self:BroadcastTypingStatus()\nend\n\n-- Add a visual indicator in the UI\nfunction PlayerNotesUI:UpdateTypingIndicator(typing_players)\n    if not self.typing_indicator then\n        self.typing_indicator = self:AddChild(Text(CHATFONT, 16))\n        self.typing_indicator:SetPosition(0, -170, 0)\n        self.typing_indicator:SetColour(0.7, 0.7, 0.7, 1)\n    end\n    \n    local names = {}\n    for userid, name in pairs(typing_players) do\n        table.insert(names, name)\n    end\n    \n    if #names > 0 then\n        self.typing_indicator:SetString(table.concat(names, ", ") .. " typing...")\n        self.typing_indicator:Show()\n    else\n        self.typing_indicator:Hide()\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"add-data-persistence",children:"Add Data Persistence"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- In the component, add save/load functions\nfunction PlayerNotes:OnSave()\n    return {\n        notes = self.notes\n    }\nend\n\nfunction PlayerNotes:OnLoad(data)\n    if data and data.notes then\n        self.notes = data.notes\n        self.net_dirty = true\n    end\nend\n\n-- Add to world entity\nAddPrefabPostInit("world", function(inst)\n    if TheWorld.ismastersim then\n        inst:AddComponent("playernotes")\n        \n        -- Add save/load hooks\n        local old_OnSave = inst.OnSave\n        inst.OnSave = function(inst, data)\n            if old_OnSave then\n                old_OnSave(inst, data)\n            end\n            \n            data.playernotes = inst.components.playernotes:OnSave()\n        end\n        \n        local old_OnLoad = inst.OnLoad\n        inst.OnLoad = function(inst, data)\n            if old_OnLoad then\n                old_OnLoad(inst, data)\n            end\n            \n            if data and data.playernotes and inst.components.playernotes then\n                inst.components.playernotes:OnLoad(data.playernotes)\n            end\n        end\n    end\nend)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"problem-data-not-syncing-between-clients",children:"Problem: Data not syncing between clients"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Make sure you're checking TheWorld.ismastersim correctly and using RPCs properly"]}),"\n",(0,i.jsx)(n.h3,{id:"problem-network-spam-causing-lag",children:"Problem: Network spam causing lag"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Throttle updates and only send what has changed"]}),"\n",(0,i.jsx)(n.h3,{id:"problem-data-lost-when-server-restarts",children:"Problem: Data lost when server restarts"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Implement proper save/load functions for persistence"]}),"\n",(0,i.jsx)(n.h3,{id:"problem-late-joining-players-dont-get-data",children:"Problem: Late-joining players don't get data"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Handle the ms_playerjoined event to sync data to new players"]}),"\n",(0,i.jsx)(n.h3,{id:"problem-race-conditions-in-network-code",children:"Problem: Race conditions in network code"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Use a task delay to ensure components are fully initialized:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Delay initialization to ensure all components are ready\ninst:DoTaskInTime(0.1, function()\n    if TheWorld.components.playernotes then\n        TheWorld.components.playernotes:SyncToClients()\n    end\nend)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you've created a networked mod, you can:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add More Features"}),": Create additional synchronized systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Improve Efficiency"}),": Optimize your network code for better performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add Persistence"}),": Save and load custom data between game sessions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create Multiplayer Tools"}),": Build collaborative tools for players"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more advanced networking, check out the ",(0,i.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/core/network-system",children:"Network System"})," documentation to learn about the full capabilities of the networking system."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function l(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);