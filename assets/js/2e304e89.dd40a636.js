"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[5425],{700:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>f,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api-vanilla/examples/optimization","title":"Performance Optimization","description":"This guide covers techniques for optimizing your Don\'t Starve Together mods to ensure they run efficiently without causing lag or performance issues.","source":"@site/docs/api-vanilla/examples/optimization.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/optimization","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/optimization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"optimization","title":"Performance Optimization","sidebar_position":10},"sidebar":"docs","previous":{"title":"World Generation","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/worldgen-mod"},"next":{"title":"Networking and Multiplayer","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/networking-mod"}}');var a=t(4848),s=t(8453);const l={id:"optimization",title:"Performance Optimization",sidebar_position:10},o="Performance Optimization Techniques",r={},c=[{value:"Understanding Performance Concerns",id:"understanding-performance-concerns",level:2},{value:"Key Areas for Optimization",id:"key-areas-for-optimization",level:2},{value:"1. Update Functions",id:"1-update-functions",level:3},{value:"2. Entity Searches",id:"2-entity-searches",level:3},{value:"3. Event Handling",id:"3-event-handling",level:3},{value:"4. Memory Management",id:"4-memory-management",level:3},{value:"5. Network Optimization",id:"5-network-optimization",level:3},{value:"Practical Optimization Example: Area Effect System",id:"practical-optimization-example-area-effect-system",level:2},{value:"Unoptimized Version",id:"unoptimized-version",level:3},{value:"Optimized Version",id:"optimized-version",level:3},{value:"Profiling and Debugging",id:"profiling-and-debugging",level:2},{value:"1. In-Game Profiling",id:"1-in-game-profiling",level:3},{value:"2. Frame Time Logging",id:"2-frame-time-logging",level:3},{value:"3. Memory Usage Tracking",id:"3-memory-usage-tracking",level:3},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Case Study: Optimizing a Weather Effect Mod",id:"case-study-optimizing-a-weather-effect-mod",level:2},{value:"Original Implementation",id:"original-implementation",level:3},{value:"Optimized Implementation",id:"optimized-implementation",level:3},{value:"Caching and Lazy Loading Techniques",id:"caching-and-lazy-loading-techniques",level:2},{value:"Caching Expensive Calculations",id:"caching-expensive-calculations",level:3},{value:"Path Caching",id:"path-caching",level:3},{value:"Lazy Loading Resources",id:"lazy-loading-resources",level:3},{value:"Component State Caching",id:"component-state-caching",level:3},{value:"Deferred Initialization",id:"deferred-initialization",level:3},{value:"Incremental Loading",id:"incremental-loading",level:3},{value:"Working with Many Entities",id:"working-with-many-entities",level:2},{value:"Entity Pooling",id:"entity-pooling",level:3},{value:"Spatial Partitioning",id:"spatial-partitioning",level:3},{value:"Batched Processing",id:"batched-processing",level:3},{value:"Level of Detail (LOD)",id:"level-of-detail-lod",level:3},{value:"Instanced Rendering",id:"instanced-rendering",level:3},{value:"Entity Culling",id:"entity-culling",level:3},{value:"Centralized Manager",id:"centralized-manager",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"performance-optimization-techniques",children:"Performance Optimization Techniques"})}),"\n",(0,a.jsx)(n.p,{children:"This guide covers techniques for optimizing your Don't Starve Together mods to ensure they run efficiently without causing lag or performance issues."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-performance-concerns",children:"Understanding Performance Concerns"}),"\n",(0,a.jsx)(n.p,{children:"Performance is critical in Don't Starve Together mods for several reasons:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The game must maintain a steady frame rate across various hardware"}),"\n",(0,a.jsx)(n.li,{children:"In multiplayer, poor optimization can affect all connected players"}),"\n",(0,a.jsx)(n.li,{children:"Complex mods can significantly impact server performance"}),"\n",(0,a.jsx)(n.li,{children:"Performance issues compound when multiple mods are installed"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-areas-for-optimization",children:"Key Areas for Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"1-update-functions",children:"1. Update Functions"}),"\n",(0,a.jsx)(n.p,{children:"One of the most common performance issues comes from inefficient update functions that run frequently:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Running expensive operations every frame\nfunction Component:OnUpdate(dt)\n    -- This runs every frame (potentially 60 times per second)\n    local entities = TheSim:FindEntities(x, y, z, 30, nil, {"INLIMBO"})\n    for _, ent in ipairs(entities) do\n        -- Complex calculations for each entity\n        self:ProcessEntity(ent)\n    end\nend\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Using periodic tasks instead of every-frame updates\nfunction Component:Init()\n    -- Run expensive operations less frequently\n    self.task = self.inst:DoPeriodicTask(0.5, function() \n        local entities = TheSim:FindEntities(x, y, z, 30, nil, {"INLIMBO"})\n        for _, ent in ipairs(entities) do\n            self:ProcessEntity(ent)\n        end\n    end)\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-entity-searches",children:"2. Entity Searches"}),"\n",(0,a.jsx)(n.p,{children:"Finding entities is an expensive operation, especially with large search radii:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Large radius, no necessary tags\nlocal entities = TheSim:FindEntities(x, y, z, 50)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Smaller radius, specific tags, excluded tags\nlocal entities = TheSim:FindEntities(x, y, z, 20, {"_combat"}, {"INLIMBO", "player", "wall"})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-event-handling",children:"3. Event Handling"}),"\n",(0,a.jsx)(n.p,{children:"Excessive event listeners can cause performance issues:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Listening to frequent events on many entities\nfor i = 1, 1000 do\n    local inst = SpawnPrefab("prefab")\n    inst:ListenForEvent("entitysleep", OnEntitySleep)\n    inst:ListenForEvent("entitywake", OnEntityWake)\n    inst:ListenForEvent("onremove", OnRemove)\n    -- More event listeners...\nend\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Use component system and targeted events\nfunction MyComponent:OnRemove()\n    -- Clean up event listeners when removed\n    if self.task then\n        self.task:Cancel()\n        self.task = nil\n    end\n    \n    if self.eventhook then\n        self.inst:RemoveEventCallback("entitysleep", self.eventhook)\n        self.eventhook = nil\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-memory-management",children:"4. Memory Management"}),"\n",(0,a.jsx)(n.p,{children:"Poor memory management can lead to leaks and degraded performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- INEFFICIENT: Creating new tables constantly\nfunction OnUpdate()\n    local data = {}\n    -- Fill data\n    return data\nend\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- OPTIMIZED: Reuse tables\nlocal data_pool = {}\n\nfunction GetDataFromPool()\n    local t = table.remove(data_pool) or {}\n    return t\nend\n\nfunction RecycleData(t)\n    table.clear(t)\n    table.insert(data_pool, t)\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-network-optimization",children:"5. Network Optimization"}),"\n",(0,a.jsx)(n.p,{children:"Networking is a critical area for optimization in multiplayer games:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Sending updates too frequently\nfunction Component:OnUpdate()\n    if TheWorld.ismastersim then\n        -- Send full state every frame\n        SendModRPCToClient(GetClientModRPC("MyMod", "SyncData"), player.userid, self.inst.GUID, json.encode(self.data))\n    end\nend\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- OPTIMIZED: Throttle updates and only send changes\nfunction Component:Init()\n    self.last_sync_time = 0\n    self.dirty = false\n    \n    self.inst:DoPeriodicTask(0.1, function()\n        if TheWorld.ismastersim and self.dirty and (self.last_sync_time + 0.5) < GetTime() then\n            -- Only send if data changed and not too recently\n            SendModRPCToClient(GetClientModRPC("MyMod", "SyncData"), player.userid, self.inst.GUID, json.encode(self.data))\n            self.last_sync_time = GetTime()\n            self.dirty = false\n        end\n    end)\nend\n\nfunction Component:SetValue(key, value)\n    if self.data[key] ~= value then\n        self.data[key] = value\n        self.dirty = true\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"practical-optimization-example-area-effect-system",children:"Practical Optimization Example: Area Effect System"}),"\n",(0,a.jsx)(n.p,{children:"Let's optimize a system that applies effects to entities in an area:"}),"\n",(0,a.jsx)(n.h3,{id:"unoptimized-version",children:"Unoptimized Version"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local AreaEffectComponent = Class(function(self, inst)\n    self.inst = inst\n    self.radius = 10\n    self.effect_fn = nil\n    \n    -- Update every frame\n    self.inst:DoTaskInTime(0, function()\n        self.updatetask = self.inst:DoPeriodicTask(0, function() self:ApplyEffect() end)\n    end)\nend)\n\nfunction AreaEffectComponent:ApplyEffect()\n    if not self.effect_fn then return end\n    \n    -- Find all entities every frame\n    local x, y, z = self.inst.Transform:GetWorldPosition()\n    local entities = TheSim:FindEntities(x, y, z, self.radius)\n    \n    -- Process each entity\n    for _, ent in ipairs(entities) do\n        self.effect_fn(ent)\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimized-version",children:"Optimized Version"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local AreaEffectComponent = Class(function(self, inst)\n    self.inst = inst\n    self.radius = 10\n    self.effect_fn = nil\n    self.affected_entities = {}\n    self.update_frequency = 0.5\n    \n    -- Start with a small delay to ensure all components are initialized\n    self.inst:DoTaskInTime(0.1, function()\n        -- Update less frequently\n        self.updatetask = self.inst:DoPeriodicTask(self.update_frequency, function() self:UpdateNearbyEntities() end)\n    end)\n    \n    -- Listen for removal to clean up\n    self.inst:ListenForEvent("onremove", function() self:OnRemove() end)\nend)\n\nfunction AreaEffectComponent:UpdateNearbyEntities()\n    local x, y, z = self.inst.Transform:GetWorldPosition()\n    \n    -- Use tags to filter entities more efficiently\n    local entities = TheSim:FindEntities(x, y, z, self.radius, nil, {"INLIMBO", "notarget"})\n    \n    -- Track which entities we\'ve seen this update\n    local seen_entities = {}\n    \n    -- Process only entities that need the effect\n    for _, ent in ipairs(entities) do\n        seen_entities[ent] = true\n        \n        -- Only apply effect if not already affected\n        if not self.affected_entities[ent] and self.effect_fn then\n            self.effect_fn(ent)\n            self.affected_entities[ent] = true\n            \n            -- Listen for entity removal to clean up our references\n            self.inst:ListenForEvent("onremove", function() \n                self.affected_entities[ent] = nil \n            end, ent)\n        end\n    end\n    \n    -- Remove effects from entities no longer in range\n    for ent in pairs(self.affected_entities) do\n        if not seen_entities[ent] then\n            -- Entity left radius, remove effect\n            if self.remove_effect_fn then\n                self.remove_effect_fn(ent)\n            end\n            self.affected_entities[ent] = nil\n        end\n    end\nend\n\nfunction AreaEffectComponent:OnRemove()\n    -- Clean up tasks\n    if self.updatetask then\n        self.updatetask:Cancel()\n        self.updatetask = nil\n    end\n    \n    -- Remove effects from all affected entities\n    if self.remove_effect_fn then\n        for ent in pairs(self.affected_entities) do\n            self.remove_effect_fn(ent)\n        end\n    end\n    \n    -- Clear table references\n    self.affected_entities = {}\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"profiling-and-debugging",children:"Profiling and Debugging"}),"\n",(0,a.jsx)(n.p,{children:"To identify performance bottlenecks, use these techniques:"}),"\n",(0,a.jsx)(n.h3,{id:"1-in-game-profiling",children:"1. In-Game Profiling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Add profiling to your mod\nlocal profile_start = os.clock()\n\n-- Code to profile\nlocal result = ExpensiveFunction()\n\nlocal duration = os.clock() - profile_start\nprint("Function took " .. duration .. " seconds")\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-frame-time-logging",children:"2. Frame Time Logging"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Log frame times to identify spikes\nlocal last_time = GetTime()\n\nAddPriorityPostInit(function()\n    -- Add a periodic task to check frame times\n    TheWorld:DoPeriodicTask(1, function()\n        local current_time = GetTime()\n        local frame_count = TheSim:GetFPS()\n        print("FPS: " .. frame_count .. ", Average frame time: " .. (1000/frame_count) .. "ms")\n        last_time = current_time\n    end)\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-memory-usage-tracking",children:"3. Memory Usage Tracking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Track memory usage\nlocal function GetMemoryUsage()\n    collectgarbage("collect")\n    return math.floor(collectgarbage("count"))\nend\n\nlocal initial_memory = GetMemoryUsage()\n\n-- After operations\nlocal current_memory = GetMemoryUsage()\nprint("Memory change: " .. (current_memory - initial_memory) .. " KB")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,a.jsx)(n.p,{children:"Use this checklist to ensure your mod is optimized:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Update Frequency"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use appropriate update intervals (not every frame)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Scale update frequency based on importance"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Consider using event-based updates instead of periodic when possible"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Entity Management"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Limit entity searches with appropriate tags and radius"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cache entity references when appropriate"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Clean up references when entities are removed"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Memory Usage"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Reuse tables and objects when possible"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Clear references in OnRemove functions"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Be careful with closures that capture large environments"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Network Optimization"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Only send data when it changes"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Throttle network updates"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Send delta updates instead of full state when possible"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Event Handling"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Remove event listeners when no longer needed"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use targeted events instead of global ones"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Avoid creating multiple listeners for the same event"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"case-study-optimizing-a-weather-effect-mod",children:"Case Study: Optimizing a Weather Effect Mod"}),"\n",(0,a.jsx)(n.p,{children:"Let's examine a real-world optimization of a weather effect mod:"}),"\n",(0,a.jsx)(n.h3,{id:"original-implementation",children:"Original Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Weather effect that spawns particles and affects players\nlocal WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    self.particles = {}\n    self.max_particles = 100\n    self.player_effect_radius = 30\n    \n    -- Update particles every frame\n    self.inst:DoPeriodicTask(0, function() self:UpdateParticles() end)\n    \n    -- Apply player effects every frame\n    self.inst:DoPeriodicTask(0, function() self:ApplyPlayerEffects() end)\nend)\n\nfunction WeatherSystem:UpdateParticles()\n    -- Spawn new particles\n    while #self.particles < self.max_particles do\n        local particle = self:SpawnParticle()\n        table.insert(self.particles, particle)\n    end\n    \n    -- Update all particles\n    for i, particle in ipairs(self.particles) do\n        if not self:UpdateParticle(particle) then\n            particle:Remove()\n            table.remove(self.particles, i)\n        end\n    end\nend\n\nfunction WeatherSystem:ApplyPlayerEffects()\n    -- Find all players\n    for _, player in ipairs(AllPlayers) do\n        -- Apply effects\n        self:ApplyEffectToPlayer(player)\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimized-implementation",children:"Optimized Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local WeatherSystem = Class(function(self, inst)\n    self.inst = inst\n    self.particles = {}\n    self.max_particles = 100\n    self.player_effect_radius = 30\n    self.particle_batch_size = 5\n    self.affected_players = {}\n    \n    -- Update particles in batches and less frequently\n    self.inst:DoPeriodicTask(0.1, function() self:UpdateParticles() end)\n    \n    -- Apply player effects less frequently\n    self.inst:DoPeriodicTask(0.5, function() self:ApplyPlayerEffects() end)\n    \n    -- Clean up on removal\n    self.inst:ListenForEvent("onremove", function() self:OnRemove() end)\nend)\n\nfunction WeatherSystem:UpdateParticles()\n    -- Spawn particles in small batches\n    local particles_to_spawn = math.min(self.particle_batch_size, self.max_particles - #self.particles)\n    for i = 1, particles_to_spawn do\n        local particle = self:SpawnParticle()\n        table.insert(self.particles, particle)\n    end\n    \n    -- Update only a subset of particles each frame\n    local start_index = self.last_updated_index or 1\n    local end_index = math.min(start_index + 20, #self.particles)\n    \n    for i = start_index, end_index do\n        local particle = self.particles[i]\n        if particle and particle:IsValid() then\n            if not self:UpdateParticle(particle) then\n                particle:Remove()\n                table.remove(self.particles, i)\n            end\n        else\n            table.remove(self.particles, i)\n        end\n    end\n    \n    -- Update index for next time\n    self.last_updated_index = end_index >= #self.particles and 1 or end_index + 1\nend\n\nfunction WeatherSystem:ApplyPlayerEffects()\n    -- Only process players that need updates\n    for _, player in ipairs(AllPlayers) do\n        local player_id = player.userid\n        \n        -- Check if player is in the affected area\n        if self:IsPlayerInEffectArea(player) then\n            -- Only apply if not already affected\n            if not self.affected_players[player_id] then\n                self:ApplyEffectToPlayer(player)\n                self.affected_players[player_id] = true\n                \n                -- Listen for player leaving\n                self.inst:ListenForEvent("onremove", function()\n                    self.affected_players[player_id] = nil\n                end, player)\n            end\n        else\n            -- Remove effect if player left the area\n            if self.affected_players[player_id] then\n                self:RemoveEffectFromPlayer(player)\n                self.affected_players[player_id] = nil\n            end\n        end\n    end\nend\n\nfunction WeatherSystem:OnRemove()\n    -- Clean up all particles\n    for _, particle in ipairs(self.particles) do\n        if particle:IsValid() then\n            particle:Remove()\n        end\n    end\n    self.particles = {}\n    \n    -- Remove effects from all players\n    for player_id, _ in pairs(self.affected_players) do\n        local player = UserToPlayer(player_id)\n        if player then\n            self:RemoveEffectFromPlayer(player)\n        end\n    end\n    self.affected_players = {}\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"caching-and-lazy-loading-techniques",children:"Caching and Lazy Loading Techniques"}),"\n",(0,a.jsx)(n.p,{children:"Caching and lazy loading are powerful techniques to improve performance by reducing redundant calculations and delaying resource-intensive operations until they're actually needed."}),"\n",(0,a.jsx)(n.h3,{id:"caching-expensive-calculations",children:"Caching Expensive Calculations"}),"\n",(0,a.jsx)(n.p,{children:"Caching stores the results of expensive operations for reuse:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Recalculating values repeatedly\nfunction Component:GetDamageMultiplier(target)\n    -- Complex calculation that depends on many factors\n    local base = self.base_damage\n    local day_mult = TheWorld.state.isday and 1.2 or 0.8\n    local health_mult = 1 + (1 - self.inst.components.health:GetPercent()) * 0.5\n    local target_resist = target:HasTag("metal") and 0.5 or 1\n    \n    -- This calculation is performed every time the function is called\n    return base * day_mult * health_mult * target_resist\nend\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimized Approach"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function Component:Init()\n    self.cached_damage_mult = nil\n    self.cached_damage_time = 0\n    \n    -- Listen for events that would invalidate the cache\n    self.inst:ListenForEvent("healthdelta", function() self:InvalidateDamageCache() end)\n    TheWorld:ListenForEvent("phasechanged", function() self:InvalidateDamageCache() end)\nend\n\nfunction Component:InvalidateDamageCache()\n    self.cached_damage_mult = nil\nend\n\nfunction Component:GetDamageMultiplier(target)\n    local target_type = target:HasTag("metal") and "metal" or "normal"\n    local current_time = GetTime()\n    \n    -- If cache is valid and less than 1 second old, use it\n    if self.cached_damage_mult and \n       self.cached_damage_mult[target_type] and \n       current_time - self.cached_damage_time < 1 then\n        return self.cached_damage_mult[target_type]\n    end\n    \n    -- Otherwise recalculate and cache the result\n    local base = self.base_damage\n    local day_mult = TheWorld.state.isday and 1.2 or 0.8\n    local health_mult = 1 + (1 - self.inst.components.health:GetPercent()) * 0.5\n    \n    -- Create cache table if it doesn\'t exist\n    self.cached_damage_mult = self.cached_damage_mult or {}\n    \n    -- Cache results for different target types\n    self.cached_damage_mult["metal"] = base * day_mult * health_mult * 0.5\n    self.cached_damage_mult["normal"] = base * day_mult * health_mult\n    self.cached_damage_time = current_time\n    \n    return self.cached_damage_mult[target_type]\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"path-caching",children:"Path Caching"}),"\n",(0,a.jsx)(n.p,{children:"For entities that frequently navigate between the same points:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local PathCache = Class(function(self)\n    self.paths = {}\n    self.max_paths = 50\n    self.path_lifetime = 30  -- seconds before a path is considered stale\nend)\n\nfunction PathCache:GetPathKey(start_x, start_z, end_x, end_z)\n    -- Round positions to reduce unique paths\n    local grid_size = 4\n    local sx = math.floor(start_x / grid_size) * grid_size\n    local sz = math.floor(start_z / grid_size) * grid_size\n    local ex = math.floor(end_x / grid_size) * grid_size\n    local ez = math.floor(end_z / grid_size) * grid_size\n    \n    return string.format("%d,%d_to_%d,%d", sx, sz, ex, ez)\nend\n\nfunction PathCache:GetPath(start_x, start_z, end_x, end_z)\n    local key = self:GetPathKey(start_x, start_z, end_x, end_z)\n    \n    if self.paths[key] and GetTime() - self.paths[key].time < self.path_lifetime then\n        -- Return cached path if it exists and isn\'t stale\n        return self.paths[key].path\n    end\n    \n    -- Path not in cache or stale, calculate new path\n    local path = self:CalculatePath(start_x, start_z, end_x, end_z)\n    \n    -- Store in cache\n    self.paths[key] = {\n        path = path,\n        time = GetTime()\n    }\n    \n    -- Limit cache size\n    self:EnforceCacheLimit()\n    \n    return path\nend\n\nfunction PathCache:EnforceCacheLimit()\n    -- If cache exceeds max size, remove oldest entries\n    local keys = {}\n    for k, v in pairs(self.paths) do\n        table.insert(keys, {key = k, time = v.time})\n    end\n    \n    if #keys > self.max_paths then\n        -- Sort by time, oldest first\n        table.sort(keys, function(a, b) return a.time < b.time end)\n        \n        -- Remove oldest entries\n        for i = 1, #keys - self.max_paths do\n            self.paths[keys[i].key] = nil\n        end\n    end\nend\n\nfunction PathCache:CalculatePath(start_x, start_z, end_x, end_z)\n    -- Your pathfinding algorithm here\n    -- ...\n    \n    -- Return calculated path\n    return path\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"lazy-loading-resources",children:"Lazy Loading Resources"}),"\n",(0,a.jsx)(n.p,{children:"Lazy loading defers loading resources until they're actually needed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local AssetManager = Class(function(self)\n    self.loaded_assets = {}\n    self.loading_assets = {}\n    self.callbacks = {}\nend)\n\nfunction AssetManager:GetAsset(name, callback)\n    -- If already loaded, return immediately\n    if self.loaded_assets[name] then\n        if callback then\n            callback(self.loaded_assets[name])\n        end\n        return self.loaded_assets[name]\n    end\n    \n    -- If currently loading, add callback to queue\n    if self.loading_assets[name] then\n        if callback then\n            table.insert(self.callbacks[name], callback)\n        end\n        return nil\n    end\n    \n    -- Start loading the asset\n    self.loading_assets[name] = true\n    self.callbacks[name] = self.callbacks[name] or {}\n    \n    if callback then\n        table.insert(self.callbacks[name], callback)\n    end\n    \n    -- Simulate asset loading (in a real mod, this would be TheSim:LoadPrefabs or similar)\n    TheWorld:DoTaskInTime(0.1, function()\n        -- Asset loaded\n        self.loaded_assets[name] = {name = name, data = "asset_data"}\n        self.loading_assets[name] = nil\n        \n        -- Call all waiting callbacks\n        for _, cb in ipairs(self.callbacks[name]) do\n            cb(self.loaded_assets[name])\n        end\n        self.callbacks[name] = {}\n    end)\n    \n    return nil\nend\n\nfunction AssetManager:UnloadAsset(name)\n    self.loaded_assets[name] = nil\nend\n\n-- Usage example\nlocal asset_manager = AssetManager()\n\n-- First request starts loading\nasset_manager:GetAsset("special_effect", function(asset)\n    print("Asset loaded:", asset.name)\nend)\n\n-- Second request will use the same loading operation\nasset_manager:GetAsset("special_effect", function(asset)\n    print("Also got the asset:", asset.name)\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"component-state-caching",children:"Component State Caching"}),"\n",(0,a.jsx)(n.p,{children:"Cache component states to avoid repeated component lookups:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- INEFFICIENT: Checking component states repeatedly\nfunction OnUpdate()\n    for _, ent in ipairs(targets) do\n        -- These component checks happen every update\n        if ent.components.health and not ent.components.health:IsDead() and\n           ent.components.combat and ent.components.combat:CanTarget(self.inst) then\n            -- Do something with valid target\n        end\n    end\nend\n\n-- OPTIMIZED: Cache component states\nfunction CacheTargetStates()\n    self.valid_targets = {}\n    \n    for _, ent in ipairs(targets) do\n        if ent.components.health and not ent.components.health:IsDead() and\n           ent.components.combat and ent.components.combat:CanTarget(self.inst) then\n            -- Cache the valid target\n            self.valid_targets[ent] = true\n            \n            -- Listen for events that would invalidate this target\n            self.inst:ListenForEvent("death", function()\n                self.valid_targets[ent] = nil\n            end, ent)\n        end\n    end\nend\n\nfunction OnUpdate()\n    -- Use cached valid targets\n    for ent in pairs(self.valid_targets) do\n        -- Do something with valid target\n    end\n    \n    -- Only rebuild cache occasionally\n    self.cache_timer = self.cache_timer - dt\n    if self.cache_timer <= 0 then\n        self.cache_timer = 2  -- Rebuild cache every 2 seconds\n        CacheTargetStates()\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"deferred-initialization",children:"Deferred Initialization"}),"\n",(0,a.jsx)(n.p,{children:"Defer creating expensive resources until they're needed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local ExpensiveComponent = Class(function(self, inst)\n    self.inst = inst\n    self.initialized = false\n    \n    -- Don't initialize expensive resources immediately\n    -- They'll be created on first use\nend)\n\nfunction ExpensiveComponent:LazyInit()\n    if not self.initialized then\n        -- Create expensive resources only when first needed\n        self.data_structure = self:BuildExpensiveDataStructure()\n        self.render_assets = self:LoadExpensiveAssets()\n        self.initialized = true\n    end\nend\n\nfunction ExpensiveComponent:DoSomething()\n    -- Ensure initialization before use\n    self:LazyInit()\n    \n    -- Now use the expensive resources\n    -- ...\nend\n\n-- Cleanup properly\nfunction ExpensiveComponent:OnRemove()\n    if self.initialized then\n        -- Only clean up if we actually initialized\n        self:CleanupExpensiveResources()\n    end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"incremental-loading",children:"Incremental Loading"}),"\n",(0,a.jsx)(n.p,{children:"For very large mods, load content incrementally to avoid freezing the game:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local ModLoader = Class(function(self)\n    self.load_queue = {}\n    self.is_loading = false\n    self.items_per_batch = 5\nend)\n\nfunction ModLoader:QueueContent(items)\n    for _, item in ipairs(items) do\n        table.insert(self.load_queue, item)\n    end\n    \n    -- Start loading if not already in progress\n    if not self.is_loading then\n        self:LoadNextBatch()\n    end\nend\n\nfunction ModLoader:LoadNextBatch()\n    if #self.load_queue == 0 then\n        self.is_loading = false\n        if self.on_complete then\n            self.on_complete()\n        end\n        return\n    end\n    \n    self.is_loading = true\n    local batch = {}\n    \n    -- Take a batch of items to load\n    for i = 1, math.min(self.items_per_batch, #self.load_queue) do\n        table.insert(batch, table.remove(self.load_queue, 1))\n    end\n    \n    -- Load this batch\n    for _, item in ipairs(batch) do\n        self:LoadItem(item)\n    end\n    \n    -- Schedule next batch\n    TheWorld:DoTaskInTime(0.1, function()\n        self:LoadNextBatch()\n    end)\nend\n\nfunction ModLoader:LoadItem(item)\n    -- Load individual item\n    print("Loading:", item)\n    -- Your loading logic here\nend\n\n-- Usage\nlocal loader = ModLoader()\nloader.on_complete = function()\n    print("All content loaded!")\nend\n\n-- Queue 100 items to load\nlocal items = {}\nfor i = 1, 100 do\n    table.insert(items, "item_" .. i)\nend\n\nloader:QueueContent(items)\n'})}),"\n",(0,a.jsx)(n.p,{children:"Implementing these caching and lazy loading techniques can significantly improve your mod's performance, especially for complex mods with many entities or resource-intensive operations."}),"\n",(0,a.jsx)(n.h2,{id:"working-with-many-entities",children:"Working with Many Entities"}),"\n",(0,a.jsx)(n.p,{children:"When your mod needs to manage a large number of entities, performance can degrade quickly. Here are specific strategies for optimizing mods that work with many entities:"}),"\n",(0,a.jsx)(n.h3,{id:"entity-pooling",children:"Entity Pooling"}),"\n",(0,a.jsx)(n.p,{children:"Instead of constantly creating and destroying entities, reuse them with an entity pool:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create an entity pool manager\nlocal EntityPool = Class(function(self)\n    self.inactive_entities = {}\n    self.active_entities = {}\n    self.prefab_name = "my_effect"\nend)\n\nfunction EntityPool:GetEntity()\n    -- Reuse an inactive entity if available\n    if #self.inactive_entities > 0 then\n        local entity = table.remove(self.inactive_entities)\n        table.insert(self.active_entities, entity)\n        entity:Show()\n        return entity\n    end\n    \n    -- Create a new entity if needed\n    local entity = SpawnPrefab(self.prefab_name)\n    table.insert(self.active_entities, entity)\n    return entity\nend\n\nfunction EntityPool:ReleaseEntity(entity)\n    -- Find and remove from active list\n    for i, e in ipairs(self.active_entities) do\n        if e == entity then\n            table.remove(self.active_entities, i)\n            break\n        end\n    end\n    \n    -- Hide instead of destroying\n    entity:Hide()\n    table.insert(self.inactive_entities, entity)\nend\n\nfunction EntityPool:ReleaseAll()\n    -- Move all active entities to inactive\n    for i = #self.active_entities, 1, -1 do\n        local entity = self.active_entities[i]\n        table.remove(self.active_entities, i)\n        entity:Hide()\n        table.insert(self.inactive_entities, entity)\n    end\nend\n\nfunction EntityPool:DestroyAll()\n    -- Clean up all entities when no longer needed\n    for _, entity in ipairs(self.active_entities) do\n        entity:Remove()\n    end\n    self.active_entities = {}\n    \n    for _, entity in ipairs(self.inactive_entities) do\n        entity:Remove()\n    end\n    self.inactive_entities = {}\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"spatial-partitioning",children:"Spatial Partitioning"}),"\n",(0,a.jsx)(n.p,{children:"For large worlds with many entities, use spatial partitioning to only process entities in relevant areas:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Simple grid-based spatial partitioning\nlocal SpatialGrid = Class(function(self, cell_size)\n    self.cell_size = cell_size or 10\n    self.grid = {}\nend)\n\nfunction SpatialGrid:GetCellKey(x, z)\n    local cell_x = math.floor(x / self.cell_size)\n    local cell_z = math.floor(z / self.cell_size)\n    return cell_x .. "," .. cell_z\nend\n\nfunction SpatialGrid:AddEntity(entity)\n    local x, y, z = entity.Transform:GetWorldPosition()\n    local cell_key = self:GetCellKey(x, z)\n    \n    self.grid[cell_key] = self.grid[cell_key] or {}\n    table.insert(self.grid[cell_key], entity)\n    \n    -- Store the cell key with the entity for quick removal\n    entity._grid_cell_key = cell_key\nend\n\nfunction SpatialGrid:RemoveEntity(entity)\n    local cell_key = entity._grid_cell_key\n    if cell_key and self.grid[cell_key] then\n        for i, e in ipairs(self.grid[cell_key]) do\n            if e == entity then\n                table.remove(self.grid[cell_key], i)\n                entity._grid_cell_key = nil\n                break\n            end\n        end\n    end\nend\n\nfunction SpatialGrid:GetEntitiesInRadius(x, z, radius)\n    local result = {}\n    local r_cells = math.ceil(radius / self.cell_size)\n    \n    local center_x = math.floor(x / self.cell_size)\n    local center_z = math.floor(z / self.cell_size)\n    \n    -- Check cells in a square area (could be optimized to a circle)\n    for cell_x = center_x - r_cells, center_x + r_cells do\n        for cell_z = center_z - r_cells, center_z + r_cells do\n            local cell_key = cell_x .. "," .. cell_z\n            if self.grid[cell_key] then\n                for _, entity in ipairs(self.grid[cell_key]) do\n                    local ex, _, ez = entity.Transform:GetWorldPosition()\n                    local dist_sq = (ex - x)^2 + (ez - z)^2\n                    if dist_sq <= radius * radius then\n                        table.insert(result, entity)\n                    end\n                end\n            end\n        end\n    end\n    \n    return result\nend\n\nfunction SpatialGrid:UpdateEntityPosition(entity)\n    -- Remove from old cell\n    self:RemoveEntity(entity)\n    -- Add to new cell\n    self:AddEntity(entity)\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"batched-processing",children:"Batched Processing"}),"\n",(0,a.jsx)(n.p,{children:"Process entities in smaller batches over multiple frames:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local EntityManager = Class(function(self, inst)\n    self.inst = inst\n    self.entities = {}\n    self.batch_size = 20\n    self.current_index = 1\n    \n    -- Process entities in batches\n    self.task = self.inst:DoPeriodicTask(0.1, function() self:ProcessBatch() end)\nend)\n\nfunction EntityManager:AddEntity(entity)\n    table.insert(self.entities, entity)\nend\n\nfunction EntityManager:ProcessBatch()\n    local count = 0\n    local start_index = self.current_index\n    \n    while count < self.batch_size and count < #self.entities do\n        local entity_index = ((start_index + count - 1) % #self.entities) + 1\n        local entity = self.entities[entity_index]\n        \n        if entity:IsValid() then\n            self:ProcessEntity(entity)\n        else\n            -- Remove invalid entities\n            table.remove(self.entities, entity_index)\n            -- Adjust indices to account for removal\n            if entity_index <= start_index then\n                start_index = math.max(1, start_index - 1)\n            end\n        end\n        \n        count = count + 1\n    end\n    \n    -- Update the index for next batch\n    self.current_index = ((start_index + count - 1) % #self.entities) + 1\nend\n\nfunction EntityManager:ProcessEntity(entity)\n    -- Your processing logic here\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"level-of-detail-lod",children:"Level of Detail (LOD)"}),"\n",(0,a.jsx)(n.p,{children:"Implement different levels of detail based on distance from the player:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"function UpdateEntityLOD(entity, player_pos)\n    local x, y, z = entity.Transform:GetWorldPosition()\n    local dist_sq = (x - player_pos.x)^2 + (z - player_pos.z)^2\n    \n    if dist_sq < 10*10 then\n        -- High detail - full updates\n        entity.components.mycomponent:SetUpdateFrequency(0.1)\n        entity.components.mycomponent:EnableEffects(true)\n    elseif dist_sq < 30*30 then\n        -- Medium detail - less frequent updates\n        entity.components.mycomponent:SetUpdateFrequency(0.5)\n        entity.components.mycomponent:EnableEffects(true)\n    else\n        -- Low detail - minimal updates, disable effects\n        entity.components.mycomponent:SetUpdateFrequency(1.0)\n        entity.components.mycomponent:EnableEffects(false)\n    end\nend\n\n-- Apply LOD to all entities periodically\nTheWorld:DoPeriodicTask(1, function()\n    if AllPlayers[1] then\n        local player_pos = Vector3(AllPlayers[1].Transform:GetWorldPosition())\n        \n        for _, entity in pairs(my_entities) do\n            UpdateEntityLOD(entity, player_pos)\n        end\n    end\nend)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"instanced-rendering",children:"Instanced Rendering"}),"\n",(0,a.jsx)(n.p,{children:"For visual effects, use instanced rendering when possible:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create a single master entity that manages many visual instances\nlocal EffectManager = Class(function(self, inst)\n    self.inst = inst\n    self.positions = {}\n    self.max_instances = 100\n    \n    -- Set up the master effect\n    self.fx_entity = SpawnPrefab("my_effect_master")\n    \n    -- Update instance positions\n    self.inst:DoPeriodicTask(0.1, function() self:UpdateInstances() end)\nend)\n\nfunction EffectManager:AddEffectAt(x, y, z)\n    if #self.positions >= self.max_instances then\n        -- Reuse the oldest position\n        table.remove(self.positions, 1)\n    end\n    \n    table.insert(self.positions, Vector3(x, y, z))\nend\n\nfunction EffectManager:UpdateInstances()\n    -- Send positions to the master effect entity\n    if self.fx_entity.components.instancedeffects then\n        self.fx_entity.components.instancedeffects:SetPositions(self.positions)\n    end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"entity-culling",children:"Entity Culling"}),"\n",(0,a.jsx)(n.p,{children:"Only process entities that are relevant to the current game state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'function ShouldProcessEntity(entity)\n    -- Skip entities that are sleeping or in limbo\n    if entity:IsAsleep() or entity:HasTag("INLIMBO") then\n        return false\n    end\n    \n    -- Skip entities too far from any player\n    local closest_dist_sq = math.huge\n    local x, y, z = entity.Transform:GetWorldPosition()\n    \n    for _, player in ipairs(AllPlayers) do\n        local px, py, pz = player.Transform:GetWorldPosition()\n        local dist_sq = (x - px)^2 + (z - pz)^2\n        closest_dist_sq = math.min(closest_dist_sq, dist_sq)\n    end\n    \n    -- Only process if within 50 units of a player\n    return closest_dist_sq < 50*50\nend\n\n-- Apply culling to entity updates\nTheWorld:DoPeriodicTask(0.2, function()\n    for _, entity in pairs(my_entities) do\n        entity.components.mycomponent.enabled = ShouldProcessEntity(entity)\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"centralized-manager",children:"Centralized Manager"}),"\n",(0,a.jsx)(n.p,{children:"Use a centralized manager instead of individual component updates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Create a global manager for a specific entity type\nlocal MyEntityManager = Class(function(self, inst)\n    self.inst = inst\n    self.entities = {}\n    \n    -- Process all entities at once\n    self.inst:DoPeriodicTask(0.2, function() self:UpdateAll() end)\nend)\n\nfunction MyEntityManager:Register(entity)\n    self.entities[entity] = true\n    \n    entity:ListenForEvent("onremove", function()\n        self.entities[entity] = nil\n    end)\nend\n\nfunction MyEntityManager:UpdateAll()\n    local player_positions = {}\n    for _, player in ipairs(AllPlayers) do\n        table.insert(player_positions, Vector3(player.Transform:GetWorldPosition()))\n    end\n    \n    -- Process all entities with shared data\n    for entity in pairs(self.entities) do\n        if entity:IsValid() then\n            self:ProcessEntity(entity, player_positions)\n        else\n            self.entities[entity] = nil\n        end\n    end\nend\n\nfunction MyEntityManager:ProcessEntity(entity, player_positions)\n    -- Shared processing logic\nend\n\n-- Create the global manager\nAddPrefabPostInit("world", function(inst)\n    if TheWorld.ismastersim then\n        TheWorld.my_entity_manager = MyEntityManager(inst)\n    end\nend)\n\n-- Register entities with the manager\nAddPrefabPostInit("my_entity", function(inst)\n    if TheWorld.ismastersim and TheWorld.my_entity_manager then\n        TheWorld.my_entity_manager:Register(inst)\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.p,{children:"By implementing these strategies, your mod can efficiently handle hundreds or even thousands of entities without causing significant performance issues."}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Optimizing your mods is essential for providing a good experience to players. By following these techniques, you can create complex mods that run efficiently even on lower-end hardware and servers."}),"\n",(0,a.jsx)(n.p,{children:"Remember these key principles:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Only update what needs updating, when it needs updating"}),"\n",(0,a.jsx)(n.li,{children:"Be mindful of expensive operations like entity searches"}),"\n",(0,a.jsx)(n.li,{children:"Clean up after yourself to prevent memory leaks"}),"\n",(0,a.jsx)(n.li,{children:"Use network bandwidth efficiently"}),"\n",(0,a.jsx)(n.li,{children:"Profile your code to identify bottlenecks"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By applying these optimization techniques, you'll create mods that players can enjoy without sacrificing performance."})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);