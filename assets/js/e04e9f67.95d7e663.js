"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[493],{2828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api-vanilla/examples/custom-game-mode","title":"Designing Custom Game Modes","description":"This guide focuses on creating custom game modes for Don\'t Starve Together. Custom game modes allow you to fundamentally change how the game is played by altering core mechanics, win conditions, player interactions, and world generation.","source":"@site/docs/api-vanilla/examples/custom-game-mode.md","sourceDirName":"api-vanilla/examples","slug":"/api-vanilla/examples/custom-game-mode","permalink":"/dst-api-webdocs/docs/api-vanilla/examples/custom-game-mode","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"id":"custom-game-mode","title":"Designing Custom Game Modes","sidebar_position":15}}');var r=t(4848),o=t(8453);const a={id:"custom-game-mode",title:"Designing Custom Game Modes",sidebar_position:15},i="Designing Custom Game Modes",l={},d=[{value:"Understanding Game Modes in DST",id:"understanding-game-modes-in-dst",level:2},{value:"Basic Game Mode Structure",id:"basic-game-mode-structure",level:2},{value:"Creating a Simple Game Mode",id:"creating-a-simple-game-mode",level:2},{value:"Game Mode Configuration",id:"game-mode-configuration",level:2},{value:"Custom World Generation",id:"custom-world-generation",level:2},{value:"Custom UI for Game Modes",id:"custom-ui-for-game-modes",level:2},{value:"Win Conditions and Game Rules",id:"win-conditions-and-game-rules",level:2},{value:"Custom Events and Challenges",id:"custom-events-and-challenges",level:2},{value:"Team-Based Game Modes",id:"team-based-game-modes",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging Tips",id:"debugging-tips",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"designing-custom-game-modes",children:"Designing Custom Game Modes"})}),"\n",(0,r.jsx)(n.p,{children:"This guide focuses on creating custom game modes for Don't Starve Together. Custom game modes allow you to fundamentally change how the game is played by altering core mechanics, win conditions, player interactions, and world generation."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-game-modes-in-dst",children:"Understanding Game Modes in DST"}),"\n",(0,r.jsx)(n.p,{children:"Don't Starve Together has several built-in game modes that serve as examples:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Survival"}),": The standard endless survival experience"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wilderness"}),": Players respawn at random locations when they die"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Endless"}),": Players can respawn at the portal without world regeneration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lavaarena"}),": A combat-focused arena mode (special event)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quagmire"}),": A cooking-focused mode (special event)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Custom game modes allow you to create entirely new ways to play, such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Competitive team-based modes"}),"\n",(0,r.jsx)(n.li,{children:"Goal-oriented challenges with win conditions"}),"\n",(0,r.jsx)(n.li,{children:"Specialized survival scenarios with unique rules"}),"\n",(0,r.jsx)(n.li,{children:"Story-driven experiences with custom progression"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-game-mode-structure",children:"Basic Game Mode Structure"}),"\n",(0,r.jsx)(n.p,{children:"A custom game mode typically requires:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A mod main file that defines the game mode"}),"\n",(0,r.jsx)(n.li,{children:"Custom world generation settings"}),"\n",(0,r.jsx)(n.li,{children:"Modified game mechanics"}),"\n",(0,r.jsx)(n.li,{children:"Custom UI elements for game mode information"}),"\n",(0,r.jsx)(n.li,{children:"Win/loss conditions (optional)"}),"\n",(0,r.jsx)(n.li,{children:"Custom scoring or progression systems (optional)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-simple-game-mode",children:"Creating a Simple Game Mode"}),"\n",(0,r.jsx)(n.p,{children:'Let\'s create a basic "Resource Race" game mode where players compete to collect resources:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\nlocal GAME_MODE_NAME = "RESOURCE_RACE"\nlocal GAME_MODE_DESCRIPTION = "Collect resources faster than other players!"\nlocal GAME_MODE_DURATION = TUNING.TOTAL_DAY_TIME * 10 -- 10 days\n\n-- Register the game mode\nAddGameMode(GAME_MODE_NAME, {\n    name = GAME_MODE_NAME,\n    description = GAME_MODE_DESCRIPTION,\n    duration = GAME_MODE_DURATION,\n    override_normal_game = true,\n})\n\n-- Game mode initialization\nlocal function InitGameMode(inst)\n    if TheWorld.ismastersim then\n        -- Set up resource targets\n        TheWorld.resource_targets = {\n            ["log"] = 50,\n            ["rocks"] = 30,\n            ["cutgrass"] = 100,\n            ["twigs"] = 100,\n        }\n        \n        -- Set up player scores\n        TheWorld.player_scores = {}\n        \n        -- Set game end time\n        TheWorld.end_time = GetTime() + GAME_MODE_DURATION\n        \n        -- Announce game start\n        TheNet:Announce("Resource Race has begun! Collect resources to win!")\n    end\nend\n\n-- Hook into world creation\nAddPrefabPostInit("world", function(inst)\n    if TheWorld.ismastersim and TheNet:GetServerGameMode() == GAME_MODE_NAME then\n        InitGameMode(inst)\n        \n        -- Set up periodic score updates\n        inst:DoPeriodicTask(1, function()\n            UpdateScores()\n            CheckGameEnd()\n        end)\n    end\nend)\n\n-- Track resource collection\nlocal function OnPickup(inst, data)\n    if TheWorld.ismastersim and TheNet:GetServerGameMode() == GAME_MODE_NAME then\n        local item = data.item\n        local player = inst\n        \n        if not TheWorld.player_scores[player.userid] then\n            TheWorld.player_scores[player.userid] = {\n                name = player.name,\n                resources = {},\n                total_points = 0\n            }\n        end\n        \n        local player_score = TheWorld.player_scores[player.userid]\n        \n        -- Check if the item is a target resource\n        if TheWorld.resource_targets[item.prefab] then\n            player_score.resources[item.prefab] = (player_score.resources[item.prefab] or 0) + 1\n            player_score.total_points = player_score.total_points + 1\n            \n            -- Announce milestones\n            if player_score.total_points % 25 == 0 then\n                TheNet:Announce(player.name .. " has collected " .. player_score.total_points .. " resources!")\n            end\n        end\n    end\nend\n\n-- Listen for item pickups\nAddPlayerPostInit(function(inst)\n    inst:ListenForEvent("itemget", function(inst, data)\n        OnPickup(inst, data)\n    end)\nend)\n\n-- Update scores and check for game end\nfunction UpdateScores()\n    -- Send score updates to clients\n    for i, player in ipairs(AllPlayers) do\n        if TheWorld.player_scores[player.userid] then\n            SendModRPCToClient(GetClientModRPC("ResourceRace", "SyncScore"), \n                player.userid, \n                json.encode(TheWorld.player_scores))\n        end\n    end\nend\n\nfunction CheckGameEnd()\n    local current_time = GetTime()\n    \n    -- Check if time is up\n    if current_time >= TheWorld.end_time then\n        -- Find the winner\n        local highest_score = 0\n        local winner = nil\n        \n        for userid, score_data in pairs(TheWorld.player_scores) do\n            if score_data.total_points > highest_score then\n                highest_score = score_data.total_points\n                winner = score_data.name\n            end\n        end\n        \n        -- Announce winner\n        if winner then\n            TheNet:Announce("Game Over! " .. winner .. " wins with " .. highest_score .. " resources!")\n        else\n            TheNet:Announce("Game Over! It\'s a tie!")\n        end\n        \n        -- Reset the world after a delay\n        TheWorld:DoTaskInTime(10, function()\n            TheNet:SendWorldResetRequestToServer()\n        end)\n    end\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"game-mode-configuration",children:"Game Mode Configuration"}),"\n",(0,r.jsx)(n.p,{children:"To make your game mode configurable, add options to the mod configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In modinfo.lua\nname = "Resource Race"\ndescription = "A competitive resource gathering game mode"\nauthor = "Your Name"\nversion = "1.0"\n\n-- Game mode configuration options\nconfiguration_options = {\n    {\n        name = "game_duration",\n        label = "Game Duration",\n        options = {\n            {description = "5 Days", data = 5},\n            {description = "10 Days", data = 10},\n            {description = "20 Days", data = 20},\n        },\n        default = 10,\n    },\n    {\n        name = "resource_targets",\n        label = "Resource Targets",\n        options = {\n            {description = "Easy", data = "easy"},\n            {description = "Normal", data = "normal"},\n            {description = "Hard", data = "hard"},\n        },\n        default = "normal",\n    },\n}\n\n-- Then in modmain.lua, use these settings:\nlocal GAME_DURATION = GetModConfigData("game_duration") * TUNING.TOTAL_DAY_TIME\nlocal DIFFICULTY = GetModConfigData("resource_targets")\n\n-- Set resource targets based on difficulty\nlocal resource_targets = {\n    easy = {\n        ["log"] = 30,\n        ["rocks"] = 20,\n        -- etc.\n    },\n    normal = {\n        ["log"] = 50,\n        ["rocks"] = 30,\n        -- etc.\n    },\n    hard = {\n        ["log"] = 80,\n        ["rocks"] = 50,\n        -- etc.\n    },\n}\n\nTheWorld.resource_targets = resource_targets[DIFFICULTY]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"custom-world-generation",children:"Custom World Generation"}),"\n",(0,r.jsx)(n.p,{children:"Game modes often require specialized world generation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\n-- Override world generation settings\nGLOBAL.TUNING.RESOURCERACE_WORLDGEN = {\n    -- Modify world size\n    override_size = "medium",\n    \n    -- Modify resource distribution\n    resources = {\n        flint = "many",\n        rocks = "many",\n        trees = "many",\n    },\n    \n    -- Modify creature spawns\n    monsters = "few",\n    \n    -- Add special structures\n    add_prefabs = {\n        "scorekeeper",\n        "resourcechest",\n    },\n}\n\n-- Apply world generation overrides\nAddLevelPreInit("SURVIVAL_TOGETHER", function(level)\n    if TheNet:GetServerGameMode() == "RESOURCE_RACE" then\n        level.overrides = GLOBAL.TUNING.RESOURCERACE_WORLDGEN\n    end\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"custom-ui-for-game-modes",children:"Custom UI for Game Modes"}),"\n",(0,r.jsx)(n.p,{children:"Create a custom UI to display game information:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In scripts/widgets/resourceracescore.lua\nlocal Widget = require "widgets/widget"\nlocal Text = require "widgets/text"\nlocal Image = require "widgets/image"\nlocal TEMPLATES = require "widgets/redux/templates"\n\nlocal ResourceRaceScore = Class(Widget, function(self, owner)\n    Widget._ctor(self, "ResourceRaceScore")\n    self.owner = owner\n    \n    -- Create background panel\n    self.root = self:AddChild(TEMPLATES.CurlyWindow(200, 300, "Resource Race", nil, nil, ""))\n    \n    -- Add timer\n    self.timer_text = self.root:AddChild(Text(BODYTEXTFONT, 30))\n    self.timer_text:SetPosition(0, 120, 0)\n    self.timer_text:SetString("Time Left: 10:00")\n    \n    -- Add score list\n    self.score_root = self.root:AddChild(Widget("score_root"))\n    self.score_root:SetPosition(0, 0, 0)\n    \n    -- Initialize scores\n    self.scores = {}\n    self:UpdateScores({})\n    \n    -- Start update loop\n    self:StartUpdating()\nend)\n\nfunction ResourceRaceScore:UpdateScores(score_data)\n    -- Clear existing score widgets\n    self.score_root:KillAllChildren()\n    \n    -- Create ordered list of players by score\n    local players = {}\n    for userid, data in pairs(score_data) do\n        table.insert(players, data)\n    end\n    \n    -- Sort by total points\n    table.sort(players, function(a, b) return a.total_points > b.total_points end)\n    \n    -- Create score entries\n    for i, player_data in ipairs(players) do\n        local y_pos = 80 - (i * 40)\n        \n        -- Player name\n        local name_text = self.score_root:AddChild(Text(BODYTEXTFONT, 20))\n        name_text:SetPosition(-70, y_pos, 0)\n        name_text:SetString(player_data.name)\n        name_text:SetHAlign(ANCHOR_LEFT)\n        \n        -- Player score\n        local score_text = self.score_root:AddChild(Text(BODYTEXTFONT, 20))\n        score_text:SetPosition(70, y_pos, 0)\n        score_text:SetString(tostring(player_data.total_points))\n        score_text:SetHAlign(ANCHOR_RIGHT)\n    end\nend\n\nfunction ResourceRaceScore:OnUpdate(dt)\n    if TheWorld.end_time then\n        local time_left = math.max(0, TheWorld.end_time - GetTime())\n        local minutes = math.floor(time_left / 60)\n        local seconds = math.floor(time_left % 60)\n        self.timer_text:SetString(string.format("Time Left: %02d:%02d", minutes, seconds))\n    end\nend\n\nreturn ResourceRaceScore\n\n-- Then in modmain.lua:\nAddClassPostConstruct("widgets/controls", function(self)\n    if TheNet:GetServerGameMode() == "RESOURCE_RACE" then\n        self.resourcerace = self:AddChild(require("widgets/resourceracescore")(self.owner))\n        self.resourcerace:SetPosition(200, -15, 0)\n    end\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"win-conditions-and-game-rules",children:"Win Conditions and Game Rules"}),"\n",(0,r.jsx)(n.p,{children:"Define custom win conditions and rules for your game mode:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\n-- Different types of win conditions\nlocal WIN_CONDITIONS = {\n    -- Time-based: Player with most resources when time expires wins\n    time_based = function()\n        return GetTime() >= TheWorld.end_time\n    end,\n    \n    -- Target-based: First player to reach target amount wins\n    target_based = function()\n        for userid, score_data in pairs(TheWorld.player_scores) do\n            if score_data.total_points >= TheWorld.target_score then\n                return true, score_data.name\n            end\n        end\n        return false\n    end,\n    \n    -- Survival-based: Last player/team standing wins\n    survival_based = function()\n        local teams_alive = {}\n        for i, player in ipairs(AllPlayers) do\n            if not player:HasTag("playerghost") then\n                teams_alive[player.components.teamleader.teamID] = true\n            end\n        end\n        \n        local count = 0\n        for _ in pairs(teams_alive) do count = count + 1 end\n        \n        if count <= 1 then\n            -- Find the surviving team\n            for team_id in pairs(teams_alive) do\n                return true, "Team " .. team_id\n            end\n            return true, "No one" -- All teams dead\n        end\n        \n        return false\n    end\n}\n\n-- Set the active win condition\nTheWorld.win_condition = WIN_CONDITIONS.time_based\n\n-- Custom game rules\nlocal GAME_RULES = {\n    -- PvP enabled\n    pvp_enabled = true,\n    \n    -- Respawn settings\n    respawn_enabled = true,\n    respawn_time = 30,\n    \n    -- Resource settings\n    resource_multiplier = 1.5,\n    \n    -- Special rules\n    drop_items_on_death = true,\n    night_always = false,\n    eternal_summer = true,\n}\n\n-- Apply game rules\nlocal function ApplyGameRules(inst)\n    if TheWorld.ismastersim and TheNet:GetServerGameMode() == "RESOURCE_RACE" then\n        -- Set PvP mode\n        TheNet:SetAllowPvP(GAME_RULES.pvp_enabled)\n        \n        -- Set respawn settings\n        TheWorld:PushEvent("ms_setrespawntime", GAME_RULES.respawn_time)\n        \n        -- Apply special rules\n        if GAME_RULES.eternal_summer then\n            TheWorld:PushEvent("ms_setseason", "summer")\n            TheWorld:PushEvent("ms_setseasonlength", {summer=999, autumn=1, winter=1, spring=1})\n        end\n        \n        if GAME_RULES.night_always then\n            TheWorld:PushEvent("ms_setphase", "night")\n            TheWorld:PushEvent("ms_setclocksegs", {day=0, dusk=0, night=16})\n        end\n    end\nend\n\n-- Apply rules on world initialization\nAddPrefabPostInit("world", ApplyGameRules)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"custom-events-and-challenges",children:"Custom Events and Challenges"}),"\n",(0,r.jsx)(n.p,{children:"Add dynamic events to keep your game mode interesting:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In scripts/prefabs/resourcerace_events.lua\nlocal Events = {\n    -- Double points event\n    double_points = {\n        name = "Double Points",\n        duration = 60,\n        start = function()\n            TheWorld.point_multiplier = 2\n            TheNet:Announce("Double Points activated for 60 seconds!")\n        end,\n        finish = function()\n            TheWorld.point_multiplier = 1\n            TheNet:Announce("Double Points has ended!")\n        end,\n    },\n    \n    -- Resource drop event\n    resource_drop = {\n        name = "Resource Shower",\n        duration = 30,\n        start = function()\n            TheNet:Announce("Resource Shower started! Look for falling resources!")\n            \n            -- Spawn resources around players\n            for i, player in ipairs(AllPlayers) do\n                local x, y, z = player.Transform:GetWorldPosition()\n                \n                for j = 1, 10 do\n                    local angle = math.random() * 2 * PI\n                    local dist = 5 + math.random() * 10\n                    local drop_x = x + math.cos(angle) * dist\n                    local drop_z = z + math.sin(angle) * dist\n                    \n                    -- Choose a random resource\n                    local resources = {"log", "rocks", "cutgrass", "twigs"}\n                    local resource = resources[math.random(#resources)]\n                    \n                    -- Spawn with a delay for visual effect\n                    TheWorld:DoTaskInTime(j * 0.5, function()\n                        local item = SpawnPrefab(resource)\n                        if item then\n                            item.Transform:SetPosition(drop_x, 20, drop_z)\n                            item.Physics:SetVel(0, -5, 0)\n                        end\n                    end)\n                end\n            end\n        end,\n        finish = function()\n            -- Nothing needed on finish\n        end,\n    },\n    \n    -- Monster attack event\n    monster_attack = {\n        name = "Monster Attack",\n        duration = 120,\n        start = function()\n            TheNet:Announce("Monster Attack! Defend yourself!")\n            \n            -- Spawn monsters near each player\n            for i, player in ipairs(AllPlayers) do\n                local x, y, z = player.Transform:GetWorldPosition()\n                \n                for j = 1, 5 do\n                    local angle = math.random() * 2 * PI\n                    local dist = 8 + math.random() * 5\n                    local spawn_x = x + math.cos(angle) * dist\n                    local spawn_z = z + math.sin(angle) * dist\n                    \n                    -- Choose a monster based on difficulty\n                    local monsters = {"spider", "hound", "tallbird"}\n                    local monster = monsters[math.random(#monsters)]\n                    \n                    local creature = SpawnPrefab(monster)\n                    if creature then\n                        creature.Transform:SetPosition(spawn_x, 0, spawn_z)\n                        \n                        -- Make monster target player\n                        if creature.components.combat then\n                            creature.components.combat:SetTarget(player)\n                        end\n                    end\n                end\n            end\n        end,\n        finish = function()\n            TheNet:Announce("The monster attack has subsided!")\n        end,\n    },\n}\n\n-- Event manager\nlocal function CreateEventManager()\n    local inst = CreateEntity()\n    \n    inst.entity:AddTransform()\n    inst.entity:AddNetwork()\n    \n    inst:AddTag("CLASSIFIED")\n    \n    inst.entity:SetPristine()\n    \n    if not TheWorld.ismastersim then\n        return inst\n    end\n    \n    inst.active_event = nil\n    inst.event_end_time = nil\n    \n    -- Start a random event\n    inst.StartRandomEvent = function(self)\n        if self.active_event then\n            return -- Event already active\n        end\n        \n        -- Choose a random event\n        local event_keys = {}\n        for k in pairs(Events) do\n            table.insert(event_keys, k)\n        end\n        \n        local event_key = event_keys[math.random(#event_keys)]\n        local event = Events[event_key]\n        \n        -- Start the event\n        self.active_event = event_key\n        self.event_end_time = GetTime() + event.duration\n        \n        event.start()\n        \n        -- Schedule event end\n        inst:DoTaskInTime(event.duration, function()\n            if self.active_event == event_key then\n                event.finish()\n                self.active_event = nil\n                self.event_end_time = nil\n            end\n        end)\n    end\n    \n    -- Schedule random events\n    inst:DoPeriodicTask(120 + math.random() * 180, function()\n        inst:StartRandomEvent()\n    end)\n    \n    return inst\nend\n\nreturn Prefab("resourcerace_eventmanager", CreateEventManager)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"team-based-game-modes",children:"Team-Based Game Modes"}),"\n",(0,r.jsx)(n.p,{children:"For team-based game modes, implement team functionality:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua\n-- Team setup\nlocal function SetupTeams(inst)\n    if TheWorld.ismastersim and TheNet:GetServerGameMode() == "TEAM_RESOURCE_RACE" then\n        TheWorld.teams = {\n            [1] = {name = "Red Team", color = {r=0.8, g=0.2, b=0.2}, members = {}, score = 0},\n            [2] = {name = "Blue Team", color = {r=0.2, g=0.2, b=0.8}, members = {}},\n        }\n        \n        -- Assign players to teams\n        local team_index = 1\n        for i, player in ipairs(AllPlayers) do\n            local team = TheWorld.teams[team_index]\n            \n            -- Add player to team\n            table.insert(team.members, player.userid)\n            \n            -- Set player color\n            player.components.colourtweener:StartTween(team.color, 0)\n            \n            -- Set team ID\n            player.team_id = team_index\n            \n            -- Alternate team assignment\n            team_index = team_index % #TheWorld.teams + 1\n        end\n        \n        -- Announce teams\n        for id, team in pairs(TheWorld.teams) do\n            local member_names = {}\n            for _, userid in ipairs(team.members) do\n                local player = UserToPlayer(userid)\n                if player then\n                    table.insert(member_names, player.name)\n                end\n            end\n            \n            TheNet:Announce(team.name .. ": " .. table.concat(member_names, ", "))\n        end\n    end\nend\n\n-- Add team score tracking\nlocal function OnTeamPickup(inst, data)\n    if TheWorld.ismastersim and TheNet:GetServerGameMode() == "TEAM_RESOURCE_RACE" then\n        local item = data.item\n        local player = inst\n        \n        if player.team_id and TheWorld.teams[player.team_id] then\n            local team = TheWorld.teams[player.team_id]\n            \n            -- Check if the item is a target resource\n            if TheWorld.resource_targets[item.prefab] then\n                team.score = team.score + 1\n                \n                -- Announce milestones\n                if team.score % 25 == 0 then\n                    TheNet:Announce(team.name .. " has collected " .. team.score .. " resources!")\n                end\n            end\n        end\n    end\nend\n\n-- Apply team setup on world initialization\nAddPrefabPostInit("world", SetupTeams)\n\n-- Listen for item pickups for team scoring\nAddPlayerPostInit(function(inst)\n    inst:ListenForEvent("itemget", function(inst, data)\n        OnTeamPickup(inst, data)\n    end)\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Balance"}),": Ensure your game mode is balanced and fun for all players"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clear Goals"}),": Make sure players understand the objectives and rules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Progression"}),": Include a sense of progression and achievement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variety"}),": Add random elements or events to increase replayability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Optimize for multiplayer performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Provide clear feedback on progress and status"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Thoroughly test with different player counts and scenarios"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronization problems"}),": Ensure all game state is properly synchronized between server and clients"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Balance issues"}),": Test with different player counts to ensure the game is fun for all group sizes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance problems"}),": Monitor server performance, especially with many players or complex events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unclear rules"}),": Make sure players understand how to play and win your game mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Save compatibility"}),": Handle save/load correctly if your game mode supports it"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"debugging-tips",children:"Debugging Tips"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Add debug commands to test your game mode\nGLOBAL.TheInput:AddKeyDownHandler(GLOBAL.KEY_F9, function()\n    if GLOBAL.TheWorld.ismastersim then\n        print("Debug: Triggering test event")\n        -- Test code here\n        TheWorld.event_manager:StartRandomEvent()\n    end\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Creating custom game modes allows you to fundamentally change how Don't Starve Together is played. By combining world generation settings, custom mechanics, UI elements, and win conditions, you can create unique experiences that extend the game in exciting new ways."}),"\n",(0,r.jsx)(n.p,{children:"Whether you're creating competitive challenges, cooperative adventures, or specialized survival scenarios, custom game modes offer endless possibilities for expanding the Don't Starve Together experience."}),"\n",(0,r.jsx)(n.p,{children:"See also:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/custom-world-generation",children:"Custom World Generation"})," - For creating specialized worlds for your game mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/custom-ai",children:"Custom AI and Brain Behaviors"})," - For creating specialized AI for your game mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/custom-ui-elements",children:"Custom UI Elements"})," - For creating game mode interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/custom-weather-effects",children:"Custom Weather Effects"})," - For adding atmospheric effects to your game mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/dst-api-webdocs/docs/api-vanilla/examples/network-optimization",children:"Network Optimization"})," - For optimizing multiplayer performance"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);