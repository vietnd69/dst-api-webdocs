"use strict";(self.webpackChunkdst_api_webdocs=self.webpackChunkdst_api_webdocs||[]).push([[8338],{6859:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-vanilla/core/rpc-system","title":"Remote Procedure Call System","description":"Remote Procedure Calls (RPCs) are a core feature of Don\'t Starve Together\'s networking architecture, enabling bidirectional communication between server and clients. Unlike network variables which are unidirectional (server to client), RPCs allow clients to send commands to the server and the server to send commands to specific clients.","source":"@site/docs/api-vanilla/core/rpc-system.md","sourceDirName":"api-vanilla/core","slug":"/api-vanilla/core/rpc-system","permalink":"/dst-api-webdocs/docs/api-vanilla/core/rpc-system","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"rpc-system","title":"Remote Procedure Call System","sidebar_position":7},"sidebar":"docs","previous":{"title":"Network System","permalink":"/dst-api-webdocs/docs/api-vanilla/core/network-system"},"next":{"title":"Mod Structure and Server Integration","permalink":"/dst-api-webdocs/docs/api-vanilla/core/mod-structure"}}');var a=r(4848),i=r(8453);const s={id:"rpc-system",title:"Remote Procedure Call System",sidebar_position:7},l="Remote Procedure Call System",o={},c=[{value:"RPC Overview",id:"rpc-overview",level:2},{value:"RPC Directions",id:"rpc-directions",level:2},{value:"Built-in RPC Categories",id:"built-in-rpc-categories",level:2},{value:"Defining Custom RPCs",id:"defining-custom-rpcs",level:2},{value:"Sending RPCs",id:"sending-rpcs",level:2},{value:"Client to Server",id:"client-to-server",level:3},{value:"Server to Specific Client",id:"server-to-specific-client",level:3},{value:"Server to All Clients",id:"server-to-all-clients",level:3},{value:"Handling RPCs",id:"handling-rpcs",level:2},{value:"Client-to-Server Handlers",id:"client-to-server-handlers",level:3},{value:"Server-to-Client Handlers",id:"server-to-client-handlers",level:3},{value:"RPC Parameter Types",id:"rpc-parameter-types",level:2},{value:"Common RPC Patterns",id:"common-rpc-patterns",level:2},{value:"Request-Response Pattern",id:"request-response-pattern",level:3},{value:"Action Confirmation Pattern",id:"action-confirmation-pattern",level:3},{value:"Advanced RPC Techniques",id:"advanced-rpc-techniques",level:2},{value:"RPC Batching",id:"rpc-batching",level:3},{value:"Area-Based RPC Broadcasting",id:"area-based-rpc-broadcasting",level:3},{value:"RPC Rate Limiting",id:"rpc-rate-limiting",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Debugging RPCs",id:"debugging-rpcs",level:2},{value:"Logging RPC Traffic",id:"logging-rpc-traffic",level:3},{value:"Tracing RPC Performance",id:"tracing-rpc-performance",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"remote-procedure-call-system",children:"Remote Procedure Call System"})}),"\n",(0,a.jsx)(n.p,{children:"Remote Procedure Calls (RPCs) are a core feature of Don't Starve Together's networking architecture, enabling bidirectional communication between server and clients. Unlike network variables which are unidirectional (server to client), RPCs allow clients to send commands to the server and the server to send commands to specific clients."}),"\n",(0,a.jsx)(n.h2,{id:"rpc-overview",children:"RPC Overview"}),"\n",(0,a.jsx)(n.p,{children:"RPCs serve several key purposes in Don't Starve Together:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Client-to-Server Communication"}),": Allow players to request actions (attacks, crafting, etc.)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Server-to-Client Communication"}),": Enable the server to trigger visual effects, sounds, or UI updates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Command Broadcasting"}),": Send information to all clients simultaneously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Targeted Messages"}),": Deliver information to specific clients"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"rpc-directions",children:"RPC Directions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- RPC direction constants\nRPC = {\n    Broadcast = 0,  -- Server to all clients\n    Target = 1,     -- Server to specific client\n    ToServer = 2    -- Client to server\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"built-in-rpc-categories",children:"Built-in RPC Categories"}),"\n",(0,a.jsx)(n.p,{children:"Don't Starve Together organizes RPCs into several categories:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Main RPC categories\nMAIN_RPC = {\n    PlayerActionPickup = 0,\n    PlayerActionPickupStack = 1,\n    PlayerActionPickupHalf = 2,\n    PlayerActionDropItem = 3,\n    PlayerActionDropItemFromContainer = 4,\n    -- Many more actions...\n}\n\n-- World RPC categories\nWORLD_RPC = {\n    Thunderstrike = 0,\n    Extinguish = 1,\n    PushExplosion = 2,\n    -- More world effects...\n}\n\n-- Character RPC categories\nCHARACTER_RPC = {\n    SetBuffEnabled = 0,\n    SetBuffLevel = 1,\n    -- Character-specific actions...\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"defining-custom-rpcs",children:"Defining Custom RPCs"}),"\n",(0,a.jsx)(n.p,{children:"For mods, you can define your own RPC messages:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- In modmain.lua\nMOD_RPC = {\n    MyMod = {\n        DoSpecialAttack = 0,\n        RequestData = 1,\n        UpdateUI = 2,\n        -- Additional RPCs...\n    }\n}\n\n-- Name conventions are important:\n-- ModName = your mod's folder name\n-- ActionName = descriptive name for the RPC\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sending-rpcs",children:"Sending RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"client-to-server",children:"Client to Server"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Basic client-to-server RPC\nSendModRPCToServer(MOD_RPC.MyMod.DoSpecialAttack, target_entity, damage_multiplier)\n\n-- Client requesting data from server\nSendModRPCToServer(MOD_RPC.MyMod.RequestData, "player_stats")\n\n-- Client informing server of a selection\nSendModRPCToServer(MOD_RPC.MyMod.SelectOption, option_id)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-specific-client",children:"Server to Specific Client"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Send RPC to a specific client (by userid/player entity)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateUI, player, "health", current_health, max_health)\n\n-- Send RPC to client with additional parameters\nSendModRPCToClient(MOD_RPC.MyMod.ShowEffect, player, effect_name, x, y, z, scale)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-all-clients",children:"Server to All Clients"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Broadcast RPC to all clients\nSendModRPCToClients(MOD_RPC.MyMod.WorldEvent, "earthquake", intensity, duration)\n\n-- Broadcast position-based effect\nlocal x, y, z = inst.Transform:GetWorldPosition()\nSendModRPCToClients(MOD_RPC.MyMod.SpawnEffect, "explosion", x, y, z)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"handling-rpcs",children:"Handling RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"client-to-server-handlers",children:"Client-to-Server Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua (server-side handler)\nAddModRPCHandler("MyMod", "DoSpecialAttack", function(player, target, multiplier)\n    -- Validate player can perform this action\n    if player.components.health:IsDead() or player:HasTag("playerghost") then\n        return\n    end\n    \n    -- Find target entity\n    local target_ent = Ents[target]\n    if target_ent == nil then\n        return\n    end\n    \n    -- Execute the action\n    if player.components.combat ~= nil then\n        local damage = player.components.combat.defaultdamage * multiplier\n        player.components.combat:DoAttack(target_ent, nil, nil, nil, damage)\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"server-to-client-handlers",children:"Server-to-Client Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- In modmain.lua (client-side handler)\nAddClientModRPCHandler("MyMod", "UpdateUI", function(health_name, current, maximum)\n    -- Update UI element with new health value\n    if health_name == "health" then\n        UpdateHealthBar(current, maximum)\n    elseif health_name == "sanity" then\n        UpdateSanityBar(current, maximum)\n    elseif health_name == "hunger" then\n        UpdateHungerBar(current, maximum)\n    end\nend)\n\n-- Handler for visual effects\nAddClientModRPCHandler("MyMod", "ShowEffect", function(effect_name, x, y, z, scale)\n    -- Spawn a client-side visual effect\n    local fx = SpawnPrefab(effect_name)\n    if fx ~= nil then\n        fx.Transform:SetPosition(x, y, z)\n        if scale ~= nil then\n            fx.Transform:SetScale(scale, scale, scale)\n        end\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rpc-parameter-types",children:"RPC Parameter Types"}),"\n",(0,a.jsx)(n.p,{children:"RPCs support several parameter types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Supported RPC parameter types\n-- Number (float/integer)\nSendModRPCToServer(MOD_RPC.MyMod.Example, 42, 3.14)\n\n-- Boolean\nSendModRPCToServer(MOD_RPC.MyMod.Example, true, false)\n\n-- String\nSendModRPCToServer(MOD_RPC.MyMod.Example, "player_name", "action_type")\n\n-- Entity references (as EntityScript or EntityID)\nSendModRPCToServer(MOD_RPC.MyMod.Example, target_entity, target_entity.entity:GetGUID())\n\n-- Vector3 (as three separate parameters)\nlocal x, y, z = inst.Transform:GetWorldPosition()\nSendModRPCToServer(MOD_RPC.MyMod.Example, x, y, z)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"common-rpc-patterns",children:"Common RPC Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"request-response-pattern",children:"Request-Response Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client requesting data\n-- 1. Define RPCs\nMOD_RPC = {\n    MyMod = {\n        RequestPlayerData = 0,\n        ReceivePlayerData = 1,\n    }\n}\n\n-- 2. Client sends request\nSendModRPCToServer(MOD_RPC.MyMod.RequestPlayerData, target_player.userid)\n\n-- 3. Server handles request and responds\nAddModRPCHandler("MyMod", "RequestPlayerData", function(player, target_userid)\n    -- Find target player\n    local target = nil\n    for _, v in ipairs(AllPlayers) do\n        if v.userid == target_userid then\n            target = v\n            break\n        end\n    end\n    \n    if target ~= nil then\n        -- Collect data\n        local data = {\n            health = target.components.health.currenthealth,\n            sanity = target.components.sanity.current,\n            hunger = target.components.hunger.current,\n        }\n        \n        -- Send response back to requesting client\n        SendModRPCToClient(MOD_RPC.MyMod.ReceivePlayerData, player, \n            target.userid, data.health, data.sanity, data.hunger)\n    end\nend)\n\n-- 4. Client handles response\nAddClientModRPCHandler("MyMod", "ReceivePlayerData", function(userid, health, sanity, hunger)\n    -- Update UI with received data\n    UpdatePlayerStatusDisplay(userid, health, sanity, hunger)\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"action-confirmation-pattern",children:"Action Confirmation Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- 1. Define RPCs\nMOD_RPC = {\n    MyMod = {\n        AttemptSpecialAction = 0,\n        ConfirmSpecialAction = 1,\n    }\n}\n\n-- 2. Client requests action\nSendModRPCToServer(MOD_RPC.MyMod.AttemptSpecialAction, target_position.x, target_position.z)\n\n-- 3. Server validates and confirms\nAddModRPCHandler("MyMod", "AttemptSpecialAction", function(player, x, z)\n    -- Check if player can perform action\n    if not CanPerformSpecialAction(player, x, z) then\n        return\n    end\n    \n    -- Perform the action\n    local success = DoSpecialAction(player, x, z)\n    \n    -- Confirm back to client\n    SendModRPCToClient(MOD_RPC.MyMod.ConfirmSpecialAction, player, success, x, z)\nend)\n\n-- 4. Client handles confirmation\nAddClientModRPCHandler("MyMod", "ConfirmSpecialAction", function(success, x, z)\n    if success then\n        -- Play success effects\n        SpawnPrefab("special_action_fx").Transform:SetPosition(x, 0, z)\n    else\n        -- Play failure animation\n        ThePlayer.AnimState:PlayAnimation("special_action_fail")\n    end\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-rpc-techniques",children:"Advanced RPC Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"rpc-batching",children:"RPC Batching"}),"\n",(0,a.jsx)(n.p,{children:"For multiple related updates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Instead of multiple RPCs:\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "health", 100)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "sanity", 200)\nSendModRPCToClient(MOD_RPC.MyMod.UpdateStat, player, "hunger", 150)\n\n-- Use a single batched RPC:\nSendModRPCToClient(MOD_RPC.MyMod.UpdateAllStats, player, 100, 200, 150)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"area-based-rpc-broadcasting",children:"Area-Based RPC Broadcasting"}),"\n",(0,a.jsx)(n.p,{children:"Send RPCs only to nearby players:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Find players within range of an effect\nlocal x, y, z = inst.Transform:GetWorldPosition()\nlocal nearby_players = FindPlayersInRange(x, y, z, TUNING.MAX_RPC_RANGE)\n\n-- Send RPC only to nearby players\nfor _, player in ipairs(nearby_players) do\n    SendModRPCToClient(MOD_RPC.MyMod.LocalEffect, player, "earthquake", x, y, z)\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"rpc-rate-limiting",children:"RPC Rate Limiting"}),"\n",(0,a.jsx)(n.p,{children:"Prevent RPC spam:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client-side rate limiting\nlocal last_request_time = 0\n\nlocal function TryRequestAction()\n    local current_time = GetTime()\n    if current_time - last_request_time < MIN_REQUEST_INTERVAL then\n        return false\n    end\n    \n    last_request_time = current_time\n    SendModRPCToServer(MOD_RPC.MyMod.RequestAction)\n    return true\nend\n\n-- Server-side rate limiting\nlocal player_request_times = {}\n\nAddModRPCHandler("MyMod", "RequestAction", function(player)\n    local userid = player.userid\n    local current_time = GetTime()\n    \n    if player_request_times[userid] and \n       current_time - player_request_times[userid] < MIN_REQUEST_INTERVAL then\n        -- Ignore too-frequent requests\n        return\n    end\n    \n    player_request_times[userid] = current_time\n    -- Process the request\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When implementing RPCs, always consider security:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate Permissions"}),": Check if player has permission to perform action"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Verify Input"}),": Validate all RPC parameters before using them"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check Entity Ownership"}),": Ensure player is authorized to control an entity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement Rate Limiting"}),": Prevent RPC spam attacks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't Trust Clients"}),": Always validate actions on the server"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Example of secure RPC handling\nAddModRPCHandler("MyMod", "HarvestCrop", function(player, crop_entity)\n    -- Validate crop exists\n    local crop = Ents[crop_entity]\n    if crop == nil then return end\n    \n    -- Check distance (prevent cheating)\n    local player_x, player_y, player_z = player.Transform:GetWorldPosition()\n    local crop_x, crop_y, crop_z = crop.Transform:GetWorldPosition()\n    local dist_sq = distsq(player_x, player_z, crop_x, crop_z)\n    \n    if dist_sq > TUNING.MAX_HARVEST_DISTANCE * TUNING.MAX_HARVEST_DISTANCE then\n        return -- Too far away\n    end\n    \n    -- Check if crop is ready\n    if not crop.components.crop.mature then\n        return -- Not ready for harvest\n    end\n    \n    -- All checks passed, allow harvest\n    crop.components.crop:Harvest(player)\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-rpcs",children:"Debugging RPCs"}),"\n",(0,a.jsx)(n.h3,{id:"logging-rpc-traffic",children:"Logging RPC Traffic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Add debug logging to RPC handlers\nAddModRPCHandler("MyMod", "ExampleRPC", function(player, ...)\n    local args = {...}\n    print("Received ExampleRPC from " .. player:GetDisplayName())\n    for i, arg in ipairs(args) do\n        print("  Arg " .. i .. ": " .. tostring(arg))\n    end\n    \n    -- Process RPC normally\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tracing-rpc-performance",children:"Tracing RPC Performance"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Measure RPC processing time\nAddModRPCHandler("MyMod", "HeavyProcessing", function(player, ...)\n    local start_time = GetTimeReal()\n    \n    -- Normal processing\n    local result = DoHeavyProcessing(...)\n    \n    local end_time = GetTimeReal()\n    print("HeavyProcessing RPC took " .. (end_time - start_time) * 1000 .. " ms")\n    \n    return result\nend)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use Appropriate Direction"}),": Choose the correct RPC direction for your needs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Minimize RPC Count"}),": Batch related operations into single RPCs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate All Input"}),": Never trust client-sent RPC parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check Permissions"}),": Verify player can perform the requested action"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle Failures Gracefully"}),": Provide feedback when RPCs can't be processed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Document Your RPCs"}),": Keep clear documentation of each RPC's purpose and parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Consistent Naming"}),": Use clear, consistent naming for your RPC identifiers"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);